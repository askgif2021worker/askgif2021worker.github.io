{"id":104,"title":"How to implement InOrder Traversal in Binary Tree?","imageUrl":"bf7ea477-0b3a-4e79-9923-feb2fab2a727_inorder_traversal in Java.jpg","dateCreated":"2018-08-09T14:17:47.233Z","dateModified":"2018-08-09T14:28:44.293Z","contributedBy":"AskGif","content":"<p>The Technique for traversal in an Inorder is slightly different from what we were doing in PreOrder Traversal. Here we go through left node, then data and then the right node.</p>\r\n<p>In an InOrder traversal, the root is visited between the subtrees. InOrder traversal is defined as follows:</p>\r\n<p>- Traverse the left subtree in InOrder.</p>\r\n<p>- Visit the root.</p>\r\n<p>- Traverse the right subtree in InOrder.</p>\r\n<p>Java Code for above Implementation is as below:</p>\r\n<pre class=\"language-java\"><code>package askgif.tree;\r\n\r\nclass Node\r\n{\r\n    int data;\r\n    Node left, right;\r\n \r\n    public Node(int item)\r\n    {\r\n        data = item;\r\n        left = right = null;\r\n    }\r\n}\r\n\r\nclass BinaryTree\r\n{\r\n    Node root;\r\n \r\n    BinaryTree()\r\n    {\r\n        root = null;\r\n    }\r\n    \r\n}\r\n\r\npublic class TreeQuestions {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tBinaryTree binaryTree = new BinaryTree();\r\n\t\tNode root = new Node(1);\r\n\t\tbinaryTree.root = root;\r\n\t\tbinaryTree.root.left = new Node(2);\r\n\t\tbinaryTree.root.right = new Node(3);\r\n\t\tbinaryTree.root.left.left = new Node(4);\r\n\t\tbinaryTree.root.left.right = new Node(5);\r\n        \r\n        PrintInOrderTraversal(root);\r\n\r\n\t}\r\n\r\n\tprivate static void PrintInOrderTraversal(Node treeNode) {\r\n\t\tif(treeNode == null)\r\n\t\t\treturn;\r\n\t\tPrintInOrderTraversal(treeNode.left);\r\n\t\tSystem.out.println(treeNode.data);\r\n\t\tPrintInOrderTraversal(treeNode.right);\r\n\t\t\r\n\t}\r\n\r\n}\r\n</code></pre>\r\n<pre class=\"language-markup\"><code>4\r\n2\r\n5\r\n1\r\n3\r\n</code></pre>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/bf7ea477-0b3a-4e79-9923-feb2fab2a727_inorder_traversal in Java.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"how-to-implement-inorder-traversal-in-binary-tree","tags":[{"name":"traversal","slug":"traversal"},{"name":"interview","slug":"interview"},{"name":"questions","slug":"questions"},{"name":"recursion","slug":"recursion"},{"name":"inorder","slug":"inorder"},{"name":"java","slug":"java"},{"name":"tree","slug":"tree"}],"recommendations":[{"id":1574,"title":"Find Mode in Binary Search Tree - Tree - Easy - LeetCode","imageUrl":"icon_7e61ce7c-697d-4270-8d1b-f48c3bda649b.jpg","dateCreated":"2020-10-07T05:05:11.566Z","dateModified":"2020-10-07T05:05:22.255Z","contributedBy":"sumitc91","content":"Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.\nAssume a BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than or equal to the node's key.<br />The right subtree o","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/7e61ce7c-697d-4270-8d1b-f48c3bda649b.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"find-mode-in-binary-search-tree-tree-easy-leetcode","total":0},{"id":1572,"title":"Binary Tree Paths - Tree - Easy - LeetCode","imageUrl":"icon_93874631-b0aa-4d7d-a413-084a6380763d.jpg","dateCreated":"2020-10-06T14:22:08.31Z","dateModified":"2020-10-06T14:22:21.599Z","contributedBy":"sumitc91","content":"Given a binary tree, return all root-to-leaf paths.\nNote: A leaf is a node with no children.\nExample:\nInput:\n&nbsp; &nbsp;1<br />&nbsp;/ &nbsp; \\<br />2 &nbsp; &nbsp; 3<br />&nbsp;\\<br />&nbsp; 5\nOutput: [\"1-&gt;2-&gt;5\", \"1-&gt;3\"]\nExplanation: All root-","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/93874631-b0aa-4d7d-a413-084a6380763d.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"binary-tree-paths-tree-easy-leetcode","total":0},{"id":40,"title":"Maximize House Robbery Amount that can be made.","imageUrl":"2c7d01cc-e4f1-489a-b1c8-572f0ae4224f_robbery.jpg","dateCreated":"2018-07-20T09:39:03.571Z","dateModified":"2018-07-20T09:39:12.736Z","contributedBy":"AskGif","content":"Given that you are a professional robber who is planning to rob houses along a street. Constraint given is that each house has a certain amount of money stashed, and adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/2c7d01cc-e4f1-489a-b1c8-572f0ae4224f_robbery.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"java","slug":"java"},{"name":"dynamic-programming","slug":"dynamic-programming"},{"name":"algorithm","slug":"algorithm"},{"name":"interview","slug":"interview"}],"slug":"maximize-house-robbery-amount-that-can-be-made","total":0},{"id":37,"title":"Find Longest Sub-string without any Repeating characters.","imageUrl":"28ea9b8b-1280-4d6a-8f2f-48f61377a5e2_maxresdefault.jpg","dateCreated":"2018-07-20T06:23:31.49Z","dateModified":"2018-07-20T06:23:41.247Z","contributedBy":"AskGif","content":"A substring is a contiguous sequence of characters within a string. For instance, \"the best of\" is a substring of \"It was the best of times\". This is not to be confused with subsequence, which is a generalization of a substring. For example, \"Itwastimes\" is a subsequence of \"It was the best of ti","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/28ea9b8b-1280-4d6a-8f2f-48f61377a5e2_maxresdefault.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"string","slug":"string"},{"name":"java","slug":"java"},{"name":"interview","slug":"interview"},{"name":"algorithm","slug":"algorithm"}],"slug":"find-longest-sub-string-without-any-repeating-characters","total":0}]}