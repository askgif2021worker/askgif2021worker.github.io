{"id":111,"title":"Find maximum element in binary tree without recursion.","imageUrl":"852f8357-9b87-4af3-9054-484bbc13f1fd_BST_Example.jpg","dateCreated":"2018-08-16T08:35:11.21Z","dateModified":"2018-08-16T08:36:54.976Z","contributedBy":"AskGif","content":"<p>We could have used either PreOrder, InOrder or PostOrder traversal to find the maximum in a Tree but as it is mentioned that we need to find the maximum without using Recursion.</p>\r\n<p>Using Level Order Traversal we can find the Maximum element. We just need to observe the elements data while deleting.</p>\r\n<p>Java Implementation is as below:</p>\r\n<pre class=\"language-java\"><code>package askgif.tree;\r\n\r\nimport java.util.LinkedList;\r\nimport java.util.Queue;\r\n\r\nclass Node\r\n{\r\n    int data;\r\n    Node left, right;\r\n \r\n    public Node(int item)\r\n    {\r\n        data = item;\r\n        left = right = null;\r\n    }\r\n}\r\n\r\nclass BinaryTree\r\n{\r\n    Node root;\r\n \r\n    BinaryTree()\r\n    {\r\n        root = null;\r\n    }\r\n    \r\n}\r\n\r\npublic class TreeQuestions {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tBinaryTree binaryTree = new BinaryTree();\r\n\t\tNode root = new Node(1);\r\n\t\tbinaryTree.root = root;\r\n\t\tbinaryTree.root.left = new Node(2);\r\n\t\tbinaryTree.root.right = new Node(3);\r\n\t\t\r\n\t\tbinaryTree.root.left.left = new Node(4);\r\n\t\tbinaryTree.root.left.right = new Node(5);\r\n        \r\n        System.out.println(FindMaxElement(root));\r\n\r\n\t}\r\n\r\n\tprivate static int FindMaxElement(Node treeNode) {\r\n\t\tif(treeNode == null)\r\n\t\t\treturn -1;\r\n\t\t\r\n\t\tQueue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();\r\n\t\tqueue.add(treeNode);\r\n\t\tint max = -1;\r\n\t\twhile(!queue.isEmpty()) {\r\n\t\t\tNode temp = queue.remove();\r\n\t\t\tif(temp.data &gt; max)\r\n\t\t\t\tmax = temp.data;\r\n\t\t\tif(temp.left != null)\r\n\t\t\t\tqueue.add(temp.left);\r\n\t\t\tif(temp.right != null)\r\n\t\t\t\tqueue.add(temp.right);\r\n\t\t}\r\n\t\t\r\n\t\treturn max;\r\n\t}\r\n\r\n}\r\n</code></pre>\r\n<pre class=\"language-markup\"><code>output:\r\n\r\n5</code></pre>\r\n<p>Time Complexity: O(n) as we are traversing through each node once.</p>\r\n<p>Space Complexity: O(n) for Queue.</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/852f8357-9b87-4af3-9054-484bbc13f1fd_BST_Example.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"find-maximum-element-in-binary-tree-without-recursion","tags":[{"name":"level-order","slug":"level-order"},{"name":"tree","slug":"tree"},{"name":"प्रशन","slug":"questions"},{"name":"binary-tree","slug":"binary-tree"},{"name":"algorithm","slug":"algorithm"},{"name":"interview","slug":"interview"},{"name":"traversal","slug":"traversal"}],"recommendations":[{"id":1697,"title":"रिवर्स प्रॉक्सी (वेब \\u200b\\u200bसर्वर) क्या है","imageUrl":"icon_c9b9941f-ccf0-43b6-8c8d-af837fe0b02d.jpg","dateCreated":"2020-11-20T07:38:40.516Z","dateModified":"2020-11-20T07:38:45.525Z","contributedBy":"sumitc91","content":"रिवर्स प्रॉक्सी एक वेब सर्वर है जो आंतरिक सेवाओं को केंद्रीकृत करता है और जनता को एकीकृत इंटरफेस प्रदान करता है। क्लाइंट से अनुरोधों को एक सर्वर पर भेजा जाता है, जो रिवर्स प्रॉक्सी के क्लाइंट के सर्वर के जवाब को वापस करने से पहले इसे पूरा कर सकता है।\nअतिरिक्त लाभों में शामिल हैं:\nबढ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/c9b9941f-ccf0-43b6-8c8d-af837fe0b02d.jpg","category":{"name":"शिक्षण","slug":"tutorials"},"tags":[{"name":"interview","slug":"interview"}],"slug":"what-is-reverse-proxy-web-server","total":0},{"id":1695,"title":"सामग्री वितरण नेटवर्क (CDN)","imageUrl":"icon_57adef3f-d788-4753-bda7-a12a6bc0d462.jpg","dateCreated":"2020-11-20T07:35:23.915Z","dateModified":"2020-11-20T07:35:35.322Z","contributedBy":"sumitc91","content":"एक कंटेंट डिलीवरी नेटवर्क (CDN) प्रॉक्सी सर्वर का एक विश्व स्तर पर वितरित नेटवर्क है, जो उपयोगकर्ता के नज़दीकी स्थानों से सामग्री परोसता है। आम तौर पर, HTML / CSS / JS जैसी स्थिर फाइलें, फ़ोटो और वीडियो CDN से लिए जाते हैं, हालाँकि कुछ CDN जैसे कि Amazon के CloudFront डायनामिक कंटेंट को सपोर्ट कर","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/57adef3f-d788-4753-bda7-a12a6bc0d462.jpg","category":{"name":"शिक्षण","slug":"tutorials"},"tags":[{"name":"interview","slug":"interview"}],"slug":"content-delivery-network-cdn","total":0},{"id":1625,"title":"Print in Order - Multi Threading - Easy - LeetCode","imageUrl":"icon_3e17a90d-8d3d-4655-9ad5-34bee8157e21.jpg","dateCreated":"2020-10-18T04:04:15.138Z","dateModified":"2020-10-18T04:04:52.636Z","contributedBy":"sumitc91","content":"Suppose we have a class:\npublic class Foo {<br />&nbsp; public void first() { print(\"first\"); }<br />&nbsp; public void second() { print(\"second\"); }<br />&nbsp; public void third() { print(\"third\"); }<br />}<br />The same instance of Foo will be passed to three different threads. Thread A","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/3e17a90d-8d3d-4655-9ad5-34bee8157e21.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"multi-threading","slug":"multi-threading"}],"slug":"print-in-order-multi-threading-easy-leetcode","total":0},{"id":1609,"title":"Customers Who Never Order - Sql - Easy - LeetCode","imageUrl":"icon_3979029e-3ead-4244-a16d-a1344d80e6ec.jpg","dateCreated":"2020-10-16T07:20:40.745Z","dateModified":"2020-10-16T07:20:46.124Z","contributedBy":"sumitc91","content":"Suppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything.\nTable: Customers.\n+----+-------+<br />| Id | Name &nbsp;|<br />+----+-------+<br />| 1 &nbsp;| Joe &nbsp; |<br />| 2 &nbsp;| Henry ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/3979029e-3ead-4244-a16d-a1344d80e6ec.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"mysql","slug":"mysql"},{"name":"sql","slug":"sql"}],"slug":"customers-who-never-order-sql-easy-leetcode","total":0}]}