{"id":1226,"title":"Two sum problem ( Without Repeating Numbers )","imageUrl":"c97dbea6-3c4a-4210-a63d-c49baa1870bf_two-sum.jpg","dateCreated":"2020-04-18T06:50:55.346Z","dateModified":"2020-04-18T07:28:48.486Z","contributedBy":"AskGif","content":"<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>\r\n<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>\r\n<p>Example:</p>\r\n<pre class=\"language-csharp\"><code>Given nums = [2, 7, 11, 15], target = 9,\r\n\r\nBecause nums[0] + nums[1] = 2 + 7 = 9,\r\nreturn [0, 1].</code></pre>\r\n<p>&nbsp;</p>\r\n<p>Solution:</p>\r\n<pre class=\"language-csharp\"><code>using System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace LeetCode.Easy\r\n{\r\n    class TwoSumSolution\r\n    {\r\n        public int[] TwoSum(int[] nums, int target)\r\n        {\r\n            var dict = new Dictionary&lt;int, int&gt;();\r\n            var sumSetIndex = new int[2];\r\n            for (int i=0;i&lt;nums.Length;i++)\r\n            {                \r\n                dict.Add(nums[i], i);                              \r\n            }\r\n\r\n            foreach (var num in nums)\r\n            {\r\n                if (dict.ContainsKey(num))\r\n                {                    \r\n                    if(dict.ContainsKey(target - num))\r\n                    {\r\n                        sumSetIndex[0] = dict[num];\r\n                        sumSetIndex[1] = dict[target - num];                            \r\n                    }                    \r\n                }\r\n            }\r\n\r\n            return sumSetIndex;\r\n        }\r\n    }\r\n}</code></pre>\r\n<p>Time Complexity: O(n) - For a complete Iteration of N Numbers.</p>\r\n<p>Space Complexity: O(n) - For HashMap</p>\r\n<p>&nbsp;</p>\r\n<p>Detail:&nbsp;<a title=\"https://github.com/sumitc91/coding/blob/master/Coding/LeetCode/Easy/TwoSumSolutionDuplicateAllowed.cs\" href=\"https://github.com/sumitc91/coding/blob/master/Coding/LeetCode/Easy/TwoSumSolutionDuplicateAllowed.cs\" target=\"_blank\" rel=\"noopener\">https://github.com/sumitc91/coding/blob/master/Coding/LeetCode/Easy/TwoSumSolutionDuplicateAllowed.cs</a></p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/c97dbea6-3c4a-4210-a63d-c49baa1870bf_two-sum.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"two-sum-problem-without-repeating-numbers-","tags":[{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"data-structure","slug":"data-structure"},{"name":"algorithm","slug":"algorithm"}],"recommendations":[{"id":1671,"title":"Find Peak Element - Array - Medium - LeetCode","imageUrl":"icon_ddbfc17c-bd5c-47a2-8c7d-53508db12cab.jpg","dateCreated":"2020-11-18T07:03:05.436Z","dateModified":"2020-11-18T07:03:11.729Z","contributedBy":"sumitc91","content":"A peak element is an element that is greater than its neighbors.\nGiven an input array nums, where nums[i] &ne; nums[i+1], find a peak element and return its index.\nThe array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\nYou may ima","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/ddbfc17c-bd5c-47a2-8c7d-53508db12cab.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"find-peak-element-array-medium-leetcode","total":0},{"id":1625,"title":"Print in Order - Multi Threading - Easy - LeetCode","imageUrl":"icon_3e17a90d-8d3d-4655-9ad5-34bee8157e21.jpg","dateCreated":"2020-10-18T04:04:15.138Z","dateModified":"2020-10-18T04:04:52.636Z","contributedBy":"sumitc91","content":"Suppose we have a class:\npublic class Foo {<br />&nbsp; public void first() { print(\"first\"); }<br />&nbsp; public void second() { print(\"second\"); }<br />&nbsp; public void third() { print(\"third\"); }<br />}<br />The same instance of Foo will be passed to three different threads. Thread A","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/3e17a90d-8d3d-4655-9ad5-34bee8157e21.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"multi-threading","slug":"multi-threading"}],"slug":"print-in-order-multi-threading-easy-leetcode","total":0},{"id":1596,"title":"Sum of Root To Leaf Binary Numbers - Tree - Easy - LeetCode","imageUrl":"icon_41e87329-1dad-4856-9c47-60b67b520656.jpg","dateCreated":"2020-10-09T09:37:18.648Z","dateModified":"2020-10-09T09:37:29.591Z","contributedBy":"sumitc91","content":"You are given the root of a binary tree where each node has a value 0 or 1. &nbsp;Each root-to-leaf path represents a binary number starting with the most significant bit. &nbsp;For example, if the path is 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1, then this could represent 01101 in binary, which is 13.<","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/41e87329-1dad-4856-9c47-60b67b520656.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"sum-of-root-to-leaf-binary-numbers-tree-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}