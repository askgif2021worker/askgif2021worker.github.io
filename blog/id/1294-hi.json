{"id":1294,"title":"Count Binary Substrings","imageUrl":"2426b649-4f7c-4d32-8c9a-9201b1f2886d-q3.jpg","dateCreated":"2020-05-10T13:02:35.408Z","dateModified":"2020-05-10T13:02:48.971Z","contributedBy":"AskGif","content":"<p>Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.</p>\r\n<p>Substrings that occur multiple times are counted the number of times they occur.</p>\r\n<p>&nbsp;</p>\r\n<p>Example 1:</p>\r\n<pre class=\"language-markup\"><code>Input: \"00110011\"\r\n\r\nOutput: 6\r\n\r\nExplanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\r\n\r\nNotice that some of these substrings repeat and are counted the number of times they occur.\r\n\r\nAlso, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together.</code></pre>\r\n<p>&nbsp;</p>\r\n<p>Example 2:</p>\r\n<pre class=\"language-markup\"><code>Input: \"10101\"\r\n\r\nOutput: 4\r\n\r\nExplanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's.</code></pre>\r\n<p>&nbsp;</p>\r\n<p>Note:</p>\r\n<pre class=\"language-markup\"><code>s.length will be between 1 and 50,000.\r\n\r\ns will only consist of \"0\" or \"1\" characters.</code></pre>\r\n<p>&nbsp;</p>\r\n<p>Solution:</p>\r\n<pre class=\"language-csharp\"><code>using System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace LeetCode.AskGif.Easy.String\r\n{\r\n    public class CountBinarySubstringsSoln\r\n    {\r\n        public int CountBinarySubstrings(string s)\r\n        {\r\n            var groups = new int[s.Length];\r\n            groups[0] = 1;\r\n            int j = 0;\r\n            for (int i = 1; i &lt; s.Length; i++)\r\n            {\r\n                if(s[i-1] != s[i])\r\n                {\r\n                    j++;\r\n                    groups[j] = 1;\r\n                }\r\n                else\r\n                {\r\n                    groups[j]++;\r\n                }\r\n            }\r\n\r\n            int sum = 0;\r\n            for (int i = 1; i &lt; s.Length; i++)\r\n            {\r\n                sum += Math.Min(groups[i - 1], groups[i]);\r\n            }\r\n\r\n            return sum;\r\n        }\r\n\r\n        \r\n    }\r\n}\r\n</code></pre>\r\n<p>&nbsp;</p>\r\n<p>Time Complexity: O(n)</p>\r\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/2426b649-4f7c-4d32-8c9a-9201b1f2886d-q3.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"count-binary-substrings","tags":[{"name":"leetcode","slug":"leetcode"},{"name":"algorithm","slug":"algorithm"},{"name":"string","slug":"string"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"}],"recommendations":[{"id":1707,"title":"Maximum Repeating Substring - String - Easy - LeetCode","imageUrl":"icon_6c2a7180-5aaa-46ea-9f10-28d9ae8d0784.jpg","dateCreated":"2020-12-02T09:09:18.46Z","dateModified":"2020-12-02T09:09:24.372Z","contributedBy":"sumitc91","content":"For a string sequence, a string word is k-repeating if word concatenated k times is a substring of sequence. The word's maximum k-repeating value is the highest value k where word is k-repeating in sequence. If word is not a substring of sequence, word's maximum k-repeating value is 0.\nGiv","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/6c2a7180-5aaa-46ea-9f10-28d9ae8d0784.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"maximum-repeating-substring-string-easy-leetcode","total":0},{"id":1643,"title":"Rotate Image - Array - Medium - LeetCode","imageUrl":"icon_1aaf92bb-a6af-4473-a7da-686247f16016.jpg","dateCreated":"2020-10-26T13:36:30.021Z","dateModified":"2020-10-26T13:36:36.406Z","contributedBy":"sumitc91","content":"You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n&nbsp;\nExample 1:","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/1aaf92bb-a6af-4473-a7da-686247f16016.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"rotate-image-array-medium-leetcode","total":0},{"id":1599,"title":"Flower Planting With No Adjacent - Graph - Easy - LeetCode","imageUrl":"icon_db7a0ad4-994c-4a3a-a3c6-63035a00d2da.jpg","dateCreated":"2020-10-15T05:15:37.382Z","dateModified":"2020-10-15T05:15:47.948Z","contributedBy":"sumitc91","content":"You have n gardens, labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes the existence of a bidirectional path from garden xi to garden yi. In each garden, you want to plant one of 4 types of flowers.\nThere is no garden that has more than three paths coming into or l","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/db7a0ad4-994c-4a3a-a3c6-63035a00d2da.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"graph","slug":"graph"},{"name":"leetcode","slug":"leetcode"}],"slug":"flower-planting-with-no-adjacent-graph-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}