{"id":1334,"title":"Find Lucky Integer in an Array - Easy - LeetCode","imageUrl":"c62b8e48-2550-4bff-a335-20c9f848f4b3-array.png","dateCreated":"2020-06-06T08:38:42.428Z","dateModified":"2020-06-06T08:39:18.761Z","contributedBy":"AskGif","content":"<p>Given an array of integers arr, a lucky integer is an integer which has a frequency in the array equal to its value.</p>\r\n<p>Return a lucky integer in the array. If there are multiple lucky integers return the largest of them. If there is no lucky integer return -1.</p>\r\n<p>&nbsp;</p>\r\n<p>Example 1:</p>\r\n<p>Input: arr = [2,2,3,4]</p>\r\n<p>Output: 2</p>\r\n<p>Explanation: The only lucky number in the array is 2 because frequency[2] == 2.</p>\r\n<p>&nbsp;</p>\r\n<p>Example 2:</p>\r\n<p>Input: arr = [1,2,2,3,3,3]</p>\r\n<p>Output: 3</p>\r\n<p>Explanation: 1, 2, and 3 are all lucky numbers, return the largest of them.</p>\r\n<p>&nbsp;</p>\r\n<p>Example 3:</p>\r\n<p>Input: arr = [2,2,2,3,3]</p>\r\n<p>Output: -1</p>\r\n<p>Explanation: There are no lucky numbers in the array.</p>\r\n<p>&nbsp;</p>\r\n<p>Example 4:</p>\r\n<p>Input: arr = [5]</p>\r\n<p>Output: -1</p>\r\n<p>&nbsp;</p>\r\n<p>Example 5:</p>\r\n<p>Input: arr = [7,7,7,7,7,7,7]</p>\r\n<p>Output: 7</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>Constraints:</p>\r\n<p>1 &lt;= arr.length &lt;= 500</p>\r\n<p>1 &lt;= arr[i] &lt;= 500</p>\r\n<p>&nbsp;</p>\r\n<p>Solution:</p>\r\n<pre class=\"language-csharp\"><code>using System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace LeetCode.AskGif.Easy.Array\r\n{\r\n    public class FindLuckySoln\r\n    {\r\n        public int FindLucky(int[] arr)\r\n        {\r\n            var map = new Dictionary&lt;int, int&gt;();\r\n            for (int i = 0; i &lt; arr.Length; i++)\r\n            {\r\n                if (map.ContainsKey(arr[i]))\r\n                {\r\n                    map[arr[i]]++;\r\n                }\r\n                else\r\n                {\r\n                    map.Add(arr[i], 1);\r\n                }\r\n            }\r\n\r\n            int max = -1;\r\n            foreach (var item in map)\r\n            {\r\n                if(item.Key == item.Value &amp;&amp; item.Key &gt; max)\r\n                {\r\n                    max = item.Key;\r\n                }\r\n            }\r\n\r\n            return max;\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>&nbsp;</p>\r\n<p>Time Complexity: O(n)</p>\r\n<p>Space Complexity: O(n)</p>\r\n<p>&nbsp;</p>\r\n<p>Unit Tests:</p>\r\n<pre class=\"language-csharp\"><code>using LeetCode.AskGif.Easy.Array;\r\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace CodingUnitTest.Easy.Array\r\n{\r\n    [TestClass]\r\n    public class FindLuckySolnTests\r\n    {\r\n        [TestMethod]\r\n        public void FindLuckySoln_First()\r\n        {\r\n            var arr = new int[] { 2, 2, 3, 4 };\r\n            var output = 2;\r\n            var res = new FindLuckySoln().FindLucky(arr);\r\n\r\n            Assert.AreEqual(res, output);\r\n        }\r\n\r\n        [TestMethod]\r\n        public void FindLuckySoln_Second()\r\n        {\r\n            var arr = new int[] { 1, 2, 2, 3, 3, 3 };\r\n            var output = 3;\r\n            var res = new FindLuckySoln().FindLucky(arr);\r\n\r\n            Assert.AreEqual(res, output);\r\n        }\r\n\r\n        [TestMethod]\r\n        public void FindLuckySoln_Third()\r\n        {\r\n            var arr = new int[] { 2, 2, 2, 3, 3 };\r\n            var output = -1;\r\n            var res = new FindLuckySoln().FindLucky(arr);\r\n\r\n            Assert.AreEqual(res, output);\r\n        }\r\n\r\n        [TestMethod]\r\n        public void FindLuckySoln_Fourth()\r\n        {\r\n            var arr = new int[] { 5 };\r\n            var output = -1;\r\n            var res = new FindLuckySoln().FindLucky(arr);\r\n\r\n            Assert.AreEqual(res, output);\r\n        }\r\n\r\n        [TestMethod]\r\n        public void FindLuckySoln_Fifth()\r\n        {\r\n            var arr = new int[] { 7, 7, 7, 7, 7, 7, 7 };\r\n            var output = 7;\r\n            var res = new FindLuckySoln().FindLucky(arr);\r\n\r\n            Assert.AreEqual(res, output);\r\n        }\r\n    }\r\n}\r\n</code></pre>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/c62b8e48-2550-4bff-a335-20c9f848f4b3-array.png","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"find-lucky-integer-in-an-array-easy-leetcode","tags":[{"name":"आसान","slug":"easy"},{"name":"c-sharp","slug":"c-sharp"},{"name":"leetcode","slug":"leetcode"},{"name":"array","slug":"array"},{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"}],"recommendations":[{"id":1647,"title":"Slowest Key - Array - Easy - LeetCode","imageUrl":"icon_836f29a5-8a43-4160-b64a-fbf8416788bd.jpg","dateCreated":"2020-10-31T03:14:43.566Z","dateModified":"2020-10-31T03:14:48.648Z","contributedBy":"sumitc91","content":"A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.\nYou are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith k","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/836f29a5-8a43-4160-b64a-fbf8416788bd.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"slowest-key-array-easy-leetcode","total":0},{"id":1638,"title":"Next Permutation - Array - Medium - LeetCode","imageUrl":"icon_467cc3d1-390e-4bc6-a589-9f2b2a7b6f67.jpg","dateCreated":"2020-10-24T11:58:46.632Z","dateModified":"2020-10-24T11:59:00.039Z","contributedBy":"sumitc91","content":"Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\nThe replacement must be in place and use ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/467cc3d1-390e-4bc6-a589-9f2b2a7b6f67.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"next-permutation-array-medium-leetcode","total":0},{"id":1601,"title":"N-th Tribonacci Number - Recursion - Easy - LeetCode","imageUrl":"icon_8864cfe3-0823-418f-867d-6299b93c28bd.jpg","dateCreated":"2020-10-15T09:12:30.383Z","dateModified":"2020-10-15T09:12:56.022Z","contributedBy":"sumitc91","content":"The Tribonacci sequence Tn is defined as follows:&nbsp;\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &gt;= 0.\nGiven n, return the value of Tn.\n&nbsp;\nExample 1:\nInput: n = 4<br />Output: 4<br />Explanation:<br />T_3 = 0 + 1 + 1 = 2<br />T_4 = 1 + 1 ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8864cfe3-0823-418f-867d-6299b93c28bd.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"dynamic-programming","slug":"dynamic-programming"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"recursion","slug":"recursion"}],"slug":"n-th-tribonacci-number-recursion-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}