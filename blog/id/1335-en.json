{"id":1335,"title":"Groups of Special-Equivalent Strings - Easy - LeetCode","imageUrl":"777fbd8f-51f2-4c38-9d3e-eadcc18d3d71-array.png","dateCreated":"2020-06-06T09:10:12.091Z","dateModified":"2020-06-06T09:10:25.141Z","contributedBy":"AskGif","content":"<p>You are given an array A of strings.</p>\r\n<p>A move onto S consists of swapping any two even indexed characters of S, or any two odd indexed characters of S.</p>\r\n<p>Two strings S and T are special-equivalent if after any number of moves onto S, S == T.</p>\r\n<p>For example, S = \"zzxy\" and T = \"xyzz\" are special-equivalent because we may make the moves \"zzxy\" -&gt; \"xzzy\" -&gt; \"xyzz\" that swap S[0] and S[2], then S[1] and S[3].</p>\r\n<p>Now, a group of special-equivalent strings from A is a non-empty subset of A such that:</p>\r\n<p>Every pair of strings in the group are special equivalent, and;</p>\r\n<p>The group is the largest size possible (ie., there isn't a string S not in the group such that S is special equivalent to every string in the group)</p>\r\n<p>Return the number of groups of special-equivalent strings from A.</p>\r\n<p>&nbsp;</p>\r\n<p>Example 1:</p>\r\n<p>Input: [\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]</p>\r\n<p>Output: 3</p>\r\n<p>Explanation:&nbsp;</p>\r\n<p>One group is [\"abcd\", \"cdab\", \"cbad\"], since they are all pairwise special equivalent, and none of the other strings are all pairwise special equivalent to these.</p>\r\n<p>The other two groups are [\"xyzz\", \"zzxy\"] and [\"zzyx\"].&nbsp; Note that in particular, \"zzxy\" is not special equivalent to \"zzyx\".</p>\r\n<p>&nbsp;</p>\r\n<p>Example 2:</p>\r\n<p>Input: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]</p>\r\n<p>Output: 3</p>\r\n<p>&nbsp;</p>\r\n<p>Note:</p>\r\n<p>1 &lt;= A.length &lt;= 1000</p>\r\n<p>1 &lt;= A[i].length &lt;= 20</p>\r\n<p>All A[i] have the same length.</p>\r\n<p>All A[i] consist of only lowercase letters.</p>\r\n<p>&nbsp;</p>\r\n<p>Solution:</p>\r\n<pre class=\"language-csharp\"><code>using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace LeetCode.AskGif.Easy.String\r\n{\r\n    class NumSpecialEquivGroupsSoln\r\n    {\r\n        public void execute()\r\n        {\r\n            var input1 = new string[]{\"abcd\", \"cdab\", \"cbad\", \"xyzz\", \"zzxy\", \"zzyx\"};\r\n            var res = NumSpecialEquivGroups(input1);\r\n        }\r\n\r\n        public int NumSpecialEquivGroups(string[] A)\r\n        {\r\n            var set = new HashSet&lt;string&gt;();\r\n            for (int i = 0; i &lt; A.Length; i++)\r\n            {\r\n                var even = new StringBuilder();\r\n                var odd = new StringBuilder();\r\n                for (int j = 0; j &lt; A[i].Length; j++)\r\n                {                    \r\n                    if (j % 2 == 0)\r\n                        even.Append(A[i][j]);\r\n                    else\r\n                        odd.Append(A[i][j]);\r\n                }\r\n\r\n                var evenStr = string.Concat(even.ToString().OrderBy(c =&gt; c));\r\n                var oddStr = string.Concat(odd.ToString().OrderBy(c =&gt; c));\r\n\r\n                set.Add(evenStr + oddStr);\r\n            }\r\n\r\n            return set.Count;\r\n        }\r\n    }\r\n}\r\n</code></pre>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/777fbd8f-51f2-4c38-9d3e-eadcc18d3d71-array.png","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"groups-of-special-equivalent-strings-easy-leetcode","tags":[{"name":"leetcode","slug":"leetcode"},{"name":"c-sharp","slug":"c-sharp"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"algorithm","slug":"algorithm"},{"name":"string","slug":"string"}],"recommendations":[{"id":1725,"title":"Sum of Unique Elements - Array - Easy - LeetCode","imageUrl":"icon_9e341651-0933-4893-84a8-1d3f65898dda.jpg","dateCreated":"2021-02-13T13:13:53.857Z","dateModified":"2021-02-13T13:13:59.576Z","contributedBy":"sumitc91","content":"You are given an integer array nums. The unique elements of an array are the elements that appear exactly once in the array.\nReturn the sum of all the unique elements of nums.\n&nbsp;\nExample 1:\nInput: nums = [1,2,3,2]<br />Output: 4<br />Explanation: The unique element","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/9e341651-0933-4893-84a8-1d3f65898dda.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"sum-of-unique-elements-array-easy-leetcode","total":0},{"id":1636,"title":"Two Strings - HashMap - Easy - HackerRank","imageUrl":"icon_b574251c-e9c0-4be6-9bc1-7c86f8da1806.jpg","dateCreated":"2020-10-24T07:22:16.972Z","dateModified":"2020-10-24T07:22:22.952Z","contributedBy":"sumitc91","content":"Given two strings, determine if they share a common substring. A substring may be as small as one character.\nFor example, the words \"a\", \"and\", \"art\" share the common substring . The words \"be\" and \"cat\" do not share a substring.\nFunction Description\nComplete the function two","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/b574251c-e9c0-4be6-9bc1-7c86f8da1806.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"hackerrank","slug":"hackerrank"},{"name":"hash-table","slug":"hash-table"}],"slug":"two-strings-hashmap-easy-hackerrank","total":0},{"id":1635,"title":"New Year Chaos - Array - Medium - HackerRank","imageUrl":"icon_53eb9e67-4065-4a48-af84-1ab48ec4ee5e.jpg","dateCreated":"2020-10-24T07:14:47.121Z","dateModified":"2020-10-24T07:15:13.568Z","contributedBy":"sumitc91","content":"It's New Year's Day and everyone's in line for the Wonderland rollercoaster ride! There are a number of people queued up, and each person wears a sticker indicating their initial position in the queue. Initial positions increment by &nbsp;from &nbsp;at the front of the line to &nbsp;at the back.<","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/53eb9e67-4065-4a48-af84-1ab48ec4ee5e.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"hackerrank","slug":"hackerrank"},{"name":"medium","slug":"medium"}],"slug":"new-year-chaos-array-medium-hackerrank","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}