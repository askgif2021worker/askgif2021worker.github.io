{"id":1343,"title":"The K Weakest Rows in a Matrix - Array - Easy - LeetCode","imageUrl":"f0340083-af99-4106-bbe0-0860c34b2f94-array.png","dateCreated":"2020-06-08T07:20:25.689Z","dateModified":"2020-06-08T14:12:06.184Z","contributedBy":"AskGif","content":"<p>Given a m * n matrix mat of ones (representing soldiers) and zeros (representing civilians), return the indexes of the k weakest rows in the matrix ordered from the weakest to the strongest.</p>\r\n<p>A row i is weaker than row j, if the number of soldiers in row i is less than the number of soldiers in row j, or they have the same number of soldiers but i is less than j. Soldiers are always stand in the frontier of a row, that is, always ones may appear first and then zeros.</p>\r\n<p>&nbsp;</p>\r\n<p>Example 1:</p>\r\n<p>Input: mat =&nbsp;</p>\r\n<p>[[1,1,0,0,0],</p>\r\n<p>&nbsp;[1,1,1,1,0],</p>\r\n<p>&nbsp;[1,0,0,0,0],</p>\r\n<p>&nbsp;[1,1,0,0,0],</p>\r\n<p>&nbsp;[1,1,1,1,1]],&nbsp;</p>\r\n<p>k = 3</p>\r\n<p>Output: [2,0,3]</p>\r\n<p>Explanation:&nbsp;</p>\r\n<p>The number of soldiers for each row is:&nbsp;</p>\r\n<p>row 0 -&gt; 2&nbsp;</p>\r\n<p>row 1 -&gt; 4&nbsp;</p>\r\n<p>row 2 -&gt; 1&nbsp;</p>\r\n<p>row 3 -&gt; 2&nbsp;</p>\r\n<p>row 4 -&gt; 5&nbsp;</p>\r\n<p>Rows ordered from the weakest to the strongest are [2,0,3,1,4]</p>\r\n<p>&nbsp;</p>\r\n<p>Example 2:</p>\r\n<p>Input: mat =&nbsp;</p>\r\n<p>[[1,0,0,0],</p>\r\n<p>&nbsp;[1,1,1,1],</p>\r\n<p>&nbsp;[1,0,0,0],</p>\r\n<p>&nbsp;[1,0,0,0]],&nbsp;</p>\r\n<p>k = 2</p>\r\n<p>Output: [0,2]</p>\r\n<p>Explanation:&nbsp;</p>\r\n<p>The number of soldiers for each row is:&nbsp;</p>\r\n<p>row 0 -&gt; 1&nbsp;</p>\r\n<p>row 1 -&gt; 4&nbsp;</p>\r\n<p>row 2 -&gt; 1&nbsp;</p>\r\n<p>row 3 -&gt; 1&nbsp;</p>\r\n<p>Rows ordered from the weakest to the strongest are [0,2,3,1]</p>\r\n<p>&nbsp;</p>\r\n<p>Constraints:</p>\r\n<p>m == mat.length</p>\r\n<p>n == mat[i].length</p>\r\n<p>2 &lt;= n, m &lt;= 100</p>\r\n<p>1 &lt;= k &lt;= m</p>\r\n<p>matrix[i][j] is either 0 or 1.</p>\r\n<p>&nbsp;</p>\r\n<p>Solution:</p>\r\n<pre class=\"language-csharp\"><code>using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace LeetCode.AskGif.Easy.Array\r\n{\r\n    public class KWeakestRowsSoln\r\n    {\r\n        public int[] KWeakestRows(int[][] mat, int k)\r\n        {\r\n            var map = new Dictionary&lt;int, int&gt;();\r\n            for (int i = 0; i &lt; mat.Length; i++)\r\n            {\r\n                for (int j = 0; j &lt; mat[i].Length; j++)\r\n                {\r\n                    if(mat[i][j] == 1)\r\n                    {\r\n                        if (map.ContainsKey(i))\r\n                        {\r\n                            map[i]++;\r\n                        }\r\n                        else\r\n                        {\r\n                            map.Add(i, 1);\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        if (!map.ContainsKey(i))\r\n                        {\r\n                            map.Add(i, 0);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            var sortedCollection = map\r\n                    .OrderBy(x =&gt; x.Value)\r\n                    .ThenBy(x =&gt; x.Key);\r\n\r\n            var res = new int[k];\r\n            int y = 0;\r\n            foreach (var item in sortedCollection)\r\n            {\r\n                res[y] = item.Key;\r\n                y++;\r\n                \r\n                if (y==k)\r\n                {\r\n                    break;\r\n                }\r\n            }            \r\n\r\n            return res;\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>&nbsp;</p>\r\n<p>Time Complexity: O(n^2)</p>\r\n<p>Space Complexity: O(n)</p>\r\n<pre class=\"language-csharp\"><code>using LeetCode.AskGif.Easy.Array;\r\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace CodingUnitTest.Easy.Array\r\n{\r\n    [TestClass]\r\n    public class KWeakestRowsSolnTests\r\n    {\r\n        [TestMethod]\r\n        public void KWeakestRowsSoln_First()\r\n        {\r\n            var mat = new int[,] {\r\n                    { 1, 1, 0, 0, 0 },\r\n                    { 1, 1, 1, 1, 0 },\r\n                    { 1, 0, 0, 0, 0 },\r\n                    { 1, 1, 0, 0, 0 },\r\n                    { 1, 1, 1, 1, 1 }\r\n                   };\r\n            var k = 3;\r\n            var output = new int[]{2, 0, 3};\r\n            var res = new KWeakestRowsSoln().KWeakestRows(ArrayMapper(mat), k);\r\n\r\n            AreEqual(res, output);\r\n        }\r\n\r\n        [TestMethod]\r\n        public void KWeakestRowsSoln_Second()\r\n        {\r\n            var mat = new int[,] {\r\n                     { 1, 0, 0, 0 },\r\n                     { 1, 1, 1, 1 },\r\n                     { 1, 0, 0, 0 },\r\n                     { 1, 0, 0, 0 }\r\n                   };\r\n            var k = 2;\r\n            var output = new int[] { 0, 2 };\r\n            var res = new KWeakestRowsSoln().KWeakestRows(ArrayMapper(mat), k);\r\n\r\n            AreEqual(res, output);\r\n        }\r\n\r\n        [TestMethod]\r\n        public void KWeakestRowsSoln_Third()\r\n        {\r\n            var mat = new int[,] {\r\n                     { 1, 0 },\r\n                     { 0, 0 },\r\n                     { 1, 0 }\r\n                   };\r\n            var k = 2;\r\n            var output = new int[] { 1, 0 };\r\n            var res = new KWeakestRowsSoln().KWeakestRows(ArrayMapper(mat), k);\r\n\r\n            AreEqual(res, output);\r\n        }\r\n\r\n        [TestMethod]\r\n        public void KWeakestRowsSoln_Fourth()\r\n        {\r\n            var mat = new int[,] {\r\n                     { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n                     { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\r\n                   };\r\n            var k = 17;\r\n            var output = new int[] { 10, 12, 15, 4, 14, 16, 2, 7, 11, 3, 5, 0, 13, 1, 9, 17, 6 };\r\n            var res = new KWeakestRowsSoln().KWeakestRows(ArrayMapper(mat), k);\r\n\r\n            AreEqual(res, output);\r\n        }\r\n\r\n        private int[][] ArrayMapper(int[,] matrix)\r\n        {\r\n            var arr = new int[matrix.GetLength(0)][];\r\n            for (int i = 0; i &lt; matrix.GetLength(0); i++)\r\n            {\r\n                arr[i] = new int[matrix.GetLength(1)];\r\n                for (int j = 0; j &lt; matrix.GetLength(1); j++)\r\n                {\r\n                    arr[i][j] = matrix[i, j];\r\n                }\r\n            }\r\n\r\n            return arr;\r\n        }\r\n\r\n        private void AreEqual(int[] res, int[] output)\r\n        {\r\n            Assert.AreEqual(res.Length, output.Length);\r\n            for (int i = 0; i &lt; res.Length; i++)\r\n            {\r\n                Assert.AreEqual(res[i], output[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>&nbsp;</p>\r\n<p>Unit Tests:</p>\r\n<p>&nbsp;</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/f0340083-af99-4106-bbe0-0860c34b2f94-array.png","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"the-k-weakest-rows-in-a-matrix-array-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"c-sharp","slug":"c-sharp"},{"name":"आसान","slug":"easy"},{"name":"array","slug":"array"},{"name":"leetcode","slug":"leetcode"},{"name":"डेटा-संरचना","slug":"data-structure"}],"recommendations":[{"id":1679,"title":"Insert Delete GetRandom O(1) - Array - Medium - LeetCode","imageUrl":"icon_8589fcba-acbd-4690-8c6e-3f8e5511c176.jpg","dateCreated":"2020-11-19T06:35:11.658Z","dateModified":"2020-11-19T06:35:19.394Z","contributedBy":"sumitc91","content":"Implement the RandomizedSet class:\nbool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.<br />bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.<","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8589fcba-acbd-4690-8c6e-3f8e5511c176.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"insert-delete-getrandom-o1-array-medium-leetcode","total":0},{"id":1640,"title":"Find First and Last Position of Element in Sorted Array - Array - Medium - LeetCode","imageUrl":"icon_4dd548b4-7f64-4384-8000-de99e5e3a765.jpg","dateCreated":"2020-10-25T13:25:33.524Z","dateModified":"2020-10-25T13:25:43.128Z","contributedBy":"sumitc91","content":"Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\nIf the target is not found in the array, return [-1, -1].\nFollow up: Could you write an algorithm with O(log n) runtime complexity?\n&nbsp;\nExample ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/4dd548b4-7f64-4384-8000-de99e5e3a765.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"find-first-and-last-position-of-element-in-sorted-array-array-medium-leetcode","total":0},{"id":1629,"title":"Maximum Nesting Depth of the Parentheses - Stack - Easy - LeetCode","imageUrl":"icon_9d515e72-4c83-4541-9650-c0972215972d.jpg","dateCreated":"2020-10-18T08:20:30.391Z","dateModified":"2020-10-18T08:20:41.012Z","contributedBy":"sumitc91","content":"A string is a valid parentheses string (denoted VPS) if it meets one of the following:\nIt is an empty string \"\", or a single character not equal to \"(\" or \")\",<br />It can be written as AB (A concatenated with B), where A and B are VPS's, or<br />It can be written as (A), where A is a VPS.","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/9d515e72-4c83-4541-9650-c0972215972d.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"stack","slug":"stack"}],"slug":"maximum-nesting-depth-of-the-parentheses-stack-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}