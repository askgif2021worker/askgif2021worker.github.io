{"id":1351,"title":"Minimum Time Visiting All Points - Array - Easy - LeetCode","imageUrl":"f51560a1-0ff7-483c-b07b-ac848d5e42b0-array.png","dateCreated":"2020-06-11T04:50:10.515Z","dateModified":"2020-06-11T04:50:58.181Z","contributedBy":"AskGif","content":"<p>On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points.</p>\r\n<p>You can move according to the next rules:</p>\r\n<p>In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second).</p>\r\n<p>You have to visit the points in the same order as they appear in the array.</p>\r\n<p>&nbsp;</p>\r\n<p>Example 1:</p>\r\n<p>Input: points = [[1,1],[3,4],[-1,0]]</p>\r\n<p>Output: 7</p>\r\n<p>Explanation: One optimal path is [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0]&nbsp; &nbsp;</p>\r\n<p>Time from [1,1] to [3,4] = 3 seconds&nbsp;</p>\r\n<p>Time from [3,4] to [-1,0] = 4 seconds</p>\r\n<p>Total time = 7 seconds</p>\r\n<p>&nbsp;</p>\r\n<p>Example 2:</p>\r\n<p>Input: points = [[3,2],[-2,2]]</p>\r\n<p>Output: 5</p>\r\n<p>&nbsp;</p>\r\n<p>Constraints:</p>\r\n<p>points.length == n</p>\r\n<p>1 &lt;= n &lt;= 100</p>\r\n<p>points[i].length == 2</p>\r\n<p>-1000 &lt;= points[i][0], points[i][1] &lt;= 1000</p>\r\n<p>&nbsp;</p>\r\n<p>Solution:</p>\r\n<pre class=\"language-csharp\"><code>using System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace LeetCode.AskGif.Easy.Array\r\n{\r\n    public class MinTimeToVisitAllPointsSoln\r\n    {\r\n        public int MinTimeToVisitAllPoints(int[][] points)\r\n        {\r\n            if(points.Length == 0)\r\n            {\r\n                return 0;\r\n            }\r\n\r\n            int time = 0;\r\n            int sourceX = points[0][0];\r\n            int sourceY = points[0][1];\r\n            for (int i = 1; i &lt; points.Length; i++)\r\n            {\r\n                int destinationX = points[i][0];\r\n                int destinationY = points[i][1];\r\n                time += CalculateTimeBetweenPoints(sourceX, sourceY, destinationX, destinationY);\r\n\r\n                sourceX = destinationX;\r\n                sourceY = destinationY;\r\n            }\r\n\r\n            return time;\r\n        }\r\n\r\n        private int CalculateTimeBetweenPoints(int sourceX, int sourceY, int destinationX, int destinationY)\r\n        {\r\n            int time = 0;\r\n            int diffX = Math.Abs(sourceX - destinationX);\r\n            int diffY = Math.Abs(sourceY - destinationY);\r\n\r\n            int diagonalMove = Math.Min(diffX, diffY);\r\n            time = diagonalMove + Math.Abs(diffX - diffY);\r\n            return time;\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>&nbsp;</p>\r\n<p>Time Complexity:O(n)</p>\r\n<p>Space Complexity: O(1)</p>\r\n<p>&nbsp;</p>\r\n<p>Unit Tests:</p>\r\n<pre class=\"language-csharp\"><code>using LeetCode.AskGif.Easy.Array;\r\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace CodingUnitTest.Easy.Array\r\n{\r\n    [TestClass]\r\n    public class MinTimeToVisitAllPointsSolnTests\r\n    {\r\n        [TestMethod]\r\n        public void MinTimeToVisitAllPointsSoln_First()\r\n        {\r\n            var arr = new int[,] {\r\n                    { 1, 1 },\r\n                    { 3, 4 },\r\n                    { -1, 0 }\r\n                };\r\n            var output = 7;\r\n            var res = new MinTimeToVisitAllPointsSoln().MinTimeToVisitAllPoints(ArrayMapper(arr));\r\n\r\n            Assert.AreEqual(output, res);\r\n        }\r\n\r\n        [TestMethod]\r\n        public void MinTimeToVisitAllPointsSoln_Second()\r\n        {\r\n            var arr = new int[,] {\r\n                    { 3 , 2 },\r\n                    { -2, 2 }\r\n                };\r\n            var output = 5;\r\n            var res = new MinTimeToVisitAllPointsSoln().MinTimeToVisitAllPoints(ArrayMapper(arr));\r\n\r\n            Assert.AreEqual(output, res);\r\n        }\r\n\r\n        private int[][] ArrayMapper(int[,] matrix)\r\n        {\r\n            var arr = new int[matrix.GetLength(0)][];\r\n            for (int i = 0; i &lt; matrix.GetLength(0); i++)\r\n            {\r\n                arr[i] = new int[matrix.GetLength(1)];\r\n                for (int j = 0; j &lt; matrix.GetLength(1); j++)\r\n                {\r\n                    arr[i][j] = matrix[i, j];\r\n                }\r\n            }\r\n\r\n            return arr;\r\n        }\r\n    }\r\n}\r\n</code></pre>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/f51560a1-0ff7-483c-b07b-ac848d5e42b0-array.png","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"minimum-time-visiting-all-points-array-easy-leetcode","tags":[{"name":"c-sharp","slug":"c-sharp"},{"name":"algorithm","slug":"algorithm"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"array","slug":"array"}],"recommendations":[{"id":1677,"title":"Find the Duplicate Number - Array - Medium - LeetCode","imageUrl":"icon_85d20211-e54a-42fd-9300-e83bc02b7ffe.jpg","dateCreated":"2020-11-18T13:09:40.526Z","dateModified":"2020-11-18T13:09:46.723Z","contributedBy":"sumitc91","content":"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one duplicate number in nums, return this duplicate number.\nFollow-ups:\nHow can we prove that at least one duplicate number must exist in nums?&nbsp;<b","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/85d20211-e54a-42fd-9300-e83bc02b7ffe.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"find-the-duplicate-number-array-medium-leetcode","total":0},{"id":1640,"title":"Find First and Last Position of Element in Sorted Array - Array - Medium - LeetCode","imageUrl":"icon_4dd548b4-7f64-4384-8000-de99e5e3a765.jpg","dateCreated":"2020-10-25T13:25:33.524Z","dateModified":"2020-10-25T13:25:43.128Z","contributedBy":"sumitc91","content":"Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\nIf the target is not found in the array, return [-1, -1].\nFollow up: Could you write an algorithm with O(log n) runtime complexity?\n&nbsp;\nExample ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/4dd548b4-7f64-4384-8000-de99e5e3a765.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"find-first-and-last-position-of-element-in-sorted-array-array-medium-leetcode","total":0},{"id":1596,"title":"Sum of Root To Leaf Binary Numbers - Tree - Easy - LeetCode","imageUrl":"icon_41e87329-1dad-4856-9c47-60b67b520656.jpg","dateCreated":"2020-10-09T09:37:18.648Z","dateModified":"2020-10-09T09:37:29.591Z","contributedBy":"sumitc91","content":"You are given the root of a binary tree where each node has a value 0 or 1. &nbsp;Each root-to-leaf path represents a binary number starting with the most significant bit. &nbsp;For example, if the path is 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1, then this could represent 01101 in binary, which is 13.<","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/41e87329-1dad-4856-9c47-60b67b520656.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"sum-of-root-to-leaf-binary-numbers-tree-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}