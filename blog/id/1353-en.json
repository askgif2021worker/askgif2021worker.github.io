{"id":1353,"title":"Cells with Odd Values in a Matrix - Array - Easy - LeetCode","imageUrl":"62e28ac4-2f10-4ba3-b380-0f9f97176f55-array.png","dateCreated":"2020-06-11T10:55:05.085Z","dateModified":"2020-06-11T10:55:18.401Z","contributedBy":"AskGif","content":"<p>Given n and m which are the dimensions of a matrix initialized by zeros and given an array indices where indices[i] = [ri, ci]. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by 1.</p>\r\n<p>Return the number of cells with odd values in the matrix after applying the increment to all indices.</p>\r\n<p>&nbsp;</p>\r\n<p>Example 1:</p>\r\n<p>&nbsp;</p>\r\n<p>Input: n = 2, m = 3, indices = [[0,1],[1,1]]</p>\r\n<p>Output: 6</p>\r\n<p>Explanation: Initial matrix = [[0,0,0],[0,0,0]].</p>\r\n<p>After applying first increment it becomes [[1,2,1],[0,1,0]].</p>\r\n<p>The final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.</p>\r\n<p>&nbsp;</p>\r\n<p>Example 2:</p>\r\n<p>Input: n = 2, m = 2, indices = [[1,1],[0,0]]</p>\r\n<p>Output: 0</p>\r\n<p>Explanation: Final matrix = [[2,2],[2,2]]. There is no odd number in the final matrix.</p>\r\n<p>&nbsp;</p>\r\n<p>Constraints:</p>\r\n<p>1 &lt;= n &lt;= 50</p>\r\n<p>1 &lt;= m &lt;= 50</p>\r\n<p>1 &lt;= indices.length &lt;= 100</p>\r\n<p>0 &lt;= indices[i][0] &lt; n</p>\r\n<p>0 &lt;= indices[i][1] &lt; m</p>\r\n<p>&nbsp;</p>\r\n<p>Solution:</p>\r\n<pre class=\"language-csharp\"><code>using System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace LeetCode.AskGif.Easy.Array\r\n{\r\n    public class OddCellsSoln\r\n    {\r\n        public int OddCells(int n, int m, int[][] indices)\r\n        {\r\n            var matrix = new int[n, m];\r\n\r\n            //initialize matrix to zero.\r\n            for (int i = 0; i &lt; n; i++)\r\n            {\r\n                for (int j = 0; j &lt; m; j++)\r\n                {\r\n                    matrix[i, j] = 0;\r\n                }\r\n            }\r\n\r\n            for (int i = 0; i &lt; indices.Length; i++)\r\n            {\r\n                int x = indices[i][0];\r\n                int y = indices[i][1];\r\n\r\n                //increment x axis\r\n                for (int a = 0; a &lt; m; a++)\r\n                {\r\n                    matrix[x,a]++;\r\n                }\r\n\r\n                //increment y axis\r\n                for (int b = 0; b &lt; n; b++)\r\n                {\r\n                    matrix[b, y]++;\r\n                }\r\n            }\r\n\r\n            int odd = 0;\r\n            for (int i = 0; i &lt; n; i++)\r\n            {\r\n                for (int j = 0; j &lt; m; j++)\r\n                {\r\n                    if (matrix[i, j] % 2 != 0)\r\n                    {\r\n                        odd++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return odd;\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>&nbsp;</p>\r\n<p>Time Complexity: O(n^2)</p>\r\n<p>Space Complexity: O(m*n) For storing the result</p>\r\n<p>&nbsp;</p>\r\n<p>Unit Tests:</p>\r\n<pre class=\"language-csharp\"><code>using LeetCode.AskGif.Easy.Array;\r\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace CodingUnitTest.Easy.Array\r\n{\r\n    [TestClass]\r\n    public class OddCellsSolnTests\r\n    {\r\n        [TestMethod]\r\n        public void OddCellsSoln_First()\r\n        {\r\n            var indices = new int[,] {\r\n                    { 0, 1 },\r\n                    { 1, 1 }\r\n                };\r\n            var n = 2;\r\n            var m = 3;\r\n            var output = 6;\r\n\r\n            var res = new OddCellsSoln().OddCells(n, m, ArrayMapper(indices));\r\n\r\n            Assert.AreEqual(output, res);\r\n        }\r\n\r\n        [TestMethod]\r\n        public void OddCellsSoln_Second()\r\n        {\r\n            var indices = new int[,] {\r\n                    { 1, 1 },\r\n                    { 0, 0 }\r\n                };\r\n            var n = 2;\r\n            var m = 2;\r\n            var output = 0;\r\n\r\n            var res = new OddCellsSoln().OddCells(n, m, ArrayMapper(indices));\r\n\r\n            Assert.AreEqual(output, res);\r\n        }\r\n\r\n        private int[][] ArrayMapper(int[,] matrix)\r\n        {\r\n            var arr = new int[matrix.GetLength(0)][];\r\n            for (int i = 0; i &lt; matrix.GetLength(0); i++)\r\n            {\r\n                arr[i] = new int[matrix.GetLength(1)];\r\n                for (int j = 0; j &lt; matrix.GetLength(1); j++)\r\n                {\r\n                    arr[i][j] = matrix[i, j];\r\n                }\r\n            }\r\n\r\n            return arr;\r\n        }\r\n    }\r\n}\r\n</code></pre>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/62e28ac4-2f10-4ba3-b380-0f9f97176f55-array.png","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"cells-with-odd-values-in-a-matrix-array-easy-leetcode","tags":[{"name":"c-sharp","slug":"c-sharp"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"easy","slug":"easy"},{"name":"algorithm","slug":"algorithm"}],"recommendations":[{"id":1681,"title":"Circular Array Loop - Array - Medium - LeetCode","imageUrl":"icon_32298a91-8bd5-4e63-872d-105103726a20.jpg","dateCreated":"2020-11-19T09:05:08.281Z","dateModified":"2020-11-19T09:05:14.582Z","contributedBy":"sumitc91","content":"You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it's negative (-k), move backward k steps. Since the array is circular, you may assume that the last element's next element is the first element,","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/32298a91-8bd5-4e63-872d-105103726a20.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"circular-array-loop-array-medium-leetcode","total":0},{"id":1659,"title":"Sort Array by Increasing Frequency - Array - Medium - LeetCode","imageUrl":"icon_0607b46b-96fe-470e-a316-ee8bf5aeee8e.jpg","dateCreated":"2020-11-03T05:02:58.417Z","dateModified":"2020-11-03T05:10:52.862Z","contributedBy":"sumitc91","content":"Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.\nReturn the sorted array.\n&nbsp;\nExample 1:\nInput: nums = [1,1,2,2,2,3]<br />Output: [3,1","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/0607b46b-96fe-470e-a316-ee8bf5aeee8e.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"sort-array-by-increasing-frequency-array-medium-leetcode","total":0},{"id":1639,"title":"Search in Rotated Sorted Array - Array - Medium - LeetCode","imageUrl":"icon_92804ec8-8b64-41e0-a4f4-89ed11e1a5e2.jpg","dateCreated":"2020-10-24T14:15:15.013Z","dateModified":"2020-10-24T14:15:23.602Z","contributedBy":"sumitc91","content":"You are given an integer array nums sorted in ascending order, and an integer target.\nSuppose that nums is rotated at some pivot unknown to you beforehand (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\nIf target is found in the array return its index, otherwise, return -1.</p","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/92804ec8-8b64-41e0-a4f4-89ed11e1a5e2.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"search-in-rotated-sorted-array-array-medium-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}