{"id":1355,"title":"Play with Chips - Array - Easy - LeetCode","imageUrl":"7a812179-4971-4b5f-abe5-1f767eeb1eba-array.png","dateCreated":"2020-06-12T12:30:51.67Z","dateModified":"2020-06-12T12:31:03.556Z","contributedBy":"AskGif","content":"<p>There are some chips, and the i-th chip is at position chips[i].</p>\r\n<p>You can perform any of the two following types of moves any number of times (possibly zero) on any chip:</p>\r\n<p>Move the i-th chip by 2 units to the left or to the right with a cost of 0.</p>\r\n<p>Move the i-th chip by 1 unit to the left or to the right with a cost of 1.</p>\r\n<p>There can be two or more chips at the same position initially.</p>\r\n<p>Return the minimum cost needed to move all the chips to the same position (any position).</p>\r\n<p>&nbsp;</p>\r\n<p>Example 1:</p>\r\n<p>Input: chips = [1,2,3]</p>\r\n<p>Output: 1</p>\r\n<p>Explanation: Second chip will be moved to positon 3 with cost 1. First chip will be moved to position 3 with cost 0. Total cost is 1.</p>\r\n<p>&nbsp;</p>\r\n<p>Example 2:</p>\r\n<p>Input: chips = [2,2,2,3,3]</p>\r\n<p>Output: 2</p>\r\n<p>Explanation: Both fourth and fifth chip will be moved to position two with cost 1. Total minimum cost will be 2.</p>\r\n<p>&nbsp;</p>\r\n<p>Constraints:</p>\r\n<p>1 &lt;= chips.length &lt;= 100</p>\r\n<p>1 &lt;= chips[i] &lt;= 10^9</p>\r\n<p>&nbsp;</p>\r\n<p>Solution:</p>\r\n<pre class=\"language-csharp\"><code>using System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace LeetCode.AskGif.Easy.Array\r\n{\r\n    public class MinCostToMoveChipsSoln\r\n    {\r\n        public int MinCostToMoveChips(int[] chips)\r\n        {\r\n            var map = new Dictionary&lt;int, int&gt;();\r\n            int max = 0;\r\n            int maxKey = 0;\r\n            int count = 0;\r\n            int evenCount = 0;                     \r\n            int oddCount = 0;                       \r\n\r\n            //Build the Hashmap and calculate even and odd position count.\r\n            for (int i = 0; i &lt; chips.Length; i++)\r\n            {\r\n                if (map.ContainsKey(chips[i]))\r\n                {\r\n                    map[chips[i]]++;                    \r\n                }\r\n                else\r\n                {\r\n                    map.Add(chips[i], 1);\r\n                }\r\n\r\n                if (chips[i] % 2 == 0)\r\n                {\r\n                    evenCount++;\r\n                }\r\n                else\r\n                {\r\n                    oddCount++;\r\n                }\r\n            }\r\n\r\n            //will make collective point based on even and odd count \r\n            //and then by frequency.\r\n            if (evenCount &gt; oddCount)\r\n            {\r\n                foreach (var item in map)\r\n                {\r\n                    if(item.Key % 2 == 0)\r\n                    {\r\n                        if(item.Key &gt; max)\r\n                        {\r\n                            max = item.Value;\r\n                            maxKey = item.Key;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                foreach (var item in map)\r\n                {\r\n                    if (item.Key % 2 != 0)\r\n                    {\r\n                        if (item.Key &gt; max)\r\n                        {\r\n                            max = item.Value;\r\n                            maxKey = item.Key;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            //find the total count required\r\n            foreach (var item in map)\r\n            {\r\n                if(item.Key != maxKey)\r\n                {\r\n                    if(item.Key &gt; maxKey)\r\n                    {\r\n                        count += item.Value * ((item.Key - maxKey) % 2);\r\n                    }\r\n                    else\r\n                    {\r\n                        count += item.Value * ((maxKey - item.Key) % 2);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            return count;\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>&nbsp;</p>\r\n<p>Time Complexity: O(n)</p>\r\n<p>Space Complexity: O(n)</p>\r\n<p>&nbsp;</p>\r\n<p>Unit Tests:</p>\r\n<pre class=\"language-csharp\"><code>using LeetCode.AskGif.Easy.Array;\r\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace CodingUnitTest.Easy.Array\r\n{\r\n    [TestClass]\r\n    public class MinCostToMoveChipsSolnTests\r\n    {\r\n        [TestMethod]\r\n        public void MinCostToMoveChipsSoln_First()\r\n        {\r\n            var chips = new int[] { 1, 2, 3 };\r\n            var output = 1;\r\n\r\n            var res = new MinCostToMoveChipsSoln().MinCostToMoveChips(chips);\r\n\r\n            Assert.AreEqual(output, res);\r\n        }\r\n\r\n        [TestMethod]\r\n        public void MinCostToMoveChipsSoln_Second()\r\n        {\r\n            var chips = new int[] { 2, 2, 2, 3, 3 };\r\n            var output = 2;\r\n\r\n            var res = new MinCostToMoveChipsSoln().MinCostToMoveChips(chips);\r\n\r\n            Assert.AreEqual(output, res);\r\n        }\r\n\r\n        [TestMethod]\r\n        public void MinCostToMoveChipsSoln_Third()\r\n        {\r\n            var chips = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 };\r\n            var output = 15;\r\n\r\n            var res = new MinCostToMoveChipsSoln().MinCostToMoveChips(chips);\r\n\r\n            Assert.AreEqual(output, res);\r\n        }\r\n\r\n        [TestMethod]\r\n        public void MinCostToMoveChipsSoln_Fourth()\r\n        {\r\n            var chips = new int[] { 1, 2, 2, 2, 2 };\r\n            var output = 1;\r\n\r\n            var res = new MinCostToMoveChipsSoln().MinCostToMoveChips(chips);\r\n\r\n            Assert.AreEqual(output, res);\r\n        }\r\n\r\n        [TestMethod]\r\n        public void MinCostToMoveChipsSoln_Fifth()\r\n        {\r\n            var chips = new int[] { 6, 4, 7, 8, 2, 10, 2, 7, 9, 7 };\r\n            var output = 4;\r\n\r\n            var res = new MinCostToMoveChipsSoln().MinCostToMoveChips(chips);\r\n\r\n            Assert.AreEqual(output, res);\r\n        }\r\n    }\r\n}\r\n</code></pre>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/7a812179-4971-4b5f-abe5-1f767eeb1eba-array.png","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"play-with-chips-array-easy-leetcode","tags":[{"name":"c-sharp","slug":"c-sharp"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"easy","slug":"easy"},{"name":"algorithm","slug":"algorithm"}],"recommendations":[{"id":1728,"title":"Minimum Changes To Make Alternating Binary String - String - Easy - LeetCode","imageUrl":"icon_85c66994-0911-4abb-b06f-a20a0a11dcd4.jpg","dateCreated":"2021-03-31T07:22:03.012Z","dateModified":"2021-03-31T07:22:08.602Z","contributedBy":"sumitc91","content":"You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.\nThe string is called alternating if no two adjacent characters are equal. For example, the string \"010\" is alternating, while the string \"0100\" is not.","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/85c66994-0911-4abb-b06f-a20a0a11dcd4.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"minimum-changes-to-make-alternating-binary-string-string-easy-leetcode","total":0},{"id":1677,"title":"Find the Duplicate Number - Array - Medium - LeetCode","imageUrl":"icon_85d20211-e54a-42fd-9300-e83bc02b7ffe.jpg","dateCreated":"2020-11-18T13:09:40.526Z","dateModified":"2020-11-18T13:09:46.723Z","contributedBy":"sumitc91","content":"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one duplicate number in nums, return this duplicate number.\nFollow-ups:\nHow can we prove that at least one duplicate number must exist in nums?&nbsp;<b","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/85d20211-e54a-42fd-9300-e83bc02b7ffe.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"find-the-duplicate-number-array-medium-leetcode","total":0},{"id":1602,"title":"Nim Game - Brainteaser - Easy - LeetCode","imageUrl":"icon_2d168a53-ceb7-4679-bee4-38527d6e5223.jpg","dateCreated":"2020-10-15T09:30:33.368Z","dateModified":"2020-10-15T09:32:06.259Z","contributedBy":"sumitc91","content":"You are playing the following Nim Game with your friend:\nInitially, there is a heap of stones on the table.<br />You and your friend will alternate taking turns, and you go first.<br />On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.<br />The one who remov","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/2d168a53-ceb7-4679-bee4-38527d6e5223.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"brainteaser","slug":"brainteaser"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"nim-game-brainteaser-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}