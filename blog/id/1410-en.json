{"id":1410,"title":"Reshape the Matrix - Array - Easy - LeetCode","imageUrl":"icon_e432d379-95d5-43d3-b36c-514c59c44988.jpg","dateCreated":"2020-09-26T06:53:56.58Z","dateModified":"2020-09-26T06:54:18.563Z","contributedBy":"sumitc91","content":"<p>In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with a different sizes but keep its original data.</p>\n<p>You're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.</p>\n<p>The reshaped matrix needs to be filled with all the elements of the original matrix in the same row-traversing order as they were.</p>\n<p>If the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>\n<p>Example 1:<br />Input:&nbsp;<br />nums =&nbsp;<br />[[1,2],<br />&nbsp;[3,4]]<br />r = 1, c = 4<br />Output:&nbsp;<br />[[1,2,3,4]]<br />Explanation:<br />The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.<br />Example 2:<br />Input:&nbsp;<br />nums =&nbsp;<br />[[1,2],<br />&nbsp;[3,4]]<br />r = 2, c = 4<br />Output:&nbsp;<br />[[1,2],<br />&nbsp;[3,4]]<br />Explanation:<br />There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.<br />Note:<br />The height and width of the given matrix is in range [1, 100].<br />The given r and c are all positive.</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int[][] MatrixReshape(int[][] nums, int r, int c) {\n        int m = nums.Length;\n        int n = nums[0].Length;\n        \n        if(m*n != r*c){\n            return nums;\n        }\n        \n        var res = new int[r][];\n        for(int i=0;i&lt;r;i++){\n            res[i] = new int[c];\n        }\n        \n        for(int i=0;i&lt;r*c;i++){\n            res[i/c][i%c] = nums[i/n][i%n];\n        }\n        return res;\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p><br />Time Complexity: O(r*c)</p>\n<p>Space Complexity: O(r*c)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/e432d379-95d5-43d3-b36c-514c59c44988.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"reshape-the-matrix-array-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1717,"title":"Task Scheduler - Array - Medium - LeetCode","imageUrl":"icon_ce3e557e-274e-4956-a16f-a62c66777be4.jpg","dateCreated":"2021-01-09T09:25:26.524Z","dateModified":"2021-01-09T09:25:33.09Z","contributedBy":"sumitc91","content":"Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\nHowever, there is","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/ce3e557e-274e-4956-a16f-a62c66777be4.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"task-scheduler-array-medium-leetcode","total":0},{"id":1673,"title":"Minimum Size Subarray Sum - Array - Medium - LeetCode","imageUrl":"icon_9cd5847f-8b41-455d-8ac3-9b66f2dcb47e.jpg","dateCreated":"2020-11-18T09:07:17.833Z","dateModified":"2020-11-18T09:07:23.659Z","contributedBy":"sumitc91","content":"Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum &ge; s. If there isn't one, return 0 instead.\nExample:&nbsp;\nInput: s = 7, nums = [2,3,1,2,4,3]<br />Output: 2<br />Explanation: the subarray [4,3] has t","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/9cd5847f-8b41-455d-8ac3-9b66f2dcb47e.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"minimum-size-subarray-sum-array-medium-leetcode","total":0},{"id":1591,"title":"Leaf-Similar Trees - Tree - Easy - LeetCode","imageUrl":"icon_db0b4415-6ae2-4e32-b111-ad26e1d99874.jpg","dateCreated":"2020-10-09T05:05:38.157Z","dateModified":"2020-10-09T05:05:50.02Z","contributedBy":"sumitc91","content":"Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.\nFor example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).\nTwo binary trees are considered leaf-similar if their leaf value sequence is t","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/db0b4415-6ae2-4e32-b111-ad26e1d99874.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"leaf-similar-trees-tree-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}