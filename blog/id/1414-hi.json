{"id":1414,"title":"Can Place Flowers - Array - Easy - LeetCode","imageUrl":"icon_f7c3f908-d474-48bc-a2db-f168086556da.jpg","dateCreated":"2020-09-26T08:52:29.066Z","dateModified":"2020-09-26T08:52:43.328Z","contributedBy":"sumitc91","content":"<p>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</p>\n<p>Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.</p>\n<p>Example 1:<br />Input: flowerbed = [1,0,0,0,1], n = 1<br />Output: True<br />Example 2:<br />Input: flowerbed = [1,0,0,0,1], n = 2<br />Output: False<br />Note:<br />The input array won't violate no-adjacent-flowers rule.<br />The input array size is in the range of [1, 20000].<br />n is a non-negative integer which won't exceed the input array size.</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public bool CanPlaceFlowers(int[] flowerbed, int n) {\n        int count = 0;\n        if(n==0){\n            return true;\n        }\n        \n        if(flowerbed.Length==0){\n            return false;\n        }\n        \n        if(flowerbed.Length==1){\n            return n==1 &amp;&amp; flowerbed[0]==0;\n        }\n        \n        \n        for(int i=0;i&lt;flowerbed.Length;i++){\n            if(i==0){\n                if(flowerbed[i] == 0 &amp;&amp; flowerbed[i+1]==0){\n                    flowerbed[i]=1;\n                    count++;\n                }\n            }\n            else if(i==flowerbed.Length-1){\n                if(flowerbed[i-1] == 0 &amp;&amp; flowerbed[i]==0){\n                    flowerbed[i]=1;\n                    count++;\n                }\n            }\n            else if(flowerbed[i-1] == 0 &amp;&amp; flowerbed[i] == 0 &amp;&amp; flowerbed[i+1]==0){\n                flowerbed[i]=1;\n                count++;\n            }\n        }\n        \n        return count&gt;=n;\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p><br />Time Complexity: O(n)</p>\n<p>Space Complexity: O(1)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/f7c3f908-d474-48bc-a2db-f168086556da.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"can-place-flowers-array-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1664,"title":"Design an Ordered Stream - Array - Easy - LeetCode","imageUrl":"icon_ee2c2f78-fadb-4eec-b972-5425cc0c84b8.jpg","dateCreated":"2020-11-16T03:10:10.642Z","dateModified":"2020-11-16T03:10:15.886Z","contributedBy":"sumitc91","content":"There are n (id, value) pairs, where id is an integer between 1 and n and value is a string. No two pairs have the same id.\nDesign a stream that takes the n pairs in an arbitrary order, and returns the values over several calls in increasing order of their ids.\nImplement the Ordered","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/ee2c2f78-fadb-4eec-b972-5425cc0c84b8.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"design-an-ordered-stream-array-easy-leetcode","total":0},{"id":1644,"title":"Spiral Matrix - Array - Medium - LeetCode","imageUrl":"icon_37d1b470-7389-4e05-97b1-d92ce68eb1ba.jpg","dateCreated":"2020-10-27T07:19:38.491Z","dateModified":"2020-10-27T07:19:48.756Z","contributedBy":"sumitc91","content":"Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\nExample 1:\nInput:<br />[<br />&nbsp;[ 1, 2, 3 ],<br />&nbsp;[ 4, 5, 6 ],<br />&nbsp;[ 7, 8, 9 ]<br />]<br />Output: [1,2,3,6,9,8,7,4,5]<br />Example 2:\nInput:<br />[<br />","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/37d1b470-7389-4e05-97b1-d92ce68eb1ba.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"spiral-matrix-array-medium-leetcode","total":0},{"id":1638,"title":"Next Permutation - Array - Medium - LeetCode","imageUrl":"icon_467cc3d1-390e-4bc6-a589-9f2b2a7b6f67.jpg","dateCreated":"2020-10-24T11:58:46.632Z","dateModified":"2020-10-24T11:59:00.039Z","contributedBy":"sumitc91","content":"Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\nThe replacement must be in place and use ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/467cc3d1-390e-4bc6-a589-9f2b2a7b6f67.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"next-permutation-array-medium-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}