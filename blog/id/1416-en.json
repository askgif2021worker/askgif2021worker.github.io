{"id":1416,"title":"Image Smoother - Array - Easy - LeetCode","imageUrl":"icon_bbf7a82d-4929-44de-995f-c53e30b9227b.jpg","dateCreated":"2020-09-26T09:54:24.21Z","dateModified":"2020-09-26T09:54:37.313Z","contributedBy":"sumitc91","content":"<p>Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can.</p>\n<p>Example 1:<br />Input:<br />[[1,1,1],<br />&nbsp;[1,0,1],<br />&nbsp;[1,1,1]]<br />Output:<br />[[0, 0, 0],<br />&nbsp;[0, 0, 0],<br />&nbsp;[0, 0, 0]]<br />Explanation:<br />For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0<br />For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0<br />For the point (1,1): floor(8/9) = floor(0.88888889) = 0<br />Note:<br />The value in the given matrix is in the range of [0, 255].<br />The length and width of the given matrix are in the range of [1, 150].</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int[][] ImageSmoother(int[][] M) {\n        var cx= new int[]{-1,-1,-1, 0, 0, 0, 1, 1, 1};\n        var cy= new int[]{-1, 0, 1,-1, 0, 1, -1, 0, 1};\n        \n        var res = new int[M.Length][];\n        for(int i=0;i&lt;M.Length;i++){\n            res[i] = new int[M[i].Length];\n            for(int j=0;j&lt;M[i].Length;j++){\n                int sum = 0;\n                int count = 0;\n                for(int p=0;p&lt;9;p++){\n                    int x = i + cx[p];\n                    int y = j + cy[p];\n                    \n                    if(x&lt;0 || x&gt;M.Length-1){\n                        continue;\n                    }\n                    \n                    if(y&lt;0 || y&gt;M[i].Length-1){\n                        continue;\n                    }\n                    \n                    sum+=M[x][y];\n                    count++;\n                }\n                res[i][j]=sum/count;\n            }\n        }\n        \n        return res;\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p><br />Time Complexity: O(n*m) Where n and m are rows and columns of the given matrix.</p>\n<p>Space Complexity: O(1)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/bbf7a82d-4929-44de-995f-c53e30b9227b.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"image-smoother-array-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1722,"title":"Latest Time by Replacing Hidden Digits - String - Easy - LeetCode","imageUrl":"icon_370ef122-a2da-4596-8095-2a518775a5cb.jpg","dateCreated":"2021-01-26T09:27:11.691Z","dateModified":"2021-01-26T09:27:17.976Z","contributedBy":"sumitc91","content":"You are given a string time in the form of hh:mm, where some of the digits in the string are hidden (represented by ?).\nThe valid times are those inclusively between 00:00 and 23:59.\nReturn the latest valid time you can get from time by replacing the hidden digits.\n&nbsp;","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/370ef122-a2da-4596-8095-2a518775a5cb.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"latest-time-by-replacing-hidden-digits-string-easy-leetcode","total":0},{"id":1703,"title":"Array Nesting - Array - Medium - LeetCode","imageUrl":"icon_5da00dcd-3cd3-4eb0-a2ee-26865bba7184.jpg","dateCreated":"2020-11-21T07:20:04.928Z","dateModified":"2020-11-21T07:20:11.837Z","contributedBy":"sumitc91","content":"A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.\nSuppose the first element in S starts with the selection of element A[i] of index = i, the next e","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/5da00dcd-3cd3-4eb0-a2ee-26865bba7184.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"array-nesting-array-medium-leetcode","total":0},{"id":1642,"title":"Combination Sum II - Array - Medium - LeetCode","imageUrl":"icon_134b4baa-680a-45e5-b0df-c627789e2d42.jpg","dateCreated":"2020-10-25T16:13:32.074Z","dateModified":"2020-10-25T16:13:43.44Z","contributedBy":"sumitc91","content":"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplic","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/134b4baa-680a-45e5-b0df-c627789e2d42.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"combination-sum-ii-array-medium-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}