{"id":1417,"title":"Non-decreasing Array - Array - Easy - LeetCode","imageUrl":"icon_12634768-de83-406e-abb3-94ca67e03410.jpg","dateCreated":"2020-09-26T10:20:15.277Z","dateModified":"2020-09-26T10:20:26.038Z","contributedBy":"sumitc91","content":"<p>Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.</p>\n<p>We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2).</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: nums = [4,2,3]<br />Output: true<br />Explanation: You could modify the first 4 to 1 to get a non-decreasing array.<br />Example 2:</p>\n<p>Input: nums = [4,2,1]<br />Output: false<br />Explanation: You can't get a non-decreasing array by modifying at most one element.<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>1 &lt;= n &lt;= 10 ^ 4<br />- 10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public bool CheckPossibility(int[] nums) {\n        int modify = 0;\n        for(int i=1;i&lt;nums.Length;i++){\n            if(nums[i]&lt;nums[i-1]){\n                modify++;\n                if(i-2&lt;0||nums[i-2]&lt;=nums[i]){\n                    nums[i-1]=nums[i];\n                }\n                else{\n                    nums[i]=nums[i-1];\n                }                \n            }\n        }\n        \n        return modify&lt;=1;\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p><br />Time Complexity: O(n)</p>\n<p>Space Complexity: O(1)</p>\n<p>Explanation:</p>\n<p>The problem requires that every number has to be equal or greater than the previous number.<br />If we encounter a failing condition where the number is not greater or equal to the previous (smaller than previous) we need to make a correction. Correction can be made in either of two ways:</p>\n<p>Make the previous number smaller or equal to the current number<br />Make the current number equal to the previous number<br />We can do (1) as long as the number at position i-2 is equal or lower than the current element. (if i-2 is valid)<br />In case 1 below we can do this at (3) (i = 2) as the element 1 (i = 0) fulfills 1 &lt;= 3. We can replace 7 with 3.<br />However, this cannot be done in case 2 as 4 &lt;= 3 does not satisfy.</p>\n<p>Correction with technique (1) takes priority as there is no risk in lowering the value but there is a risk associated if the value is increased. (Consider a scenario in case 1 if we replace 3 with 7, it will fail to satisfy the condition for the last element)</p>\n<p>We have to make corrections with (2) if we cannot achieve it by (1). In which case we increase the value of the current element by matching the previous element. In case 2, we replace 3 with 7.</p>\n<p>Also, we only compare condition with the previous element only because as we move forward we know the previous numbers are already validated.</p>\n<p>Case 1:<br />&nbsp; &nbsp; &nbsp;7<br />&nbsp; &nbsp; &nbsp;/\\ &nbsp; &nbsp;4<br />&nbsp; &nbsp; / &nbsp;\\ &nbsp;/<br />&nbsp; &nbsp;/ &nbsp; &nbsp;\\/<br />&nbsp; / &nbsp; &nbsp; &nbsp;3<br />&nbsp;1<br />&nbsp;<br />Case 2:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 9<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/<br />&nbsp; &nbsp;7 &nbsp; &nbsp;/<br />&nbsp; &nbsp;/\\ &nbsp;/<br />&nbsp; / &nbsp;\\/<br />&nbsp;/ &nbsp; &nbsp;3<br />4</p>\n<p>&nbsp;</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/12634768-de83-406e-abb3-94ca67e03410.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"non-decreasing-array-array-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1658,"title":"Remove Duplicates from Sorted Array II - Array - Medium - LeetCode","imageUrl":"icon_354cc221-dcd4-4077-91b3-0f1bd91088b2.jpg","dateCreated":"2020-11-01T11:57:49.77Z","dateModified":"2020-11-01T11:57:54.983Z","contributedBy":"sumitc91","content":"Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\nDo not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory.\nClarification:\nConfus","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/354cc221-dcd4-4077-91b3-0f1bd91088b2.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"remove-duplicates-from-sorted-array-ii-array-medium-leetcode","total":0},{"id":1642,"title":"Combination Sum II - Array - Medium - LeetCode","imageUrl":"icon_134b4baa-680a-45e5-b0df-c627789e2d42.jpg","dateCreated":"2020-10-25T16:13:32.074Z","dateModified":"2020-10-25T16:13:43.44Z","contributedBy":"sumitc91","content":"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplic","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/134b4baa-680a-45e5-b0df-c627789e2d42.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"combination-sum-ii-array-medium-leetcode","total":0},{"id":1624,"title":"Shortest Distance to a Character - Array - Easy - LeetCode","imageUrl":"icon_5ae5fc7c-ff85-4fa4-b353-2d4b89a92b76.jpg","dateCreated":"2020-10-18T03:37:10.612Z","dateModified":"2020-10-18T03:37:18.655Z","contributedBy":"sumitc91","content":"Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string.\nExample 1:\nInput: S = \"loveleetcode\", C = 'e'<br />Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]<br />&nbsp;\nNote:\nS string length is i","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/5ae5fc7c-ff85-4fa4-b353-2d4b89a92b76.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"shortest-distance-to-a-character-array-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}