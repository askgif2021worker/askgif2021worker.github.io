{"id":1418,"title":"Maximum Average Subarray I - Array - Easy - LeetCode","imageUrl":"icon_d35f0d3c-7e1b-426e-b70c-1c03e6d2631a.jpg","dateCreated":"2020-09-26T10:29:30.18Z","dateModified":"2020-09-26T10:29:48.307Z","contributedBy":"sumitc91","content":"<p>Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.</p>\n<p>Example 1:</p>\n<p>Input: [1,12,-5,-6,50,3], k = 4<br />Output: 12.75<br />Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75<br />&nbsp;</p>\n<p>Note:</p>\n<p>1 &lt;= k &lt;= n &lt;= 30,000.<br />Elements of the given array will be in the range [-10,000, 10,000].</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public double FindMaxAverage(int[] nums, int k) {\n        if(nums.Length&lt;k){\n            return 0;\n        }\n        \n        int sum = 0;        \n        //sum of first k nums in sliding window\n        for(int i=0;i&lt;k;i++){\n            sum+=nums[i];\n        }\n        int max = sum;\n        //calculate maximum sum window\n        for(int i=1;i&lt;nums.Length-k+1;i++){\n            sum-=nums[i-1];\n            sum+=nums[i+k-1];\n            if(max&lt;sum){\n                max = sum;\n            }\n        }\n        \n        return (double)max/k;\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p><br />Time Complexity: O(n)</p>\n<p>Space Complexity: O(k)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/d35f0d3c-7e1b-426e-b70c-1c03e6d2631a.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"maximum-average-subarray-i-array-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1711,"title":"Count of Matches in Tournament - String - Easy - LeetCode","imageUrl":"icon_d4fba4b6-ab89-4548-aaf7-f9918522d7dd.jpg","dateCreated":"2020-12-28T14:11:46.984Z","dateModified":"2020-12-28T14:11:55.184Z","contributedBy":"sumitc91","content":"You are given an integer n, the number of teams in a tournament that has strange rules:\nIf the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.<br />If the current number of teams is od","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/d4fba4b6-ab89-4548-aaf7-f9918522d7dd.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"count-of-matches-in-tournament-string-easy-leetcode","total":0},{"id":1681,"title":"Circular Array Loop - Array - Medium - LeetCode","imageUrl":"icon_32298a91-8bd5-4e63-872d-105103726a20.jpg","dateCreated":"2020-11-19T09:05:08.281Z","dateModified":"2020-11-19T09:05:14.582Z","contributedBy":"sumitc91","content":"You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it's negative (-k), move backward k steps. Since the array is circular, you may assume that the last element's next element is the first element,","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/32298a91-8bd5-4e63-872d-105103726a20.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"circular-array-loop-array-medium-leetcode","total":0},{"id":1671,"title":"Find Peak Element - Array - Medium - LeetCode","imageUrl":"icon_ddbfc17c-bd5c-47a2-8c7d-53508db12cab.jpg","dateCreated":"2020-11-18T07:03:05.436Z","dateModified":"2020-11-18T07:03:11.729Z","contributedBy":"sumitc91","content":"A peak element is an element that is greater than its neighbors.\nGiven an input array nums, where nums[i] &ne; nums[i+1], find a peak element and return its index.\nThe array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\nYou may ima","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/ddbfc17c-bd5c-47a2-8c7d-53508db12cab.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"find-peak-element-array-medium-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}