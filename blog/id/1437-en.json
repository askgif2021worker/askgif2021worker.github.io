{"id":1437,"title":"Count Good Triplets - Array - Easy - LeetCode","imageUrl":"icon_c3372ec3-9a48-4979-8558-0e759b6f61fe.jpg","dateCreated":"2020-09-27T09:28:59.802Z","dateModified":"2020-09-27T09:29:13.848Z","contributedBy":"sumitc91","content":"<p>Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets.</p>\n<p>A triplet (arr[i], arr[j], arr[k]) is good if the following conditions are true:</p>\n<p>0 &lt;= i &lt; j &lt; k &lt; arr.length<br />|arr[i] - arr[j]| &lt;= a<br />|arr[j] - arr[k]| &lt;= b<br />|arr[i] - arr[k]| &lt;= c<br />Where |x| denotes the absolute value of x.</p>\n<p>Return the number of good triplets.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3<br />Output: 4<br />Explanation: There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)].<br />Example 2:</p>\n<p>Input: arr = [1,1,2,2,3], a = 0, b = 0, c = 1<br />Output: 0<br />Explanation: No triplet satisfies all conditions.<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>3 &lt;= arr.length &lt;= 100<br />0 &lt;= arr[i] &lt;= 1000<br />0 &lt;= a, b, c &lt;= 1000</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int CountGoodTriplets(int[] arr, int a, int b, int c) {\n        int count = 0;\n        for(int i=0;i&lt;arr.Length;i++){\n            for(int j=i+1;j&lt;arr.Length;j++){\n                if(Math.Abs(arr[i]-arr[j])&gt;a){\n                    continue;\n                }\n                for(int k=j+1;k&lt;arr.Length;k++){\n                    if(                        \n                        (Math.Abs(arr[j]-arr[k])&lt;=b)&amp;&amp;\n                        (Math.Abs(arr[i]-arr[k])&lt;=c)\n                      )\n                    {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p><br />Time Complexity: O(n^3)</p>\n<p>Space Complexity: O(1)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/c3372ec3-9a48-4979-8558-0e759b6f61fe.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"count-good-triplets-array-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1709,"title":"Goal Parser Interpretation - String - Easy - LeetCode","imageUrl":"icon_1a301e38-c33f-42ee-b91b-84f1471554f8.jpg","dateCreated":"2020-12-07T04:02:11.892Z","dateModified":"2020-12-07T04:02:17.242Z","contributedBy":"sumitc91","content":"You own a Goal Parser that can interpret a string command. The command consists of an alphabet of \"G\", \"()\" and/or \"(al)\" in some order. The Goal Parser will interpret \"G\" as the string \"G\", \"()\" as the string \"o\", and \"(al)\" as the string \"al\". The interpreted strings are then concatenated in th","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/1a301e38-c33f-42ee-b91b-84f1471554f8.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"goal-parser-interpretation-string-easy-leetcode","total":0},{"id":1703,"title":"Array Nesting - Array - Medium - LeetCode","imageUrl":"icon_5da00dcd-3cd3-4eb0-a2ee-26865bba7184.jpg","dateCreated":"2020-11-21T07:20:04.928Z","dateModified":"2020-11-21T07:20:11.837Z","contributedBy":"sumitc91","content":"A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.\nSuppose the first element in S starts with the selection of element A[i] of index = i, the next e","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/5da00dcd-3cd3-4eb0-a2ee-26865bba7184.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"array-nesting-array-medium-leetcode","total":0},{"id":1599,"title":"Flower Planting With No Adjacent - Graph - Easy - LeetCode","imageUrl":"icon_db7a0ad4-994c-4a3a-a3c6-63035a00d2da.jpg","dateCreated":"2020-10-15T05:15:37.382Z","dateModified":"2020-10-15T05:15:47.948Z","contributedBy":"sumitc91","content":"You have n gardens, labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes the existence of a bidirectional path from garden xi to garden yi. In each garden, you want to plant one of 4 types of flowers.\nThere is no garden that has more than three paths coming into or l","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/db7a0ad4-994c-4a3a-a3c6-63035a00d2da.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"graph","slug":"graph"},{"name":"leetcode","slug":"leetcode"}],"slug":"flower-planting-with-no-adjacent-graph-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}