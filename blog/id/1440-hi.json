{"id":1440,"title":"Most Visited Sector in a Circular Track - Array - Easy - LeetCode","imageUrl":"icon_21fadc87-255a-4f31-bdd7-74fee8b2c480.jpg","dateCreated":"2020-09-27T10:54:37.191Z","dateModified":"2020-09-27T10:54:58.986Z","contributedBy":"sumitc91","content":"<p>Given an integer n and an integer array rounds. We have a circular track which consists of n sectors labeled from 1 to n. A marathon will be held on this track, the marathon consists of m rounds. The ith round starts at sector rounds[i - 1] and ends at sector rounds[i]. For example, round 1 starts at sector rounds[0] and ends at sector rounds[1]</p>\n<p>Return an array of the most visited sectors sorted in ascending order.</p>\n<p>Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).</p>\n<p>Example 1:Input: n = 4, rounds = [1,3,1,2]<br />Output: [1,2]<br />Explanation: The marathon starts at sector 1. The order of the visited sectors is as follows:<br />1 --&gt; 2 --&gt; 3 (end of round 1) --&gt; 4 --&gt; 1 (end of round 2) --&gt; 2 (end of round 3 and the marathon)<br />We can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.<br />Example 2:</p>\n<p>Input: n = 2, rounds = [2,1,2,1,2,1,2,1,2]<br />Output: [2]<br />Example 3:</p>\n<p>Input: n = 7, rounds = [1,3,5,7]<br />Output: [1,2,3,4,5,6,7]<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>2 &lt;= n &lt;= 100<br />1 &lt;= m &lt;= 100<br />rounds.length == m + 1<br />1 &lt;= rounds[i] &lt;= n<br />rounds[i] != rounds[i + 1] for 0 &lt;= i &lt; m</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public IList&lt;int&gt; MostVisited(int n, int[] rounds) {\n        int start = rounds[0];\n        int end = rounds[rounds.Length-1];\n        \n        var res = new List&lt;int&gt;();\n        \n        if(start &lt;= end) {\n            while(start&lt;=end){\n                res.Add(start++);\n            }\n        } else {\n                int i=1;\n                while(i&lt;=end) {\n                    res.Add(i++);\n                }\n                while(start &lt;= n) {\n                    res.Add(start++);\n                }\n        }\n        return res;\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p><br />Time Complexity: O(n)</p>\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/21fadc87-255a-4f31-bdd7-74fee8b2c480.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"most-visited-sector-in-a-circular-track-array-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1723,"title":"Beautiful Arrangement II - Maths - Medium - LeetCode","imageUrl":"icon_b2d502bc-0983-4102-b87f-e37eff0ed0db.jpg","dateCreated":"2021-01-26T13:09:40.384Z","dateModified":"2021-01-26T13:09:46.827Z","contributedBy":"sumitc91","content":"Given two integers n and k, you need to construct a list that contains n different positive integers ranging from 1 to n and obeys the following requirement:<br />Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/b2d502bc-0983-4102-b87f-e37eff0ed0db.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"गणित","slug":"maths"},{"name":"मध्यम","slug":"medium"}],"slug":"beautiful-arrangement-ii-maths-medium-leetcode","total":0},{"id":1654,"title":"Search a 2D Matrix - Array - Medium - LeetCode","imageUrl":"icon_4ecd9aac-a00a-4a8f-ad7b-e7e4a75307ac.jpg","dateCreated":"2020-10-31T10:10:06.758Z","dateModified":"2020-10-31T10:10:15.329Z","contributedBy":"sumitc91","content":"Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\nIntegers in each row are sorted from left to right.<br />The first integer of each row is greater than the last integer of the previous row.<br />&nbsp;\nExample 1:</p","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/4ecd9aac-a00a-4a8f-ad7b-e7e4a75307ac.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"search-a-2d-matrix-array-medium-leetcode","total":0},{"id":1617,"title":"Relative Ranks - Array - Easy - LeetCode","imageUrl":"icon_999e367f-6673-49be-9d6a-411dd5e1e1e2.jpg","dateCreated":"2020-10-17T05:30:58.485Z","dateModified":"2020-10-17T05:31:07.765Z","contributedBy":"sumitc91","content":"Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".\nExample 1:<br />Input: [5, 4, 3, 2, 1]<br />Output: [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]<","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/999e367f-6673-49be-9d6a-411dd5e1e1e2.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"relative-ranks-array-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}