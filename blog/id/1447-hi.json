{"id":1447,"title":"Isomorphic Strings - Hash Table - Easy - LeetCode","imageUrl":"icon_366529a8-12f2-4712-9046-c0f4e106bc58.jpg","dateCreated":"2020-09-27T14:40:32.348Z","dateModified":"2020-09-27T14:40:51.991Z","contributedBy":"sumitc91","content":"<p>Given two strings s and t, determine if they are isomorphic.</p>\n<p>Two strings are isomorphic if the characters in s can be replaced to get t.</p>\n<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>\n<p>Example 1:</p>\n<p>Input: s = \"egg\", t = \"add\"<br />Output: true<br />Example 2:</p>\n<p>Input: s = \"foo\", t = \"bar\"<br />Output: false<br />Example 3:</p>\n<p>Input: s = \"paper\", t = \"title\"<br />Output: true<br />Note:<br />You may assume both s and t have the same length.</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public bool IsIsomorphic(string s, string t) {\n        \n        if(s.Length != t.Length){\n            return false;\n        }\n        \n        var map1 = new Dictionary&lt;char,char&gt;();   \n        var map2 = new Dictionary&lt;char,char&gt;();   \n        for(int i=0;i&lt;s.Length;i++){\n            if(map1.ContainsKey(s[i])){\n                map1[s[i]] = t[i];\n            }\n            else{\n                map1.Add(s[i],t[i]);\n            }  \n            \n            if(map2.ContainsKey(t[i])){\n                map2[t[i]] = s[i];\n            }\n            else{\n                map2.Add(t[i],s[i]);\n            } \n        }\n        \n        for(int i=0;i&lt;s.Length;i++){\n            if(map1[s[i]]!=t[i]){\n                return false;\n            }\n            \n            if(map2[t[i]]!=s[i]){\n                return false;\n            }\n        }\n                \n        return true;\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p><br />Time Complexity: O(n)</p>\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/366529a8-12f2-4712-9046-c0f4e106bc58.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"isomorphic-strings-hash-table-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"hash-table","slug":"hash-table"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1641,"title":"Combination Sum - Array - Medium - LeetCode","imageUrl":"icon_b42ea67c-de94-42f6-aa57-391837827a47.jpg","dateCreated":"2020-10-25T14:37:09.044Z","dateModified":"2020-10-25T14:37:53.305Z","contributedBy":"sumitc91","content":"Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of time","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/b42ea67c-de94-42f6-aa57-391837827a47.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"combination-sum-array-medium-leetcode","total":0},{"id":1640,"title":"Find First and Last Position of Element in Sorted Array - Array - Medium - LeetCode","imageUrl":"icon_4dd548b4-7f64-4384-8000-de99e5e3a765.jpg","dateCreated":"2020-10-25T13:25:33.524Z","dateModified":"2020-10-25T13:25:43.128Z","contributedBy":"sumitc91","content":"Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\nIf the target is not found in the array, return [-1, -1].\nFollow up: Could you write an algorithm with O(log n) runtime complexity?\n&nbsp;\nExample ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/4dd548b4-7f64-4384-8000-de99e5e3a765.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"find-first-and-last-position-of-element-in-sorted-array-array-medium-leetcode","total":0},{"id":1636,"title":"Two Strings - HashMap - Easy - HackerRank","imageUrl":"icon_b574251c-e9c0-4be6-9bc1-7c86f8da1806.jpg","dateCreated":"2020-10-24T07:22:16.972Z","dateModified":"2020-10-24T07:22:22.952Z","contributedBy":"sumitc91","content":"Given two strings, determine if they share a common substring. A substring may be as small as one character.\nFor example, the words \"a\", \"and\", \"art\" share the common substring . The words \"be\" and \"cat\" do not share a substring.\nFunction Description\nComplete the function two","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/b574251c-e9c0-4be6-9bc1-7c86f8da1806.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"hackerrank","slug":"hackerrank"},{"name":"hash-table","slug":"hash-table"}],"slug":"two-strings-hashmap-easy-hackerrank","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}