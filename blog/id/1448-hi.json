{"id":1448,"title":"Valid Anagram - Hash Table - Easy - LeetCode","imageUrl":"icon_91fab41d-4058-4af9-a039-58567ffe7937.jpg","dateCreated":"2020-09-28T04:04:40.16Z","dateModified":"2020-09-28T04:04:52.785Z","contributedBy":"sumitc91","content":"<p>Given two strings s and t , write a function to determine if t is an anagram of s.</p>\n<p>Example 1:</p>\n<p>Input: s = \"anagram\", t = \"nagaram\"<br />Output: true<br />Example 2:</p>\n<p>Input: s = \"rat\", t = \"car\"<br />Output: false<br />Note:<br />You may assume the string contains only lowercase alphabets.</p>\n<p>Follow up:<br />What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public bool IsAnagram(string s, string t) {\n        if(s.Length != t.Length){\n            return false;\n        }\n        var map1 = new Dictionary&lt;char,int&gt;();\n        var map2 = new Dictionary&lt;char,int&gt;();\n        for(int i=0;i&lt;s.Length;i++){\n            if(map1.ContainsKey(s[i])){\n                map1[s[i]]++;\n            }\n            else{\n                map1.Add(s[i],1);\n            }\n            \n            if(map2.ContainsKey(t[i])){\n                map2[t[i]]++;\n            }\n            else{\n                map2.Add(t[i],1);\n            }\n        }\n        \n        foreach(var item in map1){\n            if(!map2.ContainsKey(item.Key)){\n                return false;\n            }\n            \n            if(item.Value != map2[item.Key]){\n                return false;\n            }\n        }\n        \n        foreach(var item in map2){\n            if(!map1.ContainsKey(item.Key)){\n                return false;\n            }\n            \n            if(item.Value != map1[item.Key]){\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p><br />Time Complexity: O(n)</p>\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/91fab41d-4058-4af9-a039-58567ffe7937.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"valid-anagram-hash-table-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"hash-table","slug":"hash-table"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1726,"title":"Maximum Swap - Array - Medium - LeetCode","imageUrl":"icon_16589057-204a-4929-8beb-ec745719515b.jpg","dateCreated":"2021-03-04T10:15:19.693Z","dateModified":"2021-03-04T10:16:54.289Z","contributedBy":"sumitc91","content":"Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.\nExample 1:<br />Input: 2736<br />Output: 7236<br />Explanation: Swap the number 2 and the number 7.<br />Example 2:<br />Input: 9973<br />O","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/16589057-204a-4929-8beb-ec745719515b.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"maximum-swap-array-medium-leetcode","total":0},{"id":1639,"title":"Search in Rotated Sorted Array - Array - Medium - LeetCode","imageUrl":"icon_92804ec8-8b64-41e0-a4f4-89ed11e1a5e2.jpg","dateCreated":"2020-10-24T14:15:15.013Z","dateModified":"2020-10-24T14:15:23.602Z","contributedBy":"sumitc91","content":"You are given an integer array nums sorted in ascending order, and an integer target.\nSuppose that nums is rotated at some pivot unknown to you beforehand (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\nIf target is found in the array return its index, otherwise, return -1.</p","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/92804ec8-8b64-41e0-a4f4-89ed11e1a5e2.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"search-in-rotated-sorted-array-array-medium-leetcode","total":0},{"id":1629,"title":"Maximum Nesting Depth of the Parentheses - Stack - Easy - LeetCode","imageUrl":"icon_9d515e72-4c83-4541-9650-c0972215972d.jpg","dateCreated":"2020-10-18T08:20:30.391Z","dateModified":"2020-10-18T08:20:41.012Z","contributedBy":"sumitc91","content":"A string is a valid parentheses string (denoted VPS) if it meets one of the following:\nIt is an empty string \"\", or a single character not equal to \"(\" or \")\",<br />It can be written as AB (A concatenated with B), where A and B are VPS's, or<br />It can be written as (A), where A is a VPS.","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/9d515e72-4c83-4541-9650-c0972215972d.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"stack","slug":"stack"}],"slug":"maximum-nesting-depth-of-the-parentheses-stack-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}