{"id":1450,"title":"Intersection of Two Arrays II - Hash Table - Easy - LeetCode","imageUrl":"icon_8cba914a-6340-473d-909a-903de35a2e83.jpg","dateCreated":"2020-09-28T05:00:38.527Z","dateModified":"2020-09-28T05:01:10.966Z","contributedBy":"sumitc91","content":"<p>Given two arrays, write a function to compute their intersection.</p>\n<p>Example 1:</p>\n<p>Input: nums1 = [1,2,2,1], nums2 = [2,2]<br />Output: [2,2]<br />Example 2:</p>\n<p>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br />Output: [4,9]<br />Note:</p>\n<p>Each element in the result should appear as many times as it shows in both arrays.<br />The result can be in any order.<br />Follow up:</p>\n<p>What if the given array is already sorted? How would you optimize your algorithm?<br />What if nums1's size is small compared to nums2's size? Which algorithm is better?<br />What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int[] Intersect(int[] nums1, int[] nums2) {\n        var map1 = new Dictionary&lt;int,int&gt;();\n        var map2 = new Dictionary&lt;int,int&gt;();\n        for(int i=0;i&lt;nums1.Length;i++){\n            if(map1.ContainsKey(nums1[i])){\n                map1[nums1[i]]++;\n            }\n            else{\n                map1.Add(nums1[i],1);\n            }\n        }\n        \n        for(int i=0;i&lt;nums2.Length;i++){\n            if(map2.ContainsKey(nums2[i])){\n                map2[nums2[i]]++;\n            }\n            else{\n                map2.Add(nums2[i],1);\n            }\n        }\n        \n        var list = new List&lt;int&gt;();\n        foreach(var item in map1){\n            if(map2.ContainsKey(item.Key)){\n                int minCount = Math.Min(item.Value,map2[item.Key]);\n                for(int i=0;i&lt;minCount;i++){\n                    list.Add(item.Key);\n                }\n            }\n        }\n        \n        return list.ToArray();\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p><br />Time Complexity: O(n)</p>\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8cba914a-6340-473d-909a-903de35a2e83.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"intersection-of-two-arrays-ii-hash-table-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"hash-table","slug":"hash-table"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1711,"title":"Count of Matches in Tournament - String - Easy - LeetCode","imageUrl":"icon_d4fba4b6-ab89-4548-aaf7-f9918522d7dd.jpg","dateCreated":"2020-12-28T14:11:46.984Z","dateModified":"2020-12-28T14:11:55.184Z","contributedBy":"sumitc91","content":"You are given an integer n, the number of teams in a tournament that has strange rules:\nIf the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.<br />If the current number of teams is od","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/d4fba4b6-ab89-4548-aaf7-f9918522d7dd.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"count-of-matches-in-tournament-string-easy-leetcode","total":0},{"id":1701,"title":"K-diff Pairs in an Array - Array - Medium - LeetCode","imageUrl":"icon_adbe88a9-d88c-469f-ae16-26daa92dc3b3.jpg","dateCreated":"2020-11-20T09:11:47.894Z","dateModified":"2020-11-20T09:11:56.252Z","contributedBy":"sumitc91","content":"Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array.\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\n0 &lt;= i, j &lt; nums.length<br />i != j<br />|nums[i] - nums[j]| == k<br />Notice that |val| ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8c421996-adef-4a2c-b776-f3e3810e1e3b.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"k-diff-pairs-in-an-array-array-medium-leetcode","total":0},{"id":1642,"title":"Combination Sum II - Array - Medium - LeetCode","imageUrl":"icon_134b4baa-680a-45e5-b0df-c627789e2d42.jpg","dateCreated":"2020-10-25T16:13:32.074Z","dateModified":"2020-10-25T16:13:43.44Z","contributedBy":"sumitc91","content":"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplic","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/134b4baa-680a-45e5-b0df-c627789e2d42.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"combination-sum-ii-array-medium-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}