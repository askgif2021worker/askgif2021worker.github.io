{"id":1455,"title":"Island Perimeter - Hash Table - Easy - LeetCode","imageUrl":"icon_46207587-0bd2-495e-92cd-74c25be2d3b2.jpg","dateCreated":"2020-09-28T11:32:21.454Z","dateModified":"2020-09-28T11:32:40.791Z","contributedBy":"sumitc91","content":"<p>ou are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.</p>\n<p>Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).</p>\n<p>The island doesn't have \"lakes\", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p><br />Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]<br />Output: 16<br />Explanation: The perimeter is the 16 yellow stripes in the image above.<br />Example 2:</p>\n<p>Input: grid = [[1]]<br />Output: 4<br />Example 3:</p>\n<p>Input: grid = [[1,0]]<br />Output: 4<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>row == grid.length<br />col == grid[i].length<br />1 &lt;= row, col &lt;= 100<br />grid[i][j] is 0 or 1.</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int IslandPerimeter(int[][] grid) {\n        int islands = 0;\n        int neighbours = 0;\n        for(int i=0;i&lt;grid.Length;i++){\n            for(int j=0;j&lt;grid[0].Length;j++){\n                if(grid[i][j]==0){\n                    continue;\n                }\n                \n                islands++;\n                if(i&lt;grid.Length-1){\n                    if(grid[i+1][j]==1){\n                        neighbours++;\n                    }\n                }\n                \n                if(j&lt;grid[0].Length-1){\n                    if(grid[i][j+1]==1){\n                        neighbours++;\n                    }\n                }\n            }\n        }\n        \n        return islands*4 - neighbours*2;\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p><br />Time Complexity: O(n)</p>\n<p>Space Complexity: O(1)</p>\n<p>loop over the matrix and count the number of islands;<br />if the current dot is an island, count if it has any right neighbours or down neighbours;<br />the result is islands * 4 - neighbours * 2</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/46207587-0bd2-495e-92cd-74c25be2d3b2.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"island-perimeter-hash-table-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"hash-table","slug":"hash-table"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1675,"title":"Majority Element II - Array - Medium - LeetCode","imageUrl":"icon_17b104bf-91b6-48b5-a7b8-2d58b5ba4b4e.jpg","dateCreated":"2020-11-18T12:22:28.829Z","dateModified":"2020-11-18T12:22:35.442Z","contributedBy":"sumitc91","content":"Given an integer array of size n, find all elements that appear more than &lfloor; n/3 &rfloor; times.\nFollow-up: Could you solve the problem in linear time and in O(1) space?\n&nbsp;\nExample 1:\nInput: nums = [3,2,3]<br />Output: [3]<br />Example 2:\nInput: nums =","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/17b104bf-91b6-48b5-a7b8-2d58b5ba4b4e.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"majority-element-ii-array-medium-leetcode","total":0},{"id":1670,"title":"Find Minimum in Rotated Sorted Array - Array - Medium - LeetCode","imageUrl":"icon_d1be15f3-8f69-4050-83a2-f9c67ac5827b.jpg","dateCreated":"2020-11-18T02:56:56.195Z","dateModified":"2020-11-18T02:57:02.762Z","contributedBy":"sumitc91","content":"Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n[4,5,6,7,0,1,2] if it was rotated 4 times.<br />[0,1,2,4,5,6,7] if it was rotated 7 times.<br />Notice that rotating an array [a[0], a[1], a[","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/d1be15f3-8f69-4050-83a2-f9c67ac5827b.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"व्यायाम","slug":"athletics"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"मध्यम","slug":"medium"}],"slug":"find-minimum-in-rotated-sorted-array-array-medium-leetcode","total":0},{"id":1601,"title":"N-th Tribonacci Number - Recursion - Easy - LeetCode","imageUrl":"icon_8864cfe3-0823-418f-867d-6299b93c28bd.jpg","dateCreated":"2020-10-15T09:12:30.383Z","dateModified":"2020-10-15T09:12:56.022Z","contributedBy":"sumitc91","content":"The Tribonacci sequence Tn is defined as follows:&nbsp;\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &gt;= 0.\nGiven n, return the value of Tn.\n&nbsp;\nExample 1:\nInput: n = 4<br />Output: 4<br />Explanation:<br />T_3 = 0 + 1 + 1 = 2<br />T_4 = 1 + 1 ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8864cfe3-0823-418f-867d-6299b93c28bd.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"dynamic-programming","slug":"dynamic-programming"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"recursion","slug":"recursion"}],"slug":"n-th-tribonacci-number-recursion-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}