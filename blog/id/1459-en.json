{"id":1459,"title":"Minimum Index Sum of Two Lists - Hash Table - Easy - LeetCode","imageUrl":"icon_ff5802f5-6d2b-4e75-a08f-6b92bb2eccb5.jpg","dateCreated":"2020-09-29T03:59:03.102Z","dateModified":"2020-09-29T03:59:11.608Z","contributedBy":"sumitc91","content":"<p>Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.</p>\n<p>You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.</p>\n<p>Example 1:<br />Input:<br />[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]<br />[\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]<br />Output: [\"Shogun\"]<br />Explanation: The only restaurant they both like is \"Shogun\".<br />Example 2:<br />Input:<br />[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]<br />[\"KFC\", \"Shogun\", \"Burger King\"]<br />Output: [\"Shogun\"]<br />Explanation: The restaurant they both like and have the least index sum is \"Shogun\" with index sum 1 (0+1).<br />Note:<br />The length of both lists will be in the range of [1, 1000].<br />The length of strings in both lists will be in the range of [1, 30].<br />The index is starting from 0 to the list length minus 1.<br />No duplicates in both lists.</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public string[] FindRestaurant(string[] list1, string[] list2) {\n        var map1 = new Dictionary&lt;string,int&gt;();\n        var map2 = new Dictionary&lt;string,int&gt;();\n        for(int i=0;i&lt;list1.Length;i++){\n            map1.Add(list1[i],i);\n        }\n        \n        for(int i=0;i&lt;list2.Length;i++){\n            map2.Add(list2[i],i);\n        }\n        \n        int min = int.MaxValue;\n        var result = new List&lt;string&gt;();\n        foreach(var item in map1){\n            if(map2.ContainsKey(item.Key)){\n                var sum = item.Value+map2[item.Key];\n                if(sum&lt;min){\n                    min = sum;\n                    result.Clear();\n                    result.Add(item.Key);\n                }         \n                else if(sum==min){\n                    result.Add(item.Key);\n                }\n            }\n        }\n        \n        return result.ToArray();\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p><br />Time Complexity: O(n)</p>\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/ff5802f5-6d2b-4e75-a08f-6b92bb2eccb5.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"minimum-index-sum-of-two-lists-hash-table-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"hash-table","slug":"hash-table"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1673,"title":"Minimum Size Subarray Sum - Array - Medium - LeetCode","imageUrl":"icon_9cd5847f-8b41-455d-8ac3-9b66f2dcb47e.jpg","dateCreated":"2020-11-18T09:07:17.833Z","dateModified":"2020-11-18T09:07:23.659Z","contributedBy":"sumitc91","content":"Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum &ge; s. If there isn't one, return 0 instead.\nExample:&nbsp;\nInput: s = 7, nums = [2,3,1,2,4,3]<br />Output: 2<br />Explanation: the subarray [4,3] has t","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/9cd5847f-8b41-455d-8ac3-9b66f2dcb47e.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"minimum-size-subarray-sum-array-medium-leetcode","total":0},{"id":1666,"title":"Construct Binary Tree from Preorder and Inorder Traversal - Array - Medium - LeetCode","imageUrl":"icon_af4cfea8-d43c-4a5f-aded-bc8e7ebfe296.jpg","dateCreated":"2020-11-17T10:00:03.216Z","dateModified":"2020-11-17T10:00:07.655Z","contributedBy":"sumitc91","content":"Given preorder and inorder traversal of a tree, construct the binary tree.\nNote:<br />You may assume that duplicates do not exist in the tree.\nFor example, given\npreorder = [3,9,20,15,7]<br />inorder = [9,3,15,20,7]<br />Return the following binary tree:\n&nbsp; &nbsp; ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/af4cfea8-d43c-4a5f-aded-bc8e7ebfe296.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"construct-binary-tree-from-preorder-and-inorder-traversal-array-medium-leetcode","total":0},{"id":1606,"title":"Combine Two Tables - Sql - Easy - LeetCode","imageUrl":"icon_88b1c8bf-74b6-45d3-8314-cbd4ac4ead29.jpg","dateCreated":"2020-10-16T05:53:11.599Z","dateModified":"2020-10-16T05:53:36.309Z","contributedBy":"sumitc91","content":"Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:\nTable: Person\n+-------------+---------+<br />| Column Name | Type &nbsp; &nbsp;|<br />+-------------+---------+<br ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/5b6e96ac-0881-4845-bd1a-6f2f1cbcf99e.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"mysql","slug":"mysql"},{"name":"sql","slug":"sql"}],"slug":"combine-two-tables-sql-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}