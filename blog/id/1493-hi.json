{"id":1493,"title":"Valid Perfect Square - Math - Easy - LeetCode","imageUrl":"icon_f4cf87e4-4811-47a1-bcd1-1f478fe98b9f.jpg","dateCreated":"2020-10-01T07:03:23.305Z","dateModified":"2020-10-01T07:03:32.081Z","contributedBy":"sumitc91","content":"<p>Given a positive integer num, write a function that returns True if num is a perfect square else False.</p>\n<p>Follow up: Do not use any built-in library function such as sqrt.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: num = 16<br />Output: true<br />Example 2:</p>\n<p>Input: num = 14<br />Output: false<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>1 &lt;= num &lt;= 2^31 - 1</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public bool IsPerfectSquare(int num) {\n        int i = 1;\n        int sum = 0;\n        while (sum &lt; num) {\n            sum += i;\n            if(sum&lt;0){\n                return false;\n            }\n            i += 2;\n        }\n        return sum==num;\n    }\n}</code></pre>\n<p>Time Complexity: O(n)</p>\n<p>Space Complexity: O(1)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/f4cf87e4-4811-47a1-bcd1-1f478fe98b9f.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"valid-perfect-square-math-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"गणित","slug":"maths"}],"recommendations":[{"id":1647,"title":"Slowest Key - Array - Easy - LeetCode","imageUrl":"icon_836f29a5-8a43-4160-b64a-fbf8416788bd.jpg","dateCreated":"2020-10-31T03:14:43.566Z","dateModified":"2020-10-31T03:14:48.648Z","contributedBy":"sumitc91","content":"A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.\nYou are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith k","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/836f29a5-8a43-4160-b64a-fbf8416788bd.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"slowest-key-array-easy-leetcode","total":0},{"id":1631,"title":"Largest Substring Between Two Equal Characters - Array - Easy - LeetCode","imageUrl":"icon_696afb81-fd63-43c4-a6e8-038e3152e83e.jpg","dateCreated":"2020-10-18T09:57:37.517Z","dateModified":"2020-10-18T09:57:48.765Z","contributedBy":"sumitc91","content":"Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.\n&nbsp;\nExample 1:\nInput: s = \"aa\"<br />","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/696afb81-fd63-43c4-a6e8-038e3152e83e.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"largest-substring-between-two-equal-characters-array-easy-leetcode","total":0},{"id":1596,"title":"Sum of Root To Leaf Binary Numbers - Tree - Easy - LeetCode","imageUrl":"icon_41e87329-1dad-4856-9c47-60b67b520656.jpg","dateCreated":"2020-10-09T09:37:18.648Z","dateModified":"2020-10-09T09:37:29.591Z","contributedBy":"sumitc91","content":"You are given the root of a binary tree where each node has a value 0 or 1. &nbsp;Each root-to-leaf path represents a binary number starting with the most significant bit. &nbsp;For example, if the path is 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1, then this could represent 01101 in binary, which is 13.<","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/41e87329-1dad-4856-9c47-60b67b520656.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"sum-of-root-to-leaf-binary-numbers-tree-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}