{"id":1519,"title":"Path Crossing - String - Easy - LeetCode","imageUrl":"icon_a28decf6-6f2f-4a7a-990b-ddcf45aa955f.jpg","dateCreated":"2020-10-02T09:33:39.167Z","dateModified":"2020-10-02T09:33:58.835Z","contributedBy":"sumitc91","content":"<p>Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.</p>\n<p>Return True if the path crosses itself at any point, that is, if at any time you are on a location you've previously visited. Return False otherwise.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>&nbsp;</p>\n<p>Input: path = \"NES\"<br />Output: false&nbsp;<br />Explanation: Notice that the path doesn't cross any point more than once.<br />Example 2:</p>\n<p>&nbsp;</p>\n<p>Input: path = \"NESWW\"<br />Output: true<br />Explanation: Notice that the path visits the origin twice.<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>1 &lt;= path.length &lt;= 10^4<br />path will only consist of characters in {'N', 'S', 'E', 'W}</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public bool IsPathCrossing(string path) {\n        int x = 0;\n        int y = 0;\n        var set = new HashSet&lt;string&gt;();\n        set.Add(GetKey(x,y));\n        for(int i=0;i&lt;path.Length;i++){\n            switch(path[i]){\n                case 'E':\n                    x++;\n                    break;\n                case 'W':\n                    x--;\n                    break;\n                case 'N':\n                    y++;\n                    break;\n                case 'S':\n                    y--;\n                    break;\n            }\n            if(set.Contains(GetKey(x,y))){\n                return true;\n            }\n            set.Add(GetKey(x,y));\n        }\n        \n        return false;\n    }\n    \n    private string GetKey(int x, int y){\n        return x.ToString()+\":\"+y.ToString();\n    }\n}</code></pre>\n<p>Time Complexity: O(n)</p>\n<p>Space Complexity: O(n)</p>\n<p>&nbsp;</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a28decf6-6f2f-4a7a-990b-ddcf45aa955f.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"path-crossing-string-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"recommendations":[{"id":1661,"title":"Get Maximum in Generated Array - Array - Easy - LeetCode","imageUrl":"icon_6268cd06-1d1b-409d-9665-cbe40d65c81d.jpg","dateCreated":"2020-11-08T08:10:40.511Z","dateModified":"2020-11-08T08:10:45.589Z","contributedBy":"sumitc91","content":"You are given an integer n. An array nums of length n + 1 is generated in the following way:\nnums[0] = 0<br />nums[1] = 1<br />nums[2 * i] = nums[i] when 2 &lt;= 2 * i &lt;= n<br />nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 &lt;= 2 * i + 1 &lt;= n<br />Return the maximum integer in the","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/6268cd06-1d1b-409d-9665-cbe40d65c81d.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"get-maximum-in-generated-array-array-easy-leetcode","total":0},{"id":1629,"title":"Maximum Nesting Depth of the Parentheses - Stack - Easy - LeetCode","imageUrl":"icon_9d515e72-4c83-4541-9650-c0972215972d.jpg","dateCreated":"2020-10-18T08:20:30.391Z","dateModified":"2020-10-18T08:20:41.012Z","contributedBy":"sumitc91","content":"A string is a valid parentheses string (denoted VPS) if it meets one of the following:\nIt is an empty string \"\", or a single character not equal to \"(\" or \")\",<br />It can be written as AB (A concatenated with B), where A and B are VPS's, or<br />It can be written as (A), where A is a VPS.","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/9d515e72-4c83-4541-9650-c0972215972d.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"stack","slug":"stack"}],"slug":"maximum-nesting-depth-of-the-parentheses-stack-easy-leetcode","total":0},{"id":1627,"title":"Number of Days Between Two Dates - Maths - Easy - LeetCode","imageUrl":"icon_c8c70ab5-92c2-4bfd-ad83-d0a6afbe3ded.jpg","dateCreated":"2020-10-18T06:18:04.266Z","dateModified":"2020-10-18T06:18:17.665Z","contributedBy":"sumitc91","content":"Write a program to count the number of days between two dates.\nThe two dates are given as strings, their format is YYYY-MM-DD as shown in the examples.\n&nbsp;\nExample 1:\nInput: date1 = \"2019-06-29\", date2 = \"2019-06-30\"<br />Output: 1<br />Example 2:\nInput: date","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/c8c70ab5-92c2-4bfd-ad83-d0a6afbe3ded.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"maths","slug":"maths"}],"slug":"number-of-days-between-two-dates-maths-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}