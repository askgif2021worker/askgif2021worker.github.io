{"id":1524,"title":"Rearrange Spaces Between Words - String - Easy - LeetCode","imageUrl":"icon_14fd5351-f838-4c15-8e78-5201b52966a2.jpg","dateCreated":"2020-10-02T11:34:32.747Z","dateModified":"2020-10-02T11:34:58.718Z","contributedBy":"sumitc91","content":"<p>You are given a string text of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that text contains at least one word.</p>\n<p>Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words and that number is maximized. If you cannot redistribute all the spaces equally, place the extra spaces at the end, meaning the returned string should be the same length as text.</p>\n<p>Return the string after rearranging the spaces.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: text = \" &nbsp;this &nbsp; is &nbsp;a sentence \"<br />Output: \"this &nbsp; is &nbsp; a &nbsp; sentence\"<br />Explanation: There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces.<br />Example 2:</p>\n<p>Input: text = \" practice &nbsp; makes &nbsp; perfect\"<br />Output: \"practice &nbsp; makes &nbsp; perfect \"<br />Explanation: There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string.<br />Example 3:</p>\n<p>Input: text = \"hello &nbsp; world\"<br />Output: \"hello &nbsp; world\"<br />Example 4:</p>\n<p>Input: text = \" &nbsp;walks &nbsp;udp package &nbsp; into &nbsp;bar a\"<br />Output: \"walks &nbsp;udp &nbsp;package &nbsp;into &nbsp;bar &nbsp;a \"<br />Example 5:</p>\n<p>Input: text = \"a\"<br />Output: \"a\"<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>1 &lt;= text.length &lt;= 100<br />text consists of lowercase English letters and ' '.<br />text contains at least one word.</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public string ReorderSpaces(string text) {\n        int spaces = 0;        \n        for(int i=0;i&lt;text.Length;i++){\n            if(text[i]==' '){\n                spaces++;\n            }\n        }\n                \n        var arr = text.Split(' ');        \n        var list = new List&lt;string&gt;();\n        foreach(var item in arr){\n            if(string.IsNullOrEmpty(item)){\n                continue;\n            }\n           list.Add(item);\n        }\n       \n        int equalSpaces = spaces;\n        if(list.Count&gt;1){\n            equalSpaces = spaces/(list.Count-1); \n        }\n        \n        var sb = new StringBuilder();\n        foreach(var item in list){\n            sb.Append(item);            \n            for(int i=0;i&lt;equalSpaces &amp;&amp; spaces &gt; 0;i++){\n                sb.Append(\" \");\n                spaces--;\n            }\n        }\n        \n        while(spaces&gt;0){\n            sb.Append(\" \");\n            spaces--;\n        }\n        \n        return sb.ToString();\n    }\n}</code></pre>\n<p>Time Complexity: O(n)</p>\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/14fd5351-f838-4c15-8e78-5201b52966a2.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"rearrange-spaces-between-words-string-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"recommendations":[{"id":1728,"title":"Minimum Changes To Make Alternating Binary String - String - Easy - LeetCode","imageUrl":"icon_85c66994-0911-4abb-b06f-a20a0a11dcd4.jpg","dateCreated":"2021-03-31T07:22:03.012Z","dateModified":"2021-03-31T07:22:08.602Z","contributedBy":"sumitc91","content":"You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.\nThe string is called alternating if no two adjacent characters are equal. For example, the string \"010\" is alternating, while the string \"0100\" is not.","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/85c66994-0911-4abb-b06f-a20a0a11dcd4.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"minimum-changes-to-make-alternating-binary-string-string-easy-leetcode","total":0},{"id":1620,"title":"Not Boring Movies - Sql - Easy - LeetCode","imageUrl":"icon_2264c3af-9542-4c4d-946f-2d631ae1b7f8.jpg","dateCreated":"2020-10-17T06:24:31.074Z","dateModified":"2020-10-17T06:24:53.421Z","contributedBy":"sumitc91","content":"X city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies&rsquo; ratings and descriptions.<br />Please write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rat","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/2264c3af-9542-4c4d-946f-2d631ae1b7f8.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"sql","slug":"sql"}],"slug":"not-boring-movies-sql-easy-leetcode","total":0},{"id":1600,"title":"Design Parking System - Design - Easy - LeetCode","imageUrl":"icon_2c48fcf9-50ff-4bd1-9d59-5a5807a0e9ab.jpg","dateCreated":"2020-10-15T05:28:49.957Z","dateModified":"2020-10-15T05:49:22.82Z","contributedBy":"sumitc91","content":"Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.\nImplement the ParkingSystem class:\nParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/2c48fcf9-50ff-4bd1-9d59-5a5807a0e9ab.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"design","slug":"design"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"design-parking-system-design-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}