{"id":1533,"title":"House Robber - Array - Easy - LeetCode","imageUrl":"icon_2717f343-9cb4-4034-ac53-2988b9967c7c.jpg","dateCreated":"2020-10-03T09:53:12.425Z","dateModified":"2020-10-03T09:53:24.869Z","contributedBy":"sumitc91","content":"<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>\n<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: nums = [1,2,3,1]<br />Output: 4<br />Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Total amount you can rob = 1 + 3 = 4.<br />Example 2:</p>\n<p>Input: nums = [2,7,9,3,1]<br />Output: 12<br />Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Total amount you can rob = 2 + 9 + 1 = 12.<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>0 &lt;= nums.length &lt;= 100<br />0 &lt;= nums[i] &lt;= 400</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int Rob(int[] nums) {\n        if(nums.Length==0){\n            return 0;\n        }\n        if(nums.Length == 1){\n            return nums[0];\n        }\n        int skipSum = 0;\n        int currSum = nums[0];\n        \n        for(int i=1;i&lt;nums.Length;i++){\n            int max = Math.Max(nums[i]+skipSum, currSum);\n            skipSum = currSum;\n            currSum = max;\n        }\n        \n        return Math.Max(skipSum, currSum);\n    }\n}</code></pre>\n<p>Time Complexity: O(n)</p>\n<p>Space Complexity: O(1)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/2717f343-9cb4-4034-ac53-2988b9967c7c.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"house-robber-array-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"dynamic-programming","slug":"dynamic-programming"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1681,"title":"Circular Array Loop - Array - Medium - LeetCode","imageUrl":"icon_32298a91-8bd5-4e63-872d-105103726a20.jpg","dateCreated":"2020-11-19T09:05:08.281Z","dateModified":"2020-11-19T09:05:14.582Z","contributedBy":"sumitc91","content":"You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it's negative (-k), move backward k steps. Since the array is circular, you may assume that the last element's next element is the first element,","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/32298a91-8bd5-4e63-872d-105103726a20.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"circular-array-loop-array-medium-leetcode","total":0},{"id":1628,"title":"Special Array With X Elements Greater Than or Equal X - Array - Easy - LeetCode","imageUrl":"icon_8f426000-750a-4ff1-bb71-5a34851ae354.jpg","dateCreated":"2020-10-18T06:57:23.217Z","dateModified":"2020-10-18T06:57:30.65Z","contributedBy":"sumitc91","content":"You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.\nNotice that x does not have to be an element in nums.\nReturn x if the array is special, othe","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8f426000-750a-4ff1-bb71-5a34851ae354.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"special-array-with-x-elements-greater-than-or-equal-x-array-easy-leetcode","total":0},{"id":1625,"title":"Print in Order - Multi Threading - Easy - LeetCode","imageUrl":"icon_3e17a90d-8d3d-4655-9ad5-34bee8157e21.jpg","dateCreated":"2020-10-18T04:04:15.138Z","dateModified":"2020-10-18T04:04:52.636Z","contributedBy":"sumitc91","content":"Suppose we have a class:\npublic class Foo {<br />&nbsp; public void first() { print(\"first\"); }<br />&nbsp; public void second() { print(\"second\"); }<br />&nbsp; public void third() { print(\"third\"); }<br />}<br />The same instance of Foo will be passed to three different threads. Thread A","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/3e17a90d-8d3d-4655-9ad5-34bee8157e21.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"multi-threading","slug":"multi-threading"}],"slug":"print-in-order-multi-threading-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}