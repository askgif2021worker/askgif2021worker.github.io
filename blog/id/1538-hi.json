{"id":1538,"title":"Next Greater Element I - Stacks - Easy - LeetCode","imageUrl":"icon_77322c88-6360-41ec-8f11-72888f8f5b19.jpg","dateCreated":"2020-10-03T12:43:07.03Z","dateModified":"2020-10-03T12:43:25.509Z","contributedBy":"sumitc91","content":"<p>You are given two arrays (without duplicates) nums1 and nums2 where nums1&rsquo;s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.</p>\n<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>\n<p>Example 1:<br />Input: nums1 = [4,1,2], nums2 = [1,3,4,2].<br />Output: [-1,3,-1]<br />Explanation:<br />&nbsp; &nbsp; For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.<br />&nbsp; &nbsp; For number 1 in the first array, the next greater number for it in the second array is 3.<br />&nbsp; &nbsp; For number 2 in the first array, there is no next greater number for it in the second array, so output -1.<br />Example 2:<br />Input: nums1 = [2,4], nums2 = [1,2,3,4].<br />Output: [3,-1]<br />Explanation:<br />&nbsp; &nbsp; For number 2 in the first array, the next greater number for it in the second array is 3.<br />&nbsp; &nbsp; For number 4 in the first array, there is no next greater number for it in the second array, so output -1.<br />Note:<br />All elements in nums1 and nums2 are unique.<br />The length of both nums1 and nums2 would not exceed 1000.</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int[] NextGreaterElement(int[] nums1, int[] nums2) {\n        var map = new Dictionary&lt;int,int&gt;();\n        var stack = new Stack&lt;int&gt;();\n        for(int i=0;i&lt;nums2.Length;i++){\n            while(stack.Count()&gt;0 &amp;&amp; stack.Peek()&lt;nums2[i]){\n                map.Add(stack.Pop(),nums2[i]);\n            }\n            stack.Push(nums2[i]);\n        }\n        \n        var list = new List&lt;int&gt;();\n        for(int i=0;i&lt;nums1.Length;i++){\n            if(map.ContainsKey(nums1[i])){\n                list.Add(map[nums1[i]]);\n            }\n            else{\n                list.Add(-1);\n            }\n        }\n        \n        return list.ToArray();\n    }\n}</code></pre>\n<p>Time Complexity: O(n)</p>\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/77322c88-6360-41ec-8f11-72888f8f5b19.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"next-greater-element-i-stacks-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"stack","slug":"stack"}],"recommendations":[{"id":1677,"title":"Find the Duplicate Number - Array - Medium - LeetCode","imageUrl":"icon_85d20211-e54a-42fd-9300-e83bc02b7ffe.jpg","dateCreated":"2020-11-18T13:09:40.526Z","dateModified":"2020-11-18T13:09:46.723Z","contributedBy":"sumitc91","content":"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one duplicate number in nums, return this duplicate number.\nFollow-ups:\nHow can we prove that at least one duplicate number must exist in nums?&nbsp;<b","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/85d20211-e54a-42fd-9300-e83bc02b7ffe.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"find-the-duplicate-number-array-medium-leetcode","total":0},{"id":1652,"title":"Minimum Path Sum - Array - Medium - LeetCode","imageUrl":"icon_d9f5ff7a-791f-41b0-89b0-f12760706d99.jpg","dateCreated":"2020-10-31T09:04:08.041Z","dateModified":"2020-10-31T09:04:16.725Z","contributedBy":"sumitc91","content":"Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample:\nInput:<br />[<br />&nbsp; [1,3,1],<br />&nbsp; [1,","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/d9f5ff7a-791f-41b0-89b0-f12760706d99.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"minimum-path-sum-array-medium-leetcode","total":0},{"id":1651,"title":"Unique Paths II - Array - Medium - LeetCode","imageUrl":"icon_ca5278d5-6ee2-45fc-9c8e-7f12ff9f0357.jpg","dateCreated":"2020-10-31T08:51:34.949Z","dateModified":"2020-10-31T08:51:41.7Z","contributedBy":"sumitc91","content":"A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\nNow consider i","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/ca5278d5-6ee2-45fc-9c8e-7f12ff9f0357.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"unique-paths-ii-array-medium-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}