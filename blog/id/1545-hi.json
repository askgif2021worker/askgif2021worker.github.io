{"id":1545,"title":"Last Stone Weight - Heap - Easy - LeetCode","imageUrl":"icon_a5fa374c-d4ce-4495-8c28-cbdcb7b9822a.jpg","dateCreated":"2020-10-04T17:15:38.203Z","dateModified":"2020-10-04T17:15:52.351Z","contributedBy":"sumitc91","content":"<p>We have a collection of stones, each stone has a positive integer weight.</p>\n<p>Each turn, we choose the two heaviest stones and smash them together. &nbsp;Suppose the stones have weights x and y with x &lt;= y. &nbsp;The result of this smash is:</p>\n<p>If x == y, both stones are totally destroyed;<br />If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.<br />At the end, there is at most 1 stone left. &nbsp;Return the weight of this stone (or 0 if there are no stones left.)</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: [2,7,4,1,8,1]<br />Output: 1<br />Explanation:&nbsp;<br />We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,<br />we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,<br />we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,<br />we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone.<br />&nbsp;</p>\n<p>Note:</p>\n<p>1 &lt;= stones.length &lt;= 30<br />1 &lt;= stones[i] &lt;= 1000</p>\n<p>&nbsp;</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    int[] heap;\n    int index = 1;\n    public int LastStoneWeight(int[] stones)\n    {\n        if(stones.Length==0){\n            return 0;\n        }\n        \n        if(stones.Length==1){\n            return stones[0];\n        }\n        \n        heap = new int[stones.Length + 1];\n        for (int i = 0; i &lt; stones.Length; i++)\n        {\n            Insert(stones[i]);\n        }\n\n        int diff = 0;\n        while (index-1 &gt; 1)\n        {\n            int max1 = ExtractMax();\n            int max2 = ExtractMax();\n            diff = max1 - max2;\n            Insert(diff);\n        }\n\n        return diff;\n    }\n\n    private int ExtractMax()\n    {\n        int max = heap[1];\n        index--;\n        heap[1] = heap[index];            \n        HeapifyDown(1);\n        return max;\n    }\n\n    private void HeapifyDown(int idx)\n    {\n        int left = 2 * idx;\n        int right = 2 * idx + 1;\n        if (left &gt; index)\n        {\n            return;\n        }\n        if (right &gt; index)\n        {\n            if (heap[left] &gt; heap[idx])\n            {\n                int temp = heap[left];\n                heap[left] = heap[idx];\n                heap[idx] = temp;\n                HeapifyDown(left);                    \n            }\n            return;\n        }\n\n        if (heap[left] &gt; heap[right] &amp;&amp; heap[left] &gt; heap[idx])\n        {\n            int temp = heap[left];\n            heap[left] = heap[idx];\n            heap[idx] = temp;\n            HeapifyDown(left);\n        }\n        else if (heap[right] &gt; heap[idx])\n        {\n            int temp = heap[right];\n            heap[right] = heap[idx];\n            heap[idx] = temp;\n            HeapifyDown(right);\n        }\n    }\n\n    private void Insert(int val)\n    {\n        heap[index] = val;\n        HeapifyUp(index);\n        index++;\n    }\n\n    private void HeapifyUp(int idx)\n    {\n        int parent = idx / 2;\n        if (parent &lt; 1)\n        {\n            return;\n        }\n\n        if (heap[parent] &lt; heap[idx])\n        {\n            int temp = heap[parent];\n            heap[parent] = heap[idx];\n            heap[idx] = temp;\n\n            HeapifyUp(parent);\n        }\n    }\n}</code></pre>\n<p>Time Complexity: O(nlogn)</p>\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a5fa374c-d4ce-4495-8c28-cbdcb7b9822a.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"last-stone-weight-heap-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"Heap-Data-Structure","slug":"heap-data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"max-heap","slug":"max-heap"}],"recommendations":[{"id":1728,"title":"Minimum Changes To Make Alternating Binary String - String - Easy - LeetCode","imageUrl":"icon_85c66994-0911-4abb-b06f-a20a0a11dcd4.jpg","dateCreated":"2021-03-31T07:22:03.012Z","dateModified":"2021-03-31T07:22:08.602Z","contributedBy":"sumitc91","content":"You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.\nThe string is called alternating if no two adjacent characters are equal. For example, the string \"010\" is alternating, while the string \"0100\" is not.","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/85c66994-0911-4abb-b06f-a20a0a11dcd4.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"minimum-changes-to-make-alternating-binary-string-string-easy-leetcode","total":0},{"id":1654,"title":"Search a 2D Matrix - Array - Medium - LeetCode","imageUrl":"icon_4ecd9aac-a00a-4a8f-ad7b-e7e4a75307ac.jpg","dateCreated":"2020-10-31T10:10:06.758Z","dateModified":"2020-10-31T10:10:15.329Z","contributedBy":"sumitc91","content":"Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\nIntegers in each row are sorted from left to right.<br />The first integer of each row is greater than the last integer of the previous row.<br />&nbsp;\nExample 1:</p","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/4ecd9aac-a00a-4a8f-ad7b-e7e4a75307ac.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"search-a-2d-matrix-array-medium-leetcode","total":0},{"id":1631,"title":"Largest Substring Between Two Equal Characters - Array - Easy - LeetCode","imageUrl":"icon_696afb81-fd63-43c4-a6e8-038e3152e83e.jpg","dateCreated":"2020-10-18T09:57:37.517Z","dateModified":"2020-10-18T09:57:48.765Z","contributedBy":"sumitc91","content":"Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.\n&nbsp;\nExample 1:\nInput: s = \"aa\"<br />","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/696afb81-fd63-43c4-a6e8-038e3152e83e.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"largest-substring-between-two-equal-characters-array-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}