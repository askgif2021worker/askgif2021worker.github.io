{"id":1549,"title":"Delete Columns to Make Sorted - Greedy - Easy - LeetCode","imageUrl":"icon_ee4c88d0-0997-42fb-be32-5870620b1e37.jpg","dateCreated":"2020-10-05T08:02:36.171Z","dateModified":"2020-10-05T08:02:46.675Z","contributedBy":"sumitc91","content":"<p>We are given an array A of N lowercase letter strings, all of the same length.</p>\n<p>Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.</p>\n<p>For example, if we have an array A = [\"abcdef\",\"uvwxyz\"] and deletion indices {0, 2, 3}, then the final array after deletions is [\"bef\", \"vyz\"], and the remaining columns of A are [\"b\",\"v\"], [\"e\",\"y\"], and [\"f\",\"z\"]. &nbsp;(Formally, the c-th column is [A[0][c], A[1][c], ..., A[A.length-1][c]]).</p>\n<p>Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order.</p>\n<p>Return the minimum possible value of D.length.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: A = [\"cba\",\"daf\",\"ghi\"]<br />Output: 1<br />Explanation:&nbsp;<br />After choosing D = {1}, each column [\"c\",\"d\",\"g\"] and [\"a\",\"f\",\"i\"] are in non-decreasing sorted order.<br />If we chose D = {}, then a column [\"b\",\"a\",\"h\"] would not be in non-decreasing sorted order.<br />Example 2:</p>\n<p>Input: A = [\"a\",\"b\"]<br />Output: 0<br />Explanation: D = {}<br />Example 3:</p>\n<p>Input: A = [\"zyx\",\"wvu\",\"tsr\"]<br />Output: 3<br />Explanation: D = {0, 1, 2}<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>1 &lt;= A.length &lt;= 100<br />1 &lt;= A[i].length &lt;= 1000</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int MinDeletionSize(string[] A) {\n        int count = 0;\n        for(int c=0;c&lt;A[0].Length;c++){\n            for(int r=1;r&lt;A.Length;r++){\n                if(A[r-1][c]&gt;A[r][c]){\n                    count++;\n                    break;\n                }\n            }\n        }\n        \n        return count;\n    }\n}</code></pre>\n<p>Time Complexity: O(m*n)</p>\n<p>Space Complexity: O(1)</p>\n<p>where m and n are the count of string and max length of string.</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/ee4c88d0-0997-42fb-be32-5870620b1e37.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"delete-columns-to-make-sorted-greedy-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"greedy","slug":"greedy"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1720,"title":"Number Of Rectangles That Can Form The Largest Square - Array - Easy - LeetCode","imageUrl":"icon_a3758d97-0c9c-4e59-860a-b2f31b1f95ab.jpg","dateCreated":"2021-01-18T12:11:37.997Z","dateModified":"2021-01-18T12:11:43.515Z","contributedBy":"sumitc91","content":"You are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of length li and width wi.\nYou can cut the ith rectangle to form a square with a side length of k if both k &lt;= li and k &lt;= wi. For example, if you have a rectangle [4,6], you can cut it to g","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a3758d97-0c9c-4e59-860a-b2f31b1f95ab.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"number-of-rectangles-that-can-form-the-largest-square-array-easy-leetcode","total":0},{"id":1673,"title":"Minimum Size Subarray Sum - Array - Medium - LeetCode","imageUrl":"icon_9cd5847f-8b41-455d-8ac3-9b66f2dcb47e.jpg","dateCreated":"2020-11-18T09:07:17.833Z","dateModified":"2020-11-18T09:07:23.659Z","contributedBy":"sumitc91","content":"Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum &ge; s. If there isn't one, return 0 instead.\nExample:&nbsp;\nInput: s = 7, nums = [2,3,1,2,4,3]<br />Output: 2<br />Explanation: the subarray [4,3] has t","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/9cd5847f-8b41-455d-8ac3-9b66f2dcb47e.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"minimum-size-subarray-sum-array-medium-leetcode","total":0},{"id":1660,"title":"Check Array Formation Through Concatenation - Array - Easy - LeetCode","imageUrl":"icon_85392267-2028-4c02-8f8a-96c1d2368591.jpg","dateCreated":"2020-11-03T06:50:35.06Z","dateModified":"2020-11-03T06:50:53.205Z","contributedBy":"sumitc91","content":"You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].\nRetur","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/85392267-2028-4c02-8f8a-96c1d2368591.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"check-array-formation-through-concatenation-array-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}