{"id":1550,"title":"Maximize Sum Of Array After K Negations - Greedy - Easy - LeetCode","imageUrl":"icon_75abc065-f2ab-4037-9471-74f097694550.jpg","dateCreated":"2020-10-05T09:20:37.677Z","dateModified":"2020-10-05T09:20:51.599Z","contributedBy":"sumitc91","content":"<p>Given an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total. &nbsp;(We may choose the same index i multiple times.)</p>\n<p>Return the largest possible sum of the array after modifying it in this way.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: A = [4,2,3], K = 1<br />Output: 5<br />Explanation: Choose indices (1,) and A becomes [4,-2,3].<br />Example 2:</p>\n<p>Input: A = [3,-1,0,2], K = 3<br />Output: 6<br />Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2].<br />Example 3:</p>\n<p>Input: A = [2,-3,-1,5,-4], K = 2<br />Output: 13<br />Explanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4].<br />&nbsp;</p>\n<p>Note:</p>\n<p>1 &lt;= A.length &lt;= 10000<br />1 &lt;= K &lt;= 10000<br />-100 &lt;= A[i] &lt;= 100</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    int[] heap;\n    int pos=1;\n    public int LargestSumAfterKNegations(int[] A, int K) {\n        heap = new int[A.Length+1];\n        for(int i=0;i&lt;A.Length;i++){\n            Insert(A[i]);\n        }\n        \n        for(int i=1;i&lt;=K;i++){\n            int min = ExtractMin();\n            Insert(-1*min);            \n        }\n        \n        int sum =0;\n        while(pos&gt;1){\n            sum+=ExtractMin();\n        }\n        \n        return sum;\n    }\n    \n    private int ExtractMin(){\n        int min = heap[1];\n        pos--;\n        heap[1]=heap[pos];\n        HeapifyDown(1);\n        return min;\n    }\n    \n    private void HeapifyDown(int index){\n        int left = 2*index;\n        int right = left +1;\n        if(left &gt; pos){\n            return;\n        }\n        if(right &gt; pos){\n            int temp = heap[left];\n            heap[left]=heap[index];\n            heap[index]=temp;\n            HeapifyDown(left);\n            return;\n        }\n        \n        if(heap[left]&lt;heap[right] &amp;&amp; heap[left]&lt;heap[index]){\n            int temp = heap[left];\n            heap[left]=heap[index];\n            heap[index]=temp;\n            HeapifyDown(left);\n        }\n        else if(heap[right]&lt;heap[index]){\n            int temp = heap[right];\n            heap[right]=heap[index];\n            heap[index]=temp;\n            HeapifyDown(right);\n        }\n    }\n    \n    private void Insert(int val){\n        heap[pos]=val;\n        HeapifyUp(pos);\n        pos++;\n    }\n    \n    private void HeapifyUp(int index){\n        int parent = index/2;\n        if(parent&lt;1){\n            return;\n        }\n        if(heap[parent]&gt;heap[index]){\n            int temp = heap[parent];\n            heap[parent]=heap[index];\n            heap[index]=temp;\n            HeapifyUp(parent);\n        }\n    }\n}</code></pre>\n<p>Time Complexity: O(nlogn)</p>\n<p>Space Complexity: O(logn)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/75abc065-f2ab-4037-9471-74f097694550.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"maximize-sum-of-array-after-k-negations-greedy-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"greedy","slug":"greedy"},{"name":"leetcode","slug":"leetcode"},{"name":"min-heap","slug":"min-heap"}],"recommendations":[{"id":1727,"title":"Check if Array Is Sorted and Rotated - Array - Easy - LeetCode","imageUrl":"icon_2110d383-81cb-448a-8e4f-3773ff37294d.jpg","dateCreated":"2021-03-31T05:53:14.382Z","dateModified":"2021-03-31T05:53:27.431Z","contributedBy":"sumitc91","content":"Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.\nThere may be duplicates in the original array.\nNote: An array A rotated by x positions results in an array B ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/2110d383-81cb-448a-8e4f-3773ff37294d.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"check-if-array-is-sorted-and-rotated-array-easy-leetcode","total":0},{"id":1721,"title":"Find the Highest Altitude - Array - Easy - LeetCode","imageUrl":"icon_0cd60e05-bb63-481c-ac68-c3417eabb1cb.jpg","dateCreated":"2021-01-26T09:15:18.731Z","dateModified":"2021-01-26T09:15:23.937Z","contributedBy":"sumitc91","content":"There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.\nYou are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for a","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/0cd60e05-bb63-481c-ac68-c3417eabb1cb.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"find-the-highest-altitude-array-easy-leetcode","total":0},{"id":1621,"title":"Swap Salary - Sql - Easy - LeetCode","imageUrl":"icon_d5dae622-be43-4a7d-a90e-4173c15f3195.jpg","dateCreated":"2020-10-17T06:35:01.639Z","dateModified":"2020-10-17T06:36:00.564Z","contributedBy":"sumitc91","content":"Given a table salary, such as the one below, that has m=male and f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update statement and no intermediate temp table.\nNote that you must write a single update statement, DO NOT write any sele","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/d5dae622-be43-4a7d-a90e-4173c15f3195.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"sql","slug":"sql"}],"slug":"swap-salary-sql-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}