{"id":1561,"title":"Number Complement - Bit Manipulation - Easy - LeetCode","imageUrl":"icon_b356a014-8311-4317-ac21-b43fa1f6ea7c.jpg","dateCreated":"2020-10-06T08:39:30.029Z","dateModified":"2020-10-06T08:39:39.785Z","contributedBy":"sumitc91","content":"<p>Given a positive integer num, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: num = 5<br />Output: 2<br />Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.<br />Example 2:</p>\n<p>Input: num = 1<br />Output: 0<br />Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>The given integer num is guaranteed to fit within the range of a 32-bit signed integer.<br />num &gt;= 1<br />You could assume no leading zero bit in the integer&rsquo;s binary representation.<br />This question is the same as 1009: <a href=\"https://leetcode.com/problems/complement-of-base-10-integer/\">https://leetcode.com/problems/complement-of-base-10-integer/</a></p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int FindComplement(int num) {\n        int sum = 0;\n        for(int i=0;i&lt;32 &amp;&amp; num != 0;i++){            \n            sum+=(int)Math.Pow(2,i)*((num&amp;1)^1);\n            num=num&gt;&gt;1;\n        }\n        return sum;\n    }\n}</code></pre>\n<p>Time Complexity: O(logn) which corresponds to the number of bits in the number.</p>\n<p>Space Complexity: O(1)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/b356a014-8311-4317-ac21-b43fa1f6ea7c.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"number-complement-bit-manipulation-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"bit-manipulation","slug":"bit-manipulation"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1672,"title":"Rotate Array - Array - Medium - LeetCode","imageUrl":"icon_37fb5cd6-ca4d-4282-9a29-a03ba8523202.jpg","dateCreated":"2020-11-18T07:21:27.3Z","dateModified":"2020-11-18T07:21:33.323Z","contributedBy":"sumitc91","content":"Given an array, rotate the array to the right by k steps, where k is non-negative.\nFollow up:\nTry to come up as many solutions as you can, there are at least 3 different ways to solve this problem.<br />Could you do it in-place with O(1) extra space?<br />&nbsp;\nExample 1:</p","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/37fb5cd6-ca4d-4282-9a29-a03ba8523202.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"rotate-array-array-medium-leetcode","total":0},{"id":1662,"title":"Search in Rotated Sorted Array II - Array - Medium - LeetCode","imageUrl":"icon_f90b9cf1-f98d-483f-9cb6-f0ccc23c9c57.jpg","dateCreated":"2020-11-10T06:51:27.488Z","dateModified":"2020-11-10T06:51:33.729Z","contributedBy":"sumitc91","content":"Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).\nYou are given a target value to search. If found in the array return true, otherwise return false.\nExample 1:\nInput: num","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/f90b9cf1-f98d-483f-9cb6-f0ccc23c9c57.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"search-in-rotated-sorted-array-ii-array-medium-leetcode","total":0},{"id":1603,"title":"Moving Stones Until Consecutive - Brainteaser - Easy - LeetCode","imageUrl":"icon_e620d162-e256-4aff-b3fa-67c0a4795dd6.jpg","dateCreated":"2020-10-16T05:13:52.149Z","dateModified":"2020-10-16T05:14:17.79Z","contributedBy":"sumitc91","content":"Three stones are on a number line at positions a, b, and c.\nEach turn, you pick up a stone at an endpoint (ie., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints. &nbsp;Formally, let's say the stones are currently at positions x, y,","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/e620d162-e256-4aff-b3fa-67c0a4795dd6.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"brain-teaser","slug":"brain-teaser"},{"name":"brainteaser","slug":"brainteaser"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"moving-stones-until-consecutive-brainteaser-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}