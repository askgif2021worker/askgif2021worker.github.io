{"id":1578,"title":"Binary Tree Tilt - Tree - Easy - LeetCode","imageUrl":"icon_55531ca6-6b80-4dbf-96b1-e3333145d1af.jpg","dateCreated":"2020-10-07T08:27:51.42Z","dateModified":"2020-10-07T08:28:04.355Z","contributedBy":"sumitc91","content":"<p>Given a binary tree, return the tilt of the whole tree.</p>\n<p>The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p>\n<p>The tilt of the whole tree is defined as the sum of all nodes' tilt.</p>\n<p>Example:<br />Input:&nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1<br />&nbsp; &nbsp; &nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; 3<br />Output: 1<br />Explanation:&nbsp;<br />Tilt of node 2 : 0<br />Tilt of node 3 : 0<br />Tilt of node 1 : |2-3| = 1<br />Tilt of binary tree : 0 + 0 + 1 = 1<br />Note:</p>\n<p>The sum of node values in any subtree won't exceed the range of 32-bit integer.<br />All the tilt values won't exceed the range of 32-bit integer.</p>\n<p>I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:</p>\n<p>Input :<br />4<br />/ \\<br />2 9<br />/ \\ \\<br />3 5 7<br />Output : 15<br />Explanation:<br />Tilt of node 3 : 0<br />Tilt of node 5 : 0<br />Tilt of node 7 : 0<br />Tilt of node 2 : |3-5| = 2<br />Tilt of node 9 : |0-7| = 7<br />Tilt of node 4 : |(3+5+2)-(9+7)| = 6<br />Tilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15</p>\n<p>&nbsp;</p>\n<pre class=\"language-csharp\"><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    int sum = 0;\n    public int FindTilt(TreeNode root) {\n        if(root==null){\n            return 0;\n        }\n        if(root.left ==null &amp;&amp; root.right == null){\n            return root.val;\n        }\n        \n        int leftSum = TotalSum(root.left);\n        int rightSum = TotalSum(root.right);\n        sum += Math.Abs(leftSum-rightSum);\n        FindTilt(root.left);\n        FindTilt(root.right);\n        return sum;\n    }\n    \n    private int TotalSum(TreeNode root){\n        if(root==null){\n            return 0;\n        }\n        \n        if(root.left == null &amp;&amp; root.right==null){\n            return root.val;\n        }\n        \n        int leftSum = TotalSum(root.left);\n        int rightSum = TotalSum(root.right);\n        return root.val+leftSum+rightSum;\n    }\n}</code></pre>\n<p>Time Complexity: O(n)</p>\n<p>Space Complexity: O(1)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/55531ca6-6b80-4dbf-96b1-e3333145d1af.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"binary-tree-tilt-tree-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"recommendations":[{"id":1674,"title":"Combination Sum III - Array - Medium - LeetCode","imageUrl":"icon_becf4b84-69f9-4582-a8d7-d32b8422353a.jpg","dateCreated":"2020-11-18T11:38:07.946Z","dateModified":"2020-11-18T11:38:14.249Z","contributedBy":"sumitc91","content":"Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\nOnly numbers 1 through 9 are used.<br />Each number is used at most once.<br />Return a list of all possible valid combinations. The list must not contain the same combination twice, and ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/becf4b84-69f9-4582-a8d7-d32b8422353a.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"combination-sum-iii-array-medium-leetcode","total":0},{"id":1672,"title":"Rotate Array - Array - Medium - LeetCode","imageUrl":"icon_37fb5cd6-ca4d-4282-9a29-a03ba8523202.jpg","dateCreated":"2020-11-18T07:21:27.3Z","dateModified":"2020-11-18T07:21:33.323Z","contributedBy":"sumitc91","content":"Given an array, rotate the array to the right by k steps, where k is non-negative.\nFollow up:\nTry to come up as many solutions as you can, there are at least 3 different ways to solve this problem.<br />Could you do it in-place with O(1) extra space?<br />&nbsp;\nExample 1:</p","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/37fb5cd6-ca4d-4282-9a29-a03ba8523202.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"rotate-array-array-medium-leetcode","total":0},{"id":1647,"title":"Slowest Key - Array - Easy - LeetCode","imageUrl":"icon_836f29a5-8a43-4160-b64a-fbf8416788bd.jpg","dateCreated":"2020-10-31T03:14:43.566Z","dateModified":"2020-10-31T03:14:48.648Z","contributedBy":"sumitc91","content":"A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.\nYou are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith k","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/836f29a5-8a43-4160-b64a-fbf8416788bd.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"slowest-key-array-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}