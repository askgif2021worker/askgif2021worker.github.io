{"id":1582,"title":"Construct String from Binary Tree - Tree - Easy - LeetCode","imageUrl":"icon_e8b61cbd-801c-4ac5-8279-5792c4fd649e.jpg","dateCreated":"2020-10-07T09:12:25.025Z","dateModified":"2020-10-07T09:12:41.839Z","contributedBy":"sumitc91","content":"<p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.</p>\n<p>The null node needs to be represented by empty parenthesis pair \"()\". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree.</p>\n<p>Example 1:<br />Input: Binary tree: [1,2,3,4]<br />&nbsp; &nbsp; &nbsp; &nbsp;1<br />&nbsp; &nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; &nbsp; 2 &nbsp; &nbsp; 3<br />&nbsp; &nbsp;/ &nbsp; &nbsp;<br />&nbsp; 4 &nbsp; &nbsp;&nbsp;</p>\n<p>Output: \"1(2(4))(3)\"</p>\n<p>Explanation: Originallay it needs to be \"1(2(4)())(3()())\",&nbsp;<br />but you need to omit all the unnecessary empty parenthesis pairs.&nbsp;<br />And it will be \"1(2(4))(3)\".<br />Example 2:<br />Input: Binary tree: [1,2,3,null,4]<br />&nbsp; &nbsp; &nbsp; &nbsp;1<br />&nbsp; &nbsp; &nbsp;/ &nbsp; \\<br />&nbsp; &nbsp; 2 &nbsp; &nbsp; 3<br />&nbsp; &nbsp; &nbsp;\\ &nbsp;<br />&nbsp; &nbsp; &nbsp; 4&nbsp;</p>\n<p>Output: \"1(2()(4))(3)\"</p>\n<p>Explanation: Almost the same as the first example,&nbsp;<br />except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.</p>\n<pre class=\"language-csharp\"><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public string Tree2str(TreeNode t) {\n        if(t==null){\n            return string.Empty;\n        }\n        var sb = new StringBuilder();\n        sb.Append(t.val);        \n        \n        if(t.left!=null){\n            sb.Append(\"(\");\n            sb.Append(Tree2str(t.left));\n            sb.Append(\")\");\n        }\n        \n        if(t.right!=null){\n            if(t.left==null){\n                sb.Append(\"()\");\n            }\n            sb.Append(\"(\");\n            sb.Append(Tree2str(t.right));\n            sb.Append(\")\");\n        }\n        return sb.ToString();\n    }\n}</code></pre>\n<p>Time Complexity: O(n)</p>\n<p>Space Complexity: O(1)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/e8b61cbd-801c-4ac5-8279-5792c4fd649e.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"construct-string-from-binary-tree-tree-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"recommendations":[{"id":1706,"title":"Check If Two String Arrays are Equivalent - String - Easy - LeetCode","imageUrl":"icon_38460c51-4f08-46d0-82ef-1f2263c60127.jpg","dateCreated":"2020-11-24T13:04:46.01Z","dateModified":"2020-11-24T13:04:50.906Z","contributedBy":"sumitc91","content":"Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.\n&nbsp;\nExample 1:\nInput: word1 = [\"ab\", \"c\"], word2 ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/38460c51-4f08-46d0-82ef-1f2263c60127.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"check-if-two-string-arrays-are-equivalent-string-easy-leetcode","total":0},{"id":1647,"title":"Slowest Key - Array - Easy - LeetCode","imageUrl":"icon_836f29a5-8a43-4160-b64a-fbf8416788bd.jpg","dateCreated":"2020-10-31T03:14:43.566Z","dateModified":"2020-10-31T03:14:48.648Z","contributedBy":"sumitc91","content":"A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.\nYou are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith k","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/836f29a5-8a43-4160-b64a-fbf8416788bd.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"slowest-key-array-easy-leetcode","total":0},{"id":1593,"title":"Range Sum of BST - Tree - Easy - LeetCode","imageUrl":"icon_2d446765-9ada-4072-93c3-eedfb56f7794.jpg","dateCreated":"2020-10-09T08:49:41.585Z","dateModified":"2020-10-09T08:49:55.954Z","contributedBy":"sumitc91","content":"Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive).\nThe binary search tree is guaranteed to have unique values.\n&nbsp;\nExample 1:\nInput: root = [10,5,15,3,7,null,18], L = 7, R = 15<br />Output: 32<b","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/2d446765-9ada-4072-93c3-eedfb56f7794.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"range-sum-of-bst-tree-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}