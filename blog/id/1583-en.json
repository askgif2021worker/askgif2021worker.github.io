{"id":1583,"title":"Merge Two Binary Trees - Tree - Easy - LeetCode","imageUrl":"icon_20c35011-6cff-4cac-b2eb-2fe805fd696e.jpg","dateCreated":"2020-10-08T03:35:36.258Z","dateModified":"2020-10-08T03:35:54.193Z","contributedBy":"sumitc91","content":"<p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p>\n<p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>\n<p>Example 1:</p>\n<p>Input:&nbsp;<br />&nbsp; &nbsp; Tree 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Tree 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/ \\ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / \\ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; 3 &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp;/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \\ &nbsp; \\ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; 5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; 7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />Output:&nbsp;<br />Merged tree:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3<br />&nbsp; &nbsp; &nbsp; &nbsp; / \\<br />&nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; 5<br />&nbsp; &nbsp; &nbsp; / \\ &nbsp; \\&nbsp;<br />&nbsp; &nbsp; &nbsp;5 &nbsp; 4 &nbsp; 7<br />&nbsp;</p>\n<p>Note: The merging process must start from the root nodes of both trees.</p>\n<pre class=\"language-csharp\"><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode MergeTrees(TreeNode t1, TreeNode t2) {\n        if(t1==null &amp;&amp; t2==null){\n            return null;\n        }\n        \n        TreeNode root = new TreeNode();\n        if(t1 != null){\n            root.val += t1.val;\n        }   \n        \n        if(t2 != null){\n            root.val += t2.val;\n        }\n                \n        root.left = MergeTrees(t1==null?null:t1.left,t2==null?null:t2.left);\n        root.right = MergeTrees(t1==null?null:t1.right,t2==null?null:t2.right);\n        return root;\n    }\n}</code></pre>\n<p>Time Complexity: O(m+n)</p>\n<p>Space Complexity: O(m+n)</p>\n<p>Where m and n are the nodes of tree t1 and tree t2.</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/20c35011-6cff-4cac-b2eb-2fe805fd696e.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"merge-two-binary-trees-tree-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"recommendations":[{"id":1709,"title":"Goal Parser Interpretation - String - Easy - LeetCode","imageUrl":"icon_1a301e38-c33f-42ee-b91b-84f1471554f8.jpg","dateCreated":"2020-12-07T04:02:11.892Z","dateModified":"2020-12-07T04:02:17.242Z","contributedBy":"sumitc91","content":"You own a Goal Parser that can interpret a string command. The command consists of an alphabet of \"G\", \"()\" and/or \"(al)\" in some order. The Goal Parser will interpret \"G\" as the string \"G\", \"()\" as the string \"o\", and \"(al)\" as the string \"al\". The interpreted strings are then concatenated in th","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/1a301e38-c33f-42ee-b91b-84f1471554f8.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"goal-parser-interpretation-string-easy-leetcode","total":0},{"id":1660,"title":"Check Array Formation Through Concatenation - Array - Easy - LeetCode","imageUrl":"icon_85392267-2028-4c02-8f8a-96c1d2368591.jpg","dateCreated":"2020-11-03T06:50:35.06Z","dateModified":"2020-11-03T06:50:53.205Z","contributedBy":"sumitc91","content":"You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].\nRetur","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/85392267-2028-4c02-8f8a-96c1d2368591.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"check-array-formation-through-concatenation-array-easy-leetcode","total":0},{"id":1633,"title":"3Sum - Array - Medium - LeetCode","imageUrl":"icon_b05855a6-ac78-4434-a041-4682444c76bc.jpg","dateCreated":"2020-10-19T04:39:11.508Z","dateModified":"2020-10-19T04:39:21.598Z","contributedBy":"sumitc91","content":"Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\nNotice that the solution set must not contain duplicate triplets.\n&nbsp;\nExample 1:\nInput: nums = [-1,0,1,2","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/b05855a6-ac78-4434-a041-4682444c76bc.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"3sum-array-medium-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}