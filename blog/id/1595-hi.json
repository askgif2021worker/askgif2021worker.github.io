{"id":1595,"title":"Cousins in Binary Tree - Tree - Easy - LeetCode","imageUrl":"icon_249b4ce9-a2e8-4b2a-a369-264d0c802503.jpg","dateCreated":"2020-10-09T09:24:10.362Z","dateModified":"2020-10-09T09:24:23.315Z","contributedBy":"sumitc91","content":"<p>In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.</p>\n<p>Two nodes of a binary tree are cousins if they have the same depth, but have different parents.</p>\n<p>We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree.</p>\n<p>Return true if and only if the nodes corresponding to the values x and y are cousins.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p><br />Input: root = [1,2,3,4], x = 4, y = 3<br />Output: false<br />Example 2:</p>\n<p><br />Input: root = [1,2,3,null,4,null,5], x = 5, y = 4<br />Output: true<br />Example 3:</p>\n<p>&nbsp;</p>\n<p>Input: root = [1,2,3,null,4], x = 2, y = 3<br />Output: false<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>The number of nodes in the tree will be between 2 and 100.<br />Each node has a unique integer value from 1 to 100.</p>\n<pre class=\"language-csharp\"><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsCousins(TreeNode root, int x, int y) {\n        if(root == null){\n            return false;\n        }\n        \n        var queue = new Queue&lt;TreeNode&gt;();\n        queue.Enqueue(root);\n        while(queue.Count()&gt;0){\n            int count = queue.Count();\n            bool foundx = false;\n            bool foundy = false;\n            while(count--&gt;0){\n                var node = queue.Dequeue();\n                if(node.val==x){\n                    foundx=true;\n                }\n                if(node.val==y){\n                    foundy=true;\n                }         \n                \n                if(node.left != null &amp;&amp; node.right != null){\n                    if(node.left.val ==x &amp;&amp; node.right.val == y){\n                        return false;\n                    }\n                    if(node.right.val==x &amp;&amp; node.left.val==y){\n                        return false;\n                    }\n                }\n                \n                if(node.left != null){\n                    queue.Enqueue(node.left);\n                }\n                if(node.right != null){\n                    queue.Enqueue(node.right);\n                }\n                            \n            }\n            if(foundx &amp;&amp; foundy)\n            {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}</code></pre>\n<p>Time Complexity: O(n)</p>\n<p>Space Complexity: O(height)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/249b4ce9-a2e8-4b2a-a369-264d0c802503.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"cousins-in-binary-tree-tree-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"recommendations":[{"id":1716,"title":"Maximum Units on a Truck - Array - Easy - LeetCode","imageUrl":"icon_3aedf9be-e325-4d16-b5ad-e180a12291dc.jpg","dateCreated":"2021-01-08T09:45:52.965Z","dateModified":"2021-01-08T09:46:00.078Z","contributedBy":"sumitc91","content":"You are assigned to put some amount of boxes onto one truck. You are given a 2D array boxTypes, where boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]:\nnumberOfBoxesi is the number of boxes of type i.<br />numberOfUnitsPerBoxi is the number of units in each box of the type i.<br />You ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/3aedf9be-e325-4d16-b5ad-e180a12291dc.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"maximum-units-on-a-truck-array-easy-leetcode","total":0},{"id":1660,"title":"Check Array Formation Through Concatenation - Array - Easy - LeetCode","imageUrl":"icon_85392267-2028-4c02-8f8a-96c1d2368591.jpg","dateCreated":"2020-11-03T06:50:35.06Z","dateModified":"2020-11-03T06:50:53.205Z","contributedBy":"sumitc91","content":"You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].\nRetur","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/85392267-2028-4c02-8f8a-96c1d2368591.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"check-array-formation-through-concatenation-array-easy-leetcode","total":0},{"id":1644,"title":"Spiral Matrix - Array - Medium - LeetCode","imageUrl":"icon_37d1b470-7389-4e05-97b1-d92ce68eb1ba.jpg","dateCreated":"2020-10-27T07:19:38.491Z","dateModified":"2020-10-27T07:19:48.756Z","contributedBy":"sumitc91","content":"Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\nExample 1:\nInput:<br />[<br />&nbsp;[ 1, 2, 3 ],<br />&nbsp;[ 4, 5, 6 ],<br />&nbsp;[ 7, 8, 9 ]<br />]<br />Output: [1,2,3,6,9,8,7,4,5]<br />Example 2:\nInput:<br />[<br />","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/37d1b470-7389-4e05-97b1-d92ce68eb1ba.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"spiral-matrix-array-medium-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}