{"id":1598,"title":"Find the Town Judge - Tree - Easy - LeetCode","imageUrl":"icon_2f8d0898-e59c-49cd-b25f-5234ed605d94.jpg","dateCreated":"2020-10-14T09:05:56.984Z","dateModified":"2020-10-14T09:06:09.069Z","contributedBy":"sumitc91","content":"<p>In a town, there are N people labelled from 1 to N. &nbsp;There is a rumor that one of these people is secretly the town judge.</p>\n<p>If the town judge exists, then:</p>\n<p>The town judge trusts nobody.<br />Everybody (except for the town judge) trusts the town judge.<br />There is exactly one person that satisfies properties 1 and 2.<br />You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.</p>\n<p>If the town judge exists and can be identified, return the label of the town judge. &nbsp;Otherwise, return -1.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: N = 2, trust = [[1,2]]<br />Output: 2<br />Example 2:</p>\n<p>Input: N = 3, trust = [[1,3],[2,3]]<br />Output: 3<br />Example 3:</p>\n<p>Input: N = 3, trust = [[1,3],[2,3],[3,1]]<br />Output: -1<br />Example 4:</p>\n<p>Input: N = 3, trust = [[1,2],[2,3]]<br />Output: -1<br />Example 5:</p>\n<p>Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]<br />Output: 3<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>1 &lt;= N &lt;= 1000<br />0 &lt;= trust.length &lt;= 10^4<br />trust[i].length == 2<br />trust[i] are all different<br />trust[i][0] != trust[i][1]<br />1 &lt;= trust[i][0], trust[i][1] &lt;= N</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    Dictionary&lt;int,List&lt;int&gt;&gt; graph = new Dictionary&lt;int,List&lt;int&gt;&gt;();\n    HashSet&lt;int&gt; visited = new HashSet&lt;int&gt;();\n    Dictionary&lt;int,int&gt; inVertex = new Dictionary&lt;int,int&gt;();\n    Dictionary&lt;int,int&gt; outVertex = new Dictionary&lt;int,int&gt;();\n    private void AddVertex(int v){\n        graph.Add(v, new List&lt;int&gt;());    \n    }\n    \n    private void AddEdge(int source, int destination){\n        var edges =graph[source];\n        edges.Add(destination);\n        graph[source]=edges;\n        \n        if(inVertex.ContainsKey(destination)){\n            inVertex[destination]++;\n        }\n        else{\n            inVertex.Add(destination,1);\n        }\n        \n        if(outVertex.ContainsKey(source)){\n            outVertex[source]++;\n        }\n        else{\n            outVertex.Add(source,1);\n        }\n    }\n    \n    public int FindJudge(int N, int[][] trust) {\n        \n        if(trust.Count()==0 &amp;&amp; N==1){\n            return 1;\n        }\n        \n        for(int i=1;i&lt;=N;i++){\n            AddVertex(i);\n        }\n        \n        for(int i=0;i&lt;trust.Length;i++){\n            AddEdge(trust[i][0],trust[i][1]);\n        }                \n        \n        foreach(var item in inVertex){\n            if(item.Value == N-1 &amp;&amp; !outVertex.ContainsKey(item.Key)){\n                return item.Key;\n            }\n        }\n        \n        return -1;\n    }\n    \n}</code></pre>\n<p>Time Complexity: O(V*E)</p>\n<p>Space Complexity: O(V)</p>\n<p>Where V is the number of Vertices and E is the number of Edges</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/2f8d0898-e59c-49cd-b25f-5234ed605d94.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"find-the-town-judge-tree-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"graph","slug":"graph"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1666,"title":"Construct Binary Tree from Preorder and Inorder Traversal - Array - Medium - LeetCode","imageUrl":"icon_af4cfea8-d43c-4a5f-aded-bc8e7ebfe296.jpg","dateCreated":"2020-11-17T10:00:03.216Z","dateModified":"2020-11-17T10:00:07.655Z","contributedBy":"sumitc91","content":"Given preorder and inorder traversal of a tree, construct the binary tree.\nNote:<br />You may assume that duplicates do not exist in the tree.\nFor example, given\npreorder = [3,9,20,15,7]<br />inorder = [9,3,15,20,7]<br />Return the following binary tree:\n&nbsp; &nbsp; ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/af4cfea8-d43c-4a5f-aded-bc8e7ebfe296.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"construct-binary-tree-from-preorder-and-inorder-traversal-array-medium-leetcode","total":0},{"id":1635,"title":"New Year Chaos - Array - Medium - HackerRank","imageUrl":"icon_53eb9e67-4065-4a48-af84-1ab48ec4ee5e.jpg","dateCreated":"2020-10-24T07:14:47.121Z","dateModified":"2020-10-24T07:15:13.568Z","contributedBy":"sumitc91","content":"It's New Year's Day and everyone's in line for the Wonderland rollercoaster ride! There are a number of people queued up, and each person wears a sticker indicating their initial position in the queue. Initial positions increment by &nbsp;from &nbsp;at the front of the line to &nbsp;at the back.<","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/53eb9e67-4065-4a48-af84-1ab48ec4ee5e.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"hackerrank","slug":"hackerrank"},{"name":"मध्यम","slug":"medium"}],"slug":"new-year-chaos-array-medium-hackerrank","total":0},{"id":1593,"title":"Range Sum of BST - Tree - Easy - LeetCode","imageUrl":"icon_2d446765-9ada-4072-93c3-eedfb56f7794.jpg","dateCreated":"2020-10-09T08:49:41.585Z","dateModified":"2020-10-09T08:49:55.954Z","contributedBy":"sumitc91","content":"Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive).\nThe binary search tree is guaranteed to have unique values.\n&nbsp;\nExample 1:\nInput: root = [10,5,15,3,7,null,18], L = 7, R = 15<br />Output: 32<b","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/2d446765-9ada-4072-93c3-eedfb56f7794.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"range-sum-of-bst-tree-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}