{"id":1599,"title":"Flower Planting With No Adjacent - Graph - Easy - LeetCode","imageUrl":"icon_db7a0ad4-994c-4a3a-a3c6-63035a00d2da.jpg","dateCreated":"2020-10-15T05:15:37.382Z","dateModified":"2020-10-15T05:15:47.948Z","contributedBy":"sumitc91","content":"<p>You have n gardens, labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes the existence of a bidirectional path from garden xi to garden yi. In each garden, you want to plant one of 4 types of flowers.</p>\n<p>There is no garden that has more than three paths coming into or leaving it.</p>\n<p>Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.</p>\n<p>Return any such a choice as an array answer, where answer[i] is the type of flower planted in the (i+1)th garden. &nbsp;The flower types are denoted 1, 2, 3, or 4. &nbsp;It is guaranteed an answer exists.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: n = 3, paths = [[1,2],[2,3],[3,1]]<br />Output: [1,2,3]<br />Example 2:</p>\n<p>Input: n = 4, paths = [[1,2],[3,4]]<br />Output: [1,2,1,2]<br />Example 3:</p>\n<p>Input: n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]<br />Output: [1,2,3,4]<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>1 &lt;= n &lt;= 104<br />0 &lt;= paths.length &lt;= 2 * 104<br />paths[i].length == 2<br />1 &lt;= xi, yi &lt;= n<br />xi != yi<br />No garden has four or more paths coming into or leaving it.</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    Dictionary&lt;int,List&lt;int&gt;&gt; graph = new Dictionary&lt;int,List&lt;int&gt;&gt;();\n    HashSet&lt;int&gt; visited = new HashSet&lt;int&gt;();    \n    private void AddVertex(int v){\n        graph.Add(v,new List&lt;int&gt;());\n    }\n    \n    private void AddEdge(int s, int d){\n        var sEdges = graph[s];\n        var dEdges = graph[d];\n        \n        sEdges.Add(d);\n        dEdges.Add(s);\n        graph[s]=sEdges;\n        graph[d]=dEdges;\n        \n    }\n        \n    public int[] GardenNoAdj(int n, int[][] paths) {\n        for(int i=1;i&lt;=n;i++){\n            AddVertex(i);\n        }\n        \n        for(int i=0;i&lt;paths.Length;i++){\n            AddEdge(paths[i][0],paths[i][1]);\n        }\n        \n        var ans = new int[n];\n        \n        for(int i=1;i&lt;=n;i++){\n            var colors = new int[5];            \n            foreach(var item in graph[i]){                \n                colors[ans[item-1]]=1;\n            }\n            \n            for(int j=4;j&gt;=1;j--){\n                if(colors[j]!=1){\n                    ans[i-1]=j;\n                }\n            }\n        }\n        \n        \n        return ans;\n    }\n    \n}</code></pre>\n<p>t</p>\n<p>Time Complexity: O(V.E)</p>\n<p>Space Complexity: O(V)</p>\n<p>Where V and E are the vertices and Edges of graph.</p>\n<p>&nbsp;</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/db7a0ad4-994c-4a3a-a3c6-63035a00d2da.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"flower-planting-with-no-adjacent-graph-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"graph","slug":"graph"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1728,"title":"Minimum Changes To Make Alternating Binary String - String - Easy - LeetCode","imageUrl":"icon_85c66994-0911-4abb-b06f-a20a0a11dcd4.jpg","dateCreated":"2021-03-31T07:22:03.012Z","dateModified":"2021-03-31T07:22:08.602Z","contributedBy":"sumitc91","content":"You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.\nThe string is called alternating if no two adjacent characters are equal. For example, the string \"010\" is alternating, while the string \"0100\" is not.","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/85c66994-0911-4abb-b06f-a20a0a11dcd4.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"minimum-changes-to-make-alternating-binary-string-string-easy-leetcode","total":0},{"id":1713,"title":"Reformat Phone Number - String - Easy - LeetCode","imageUrl":"icon_716c7816-48e6-45e6-840e-df068e41c6f6.jpg","dateCreated":"2021-01-05T04:21:52.889Z","dateModified":"2021-01-05T04:22:00.273Z","contributedBy":"sumitc91","content":"You are given a phone number as a string number. number consists of digits, spaces ' ', and/or dashes '-'.\nYou would like to reformat the phone number in a certain manner. Firstly, remove all spaces and dashes. Then, group the digits from left to right into blocks of length 3 until there a","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/716c7816-48e6-45e6-840e-df068e41c6f6.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"reformat-phone-number-string-easy-leetcode","total":0},{"id":1638,"title":"Next Permutation - Array - Medium - LeetCode","imageUrl":"icon_467cc3d1-390e-4bc6-a589-9f2b2a7b6f67.jpg","dateCreated":"2020-10-24T11:58:46.632Z","dateModified":"2020-10-24T11:59:00.039Z","contributedBy":"sumitc91","content":"Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\nThe replacement must be in place and use ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/467cc3d1-390e-4bc6-a589-9f2b2a7b6f67.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"next-permutation-array-medium-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}