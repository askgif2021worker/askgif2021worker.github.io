{"id":1603,"title":"Moving Stones Until Consecutive - Brainteaser - Easy - LeetCode","imageUrl":"icon_e620d162-e256-4aff-b3fa-67c0a4795dd6.jpg","dateCreated":"2020-10-16T05:13:52.149Z","dateModified":"2020-10-16T05:14:17.79Z","contributedBy":"sumitc91","content":"<p>Three stones are on a number line at positions a, b, and c.</p>\n<p>Each turn, you pick up a stone at an endpoint (ie., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints. &nbsp;Formally, let's say the stones are currently at positions x, y, z with x &lt; y &lt; z. &nbsp;You pick up the stone at either position x or position z, and move that stone to an integer position k, with x &lt; k &lt; z and k != y.</p>\n<p>The game ends when you cannot make any more moves, ie. the stones are in consecutive positions.</p>\n<p>When the game ends, what is the minimum and maximum number of moves that you could have made? &nbsp;Return the answer as an length 2 array: answer = [minimum_moves, maximum_moves]</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: a = 1, b = 2, c = 5<br />Output: [1,2]<br />Explanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.<br />Example 2:</p>\n<p>Input: a = 4, b = 3, c = 2<br />Output: [0,0]<br />Explanation: We cannot make any moves.<br />Example 3:</p>\n<p>Input: a = 3, b = 5, c = 1<br />Output: [1,2]<br />Explanation: Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.<br />&nbsp;</p>\n<p>Note:</p>\n<p>1 &lt;= a &lt;= 100<br />1 &lt;= b &lt;= 100<br />1 &lt;= c &lt;= 100<br />a != b, b != c, c != a</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int[] NumMovesStones(int a, int b, int c) {\n        var arr = new int[]{a,b,c};\n        var res = new int[2];\n        Array.Sort(arr);\n        if(arr[2]-arr[0]==2){\n            return res;\n        }\n        \n        res[0] = Math.Min(arr[1]-arr[0], arr[2]-arr[1])&lt;=2 ? 1: 2;\n        res[1] = arr[2]-arr[0]-2;\n        \n        return res;\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p>Time Complexity: O(nlogn)</p>\n<p>Space Complexity: O(n)</p>\n<p>Edge case 1: all three stones are next to each other (z - x == 2). Return {0, 0}.<br />Edge case 2: two stones are next to each other, or there is only one space in between. The minimum move is 1.</p>\n<p>Otherwise; minimum moves are 2, maximum - z - x - 2.</p>\n<p>So the position of the middle stone (y) only matters for the minimum moves.</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/e620d162-e256-4aff-b3fa-67c0a4795dd6.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"moving-stones-until-consecutive-brainteaser-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"brain-teaser","slug":"brain-teaser"},{"name":"brainteaser","slug":"brainteaser"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1668,"title":"Triangle - Array - Medium - LeetCode","imageUrl":"icon_40571e99-73c8-48d0-aa94-4a53cb2adbce.jpg","dateCreated":"2020-11-17T12:18:25.997Z","dateModified":"2020-11-17T12:18:30.576Z","contributedBy":"sumitc91","content":"Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\nFor example, given the following triangle\n[<br />&nbsp; &nbsp; &nbsp;[2],<br />&nbsp; &nbsp; [3,4],<br />&nbsp; &nbsp;[6,5,7],<br />&nbsp; [4,1,8,3]<br />]<br","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/40571e99-73c8-48d0-aa94-4a53cb2adbce.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"triangle-array-medium-leetcode","total":0},{"id":1621,"title":"Swap Salary - Sql - Easy - LeetCode","imageUrl":"icon_d5dae622-be43-4a7d-a90e-4173c15f3195.jpg","dateCreated":"2020-10-17T06:35:01.639Z","dateModified":"2020-10-17T06:36:00.564Z","contributedBy":"sumitc91","content":"Given a table salary, such as the one below, that has m=male and f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update statement and no intermediate temp table.\nNote that you must write a single update statement, DO NOT write any sele","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/d5dae622-be43-4a7d-a90e-4173c15f3195.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"sql","slug":"sql"}],"slug":"swap-salary-sql-easy-leetcode","total":0},{"id":1617,"title":"Relative Ranks - Array - Easy - LeetCode","imageUrl":"icon_999e367f-6673-49be-9d6a-411dd5e1e1e2.jpg","dateCreated":"2020-10-17T05:30:58.485Z","dateModified":"2020-10-17T05:31:07.765Z","contributedBy":"sumitc91","content":"Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".\nExample 1:<br />Input: [5, 4, 3, 2, 1]<br />Output: [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]<","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/999e367f-6673-49be-9d6a-411dd5e1e1e2.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"relative-ranks-array-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}