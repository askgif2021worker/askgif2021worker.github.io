{"id":1617,"title":"Relative Ranks - Array - Easy - LeetCode","imageUrl":"icon_999e367f-6673-49be-9d6a-411dd5e1e1e2.jpg","dateCreated":"2020-10-17T05:30:58.485Z","dateModified":"2020-10-17T05:31:07.765Z","contributedBy":"sumitc91","content":"<p>Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".</p>\n<p>Example 1:<br />Input: [5, 4, 3, 2, 1]<br />Output: [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]<br />Explanation: The first three athletes got the top three highest scores, so they got \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".&nbsp;<br />For the left two athletes, you just need to output their relative ranks according to their scores.<br />Note:<br />N is a positive integer and won't exceed 10,000.<br />All the scores of athletes are guaranteed to be unique.</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public string[] FindRelativeRanks(int[] nums) {\n        var map = new SortedDictionary&lt;int,int&gt;();\n        var temp = nums;\n        for(int i=0;i&lt;nums.Length;i++){\n            map.Add(nums[i],i);\n        }\n        Array.Sort(temp);\n        Array.Reverse(temp);\n        \n        var res = new string[nums.Length];\n        for(int i=0;i&lt;nums.Length;i++){\n            if(i==0){\n                res[map[temp[i]]]=\"Gold Medal\";\n            }\n            else if(i==1){\n                res[map[temp[i]]]=\"Silver Medal\";\n            }\n            else if(i==2){\n                res[map[temp[i]]]=\"Bronze Medal\";\n            }\n            else{\n                res[map[temp[i]]]=(i+1).ToString();\n            }\n        }\n        \n        return res;\n    }\n}</code></pre>\n<p>Time Complexity: O(nlogn)</p>\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/999e367f-6673-49be-9d6a-411dd5e1e1e2.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"relative-ranks-array-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1668,"title":"Triangle - Array - Medium - LeetCode","imageUrl":"icon_40571e99-73c8-48d0-aa94-4a53cb2adbce.jpg","dateCreated":"2020-11-17T12:18:25.997Z","dateModified":"2020-11-17T12:18:30.576Z","contributedBy":"sumitc91","content":"Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\nFor example, given the following triangle\n[<br />&nbsp; &nbsp; &nbsp;[2],<br />&nbsp; &nbsp; [3,4],<br />&nbsp; &nbsp;[6,5,7],<br />&nbsp; [4,1,8,3]<br />]<br","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/40571e99-73c8-48d0-aa94-4a53cb2adbce.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"triangle-array-medium-leetcode","total":0},{"id":1615,"title":"License Key Formatting - String - Easy - LeetCode","imageUrl":"icon_168f3a9d-b3aa-4758-a48d-b2e53a3ad538.jpg","dateCreated":"2020-10-17T04:06:23.384Z","dateModified":"2020-10-17T04:06:32.538Z","contributedBy":"sumitc91","content":"You are given a license key represented as a string S which consists of only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.\nGiven a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the fi","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/168f3a9d-b3aa-4758-a48d-b2e53a3ad538.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"license-key-formatting-string-easy-leetcode","total":0},{"id":1610,"title":"Valid Phone Numbers - Bash - Easy - LeetCode","imageUrl":"icon_903f4733-4a8e-4987-9d87-0e0feefd9f8e.jpg","dateCreated":"2020-10-16T07:46:02.223Z","dateModified":"2020-10-16T07:46:13.79Z","contributedBy":"sumitc91","content":"Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers.\nYou may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)\n","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/903f4733-4a8e-4987-9d87-0e0feefd9f8e.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"valid-phone-numbers-bash-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}