{"id":1629,"title":"Maximum Nesting Depth of the Parentheses - Stack - Easy - LeetCode","imageUrl":"icon_9d515e72-4c83-4541-9650-c0972215972d.jpg","dateCreated":"2020-10-18T08:20:30.391Z","dateModified":"2020-10-18T08:20:41.012Z","contributedBy":"sumitc91","content":"<p>A string is a valid parentheses string (denoted VPS) if it meets one of the following:</p>\n<p>It is an empty string \"\", or a single character not equal to \"(\" or \")\",<br />It can be written as AB (A concatenated with B), where A and B are VPS's, or<br />It can be written as (A), where A is a VPS.<br />We can similarly define the nesting depth depth(S) of any VPS S as follows:</p>\n<p>depth(\"\") = 0<br />depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's<br />depth(\"(\" + A + \")\") = 1 + depth(A), where A is a VPS.<br />For example, \"\", \"()()\", and \"()(()())\" are VPS's (with nesting depths 0, 1, and 2), and \")(\" and \"(()\" are not VPS's.</p>\n<p>Given a VPS represented as string s, return the nesting depth of s.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: s = \"(1+(2*3)+((8)/4))+1\"<br />Output: 3<br />Explanation: Digit 8 is inside of 3 nested parentheses in the string.<br />Example 2:</p>\n<p>Input: s = \"(1)+((2))+(((3)))\"<br />Output: 3<br />Example 3:</p>\n<p>Input: s = \"1+(2*3)/(2-1)\"<br />Output: 1<br />Example 4:</p>\n<p>Input: s = \"1\"<br />Output: 0<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>1 &lt;= s.length &lt;= 100<br />s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.<br />It is guaranteed that parentheses expression s is a VPS.</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int MaxDepth(string s) {\n        var stack = new Stack&lt;char&gt;();\n        int max = 0;\n        for(int i=0; i&lt; s.Length;i++){\n            if(s[i]=='('){\n                stack.Push('(');\n                if(max&lt;stack.Count()){\n                    max = stack.Count();\n                }\n            }\n            else if(s[i]==')'){\n                if(stack.Count()==0){\n                    return 0;\n                }\n                stack.Pop();\n            }\n        }\n        \n        return max;\n    }\n}</code></pre>\n<p>Time Complexity: O(n)</p>\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/9d515e72-4c83-4541-9650-c0972215972d.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"maximum-nesting-depth-of-the-parentheses-stack-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"stack","slug":"stack"}],"recommendations":[{"id":1701,"title":"K-diff Pairs in an Array - Array - Medium - LeetCode","imageUrl":"icon_adbe88a9-d88c-469f-ae16-26daa92dc3b3.jpg","dateCreated":"2020-11-20T09:11:47.894Z","dateModified":"2020-11-20T09:11:56.252Z","contributedBy":"sumitc91","content":"Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array.\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\n0 &lt;= i, j &lt; nums.length<br />i != j<br />|nums[i] - nums[j]| == k<br />Notice that |val| ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8c421996-adef-4a2c-b776-f3e3810e1e3b.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"k-diff-pairs-in-an-array-array-medium-leetcode","total":0},{"id":1679,"title":"Insert Delete GetRandom O(1) - Array - Medium - LeetCode","imageUrl":"icon_8589fcba-acbd-4690-8c6e-3f8e5511c176.jpg","dateCreated":"2020-11-19T06:35:11.658Z","dateModified":"2020-11-19T06:35:19.394Z","contributedBy":"sumitc91","content":"Implement the RandomizedSet class:\nbool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.<br />bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.<","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8589fcba-acbd-4690-8c6e-3f8e5511c176.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"insert-delete-getrandom-o1-array-medium-leetcode","total":0},{"id":1599,"title":"Flower Planting With No Adjacent - Graph - Easy - LeetCode","imageUrl":"icon_db7a0ad4-994c-4a3a-a3c6-63035a00d2da.jpg","dateCreated":"2020-10-15T05:15:37.382Z","dateModified":"2020-10-15T05:15:47.948Z","contributedBy":"sumitc91","content":"You have n gardens, labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes the existence of a bidirectional path from garden xi to garden yi. In each garden, you want to plant one of 4 types of flowers.\nThere is no garden that has more than three paths coming into or l","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/db7a0ad4-994c-4a3a-a3c6-63035a00d2da.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"graph","slug":"graph"},{"name":"leetcode","slug":"leetcode"}],"slug":"flower-planting-with-no-adjacent-graph-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}