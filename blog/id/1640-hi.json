{"id":1640,"title":"Find First and Last Position of Element in Sorted Array - Array - Medium - LeetCode","imageUrl":"icon_4dd548b4-7f64-4384-8000-de99e5e3a765.jpg","dateCreated":"2020-10-25T13:25:33.524Z","dateModified":"2020-10-25T13:25:43.128Z","contributedBy":"sumitc91","content":"<p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p>\n<p>If the target is not found in the array, return [-1, -1].</p>\n<p>Follow up: Could you write an algorithm with O(log n) runtime complexity?</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: nums = [5,7,7,8,8,10], target = 8<br />Output: [3,4]<br />Example 2:</p>\n<p>Input: nums = [5,7,7,8,8,10], target = 6<br />Output: [-1,-1]<br />Example 3:</p>\n<p>Input: nums = [], target = 0<br />Output: [-1,-1]<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>0 &lt;= nums.length &lt;= 105<br />-109 &lt;= nums[i] &lt;= 109<br />nums is a non-decreasing array.<br />-109 &lt;= target &lt;= 109</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int[] SearchRange(int[] nums, int target) {\n        var res = new int[2]{-1,-1};\n        int l = BinarySearchLeft(nums,target,0,nums.Length-1);\n        if(l==-1){\n            return res;\n        }\n        int r = BinarySearchRight(nums,target,0,nums.Length-1);\n        \n        res[0]=l;\n        res[1]=r;\n        return res;\n    }\n    \n    private int BinarySearchRight(int[] nums, int target, int lo, int hi){\n        if(lo &gt; hi){\n            return -1;\n        }\n        \n        int mid = lo + (hi-lo)/2;\n        if(nums.Length==0){\n            return -1;\n        }\n        \n        if(mid==nums.Length-1){\n            if(nums[mid]==target){\n                return mid;\n            }\n            else{\n                return -1;\n            }\n        }\n        else if(nums[mid] == target &amp;&amp; nums[mid+1]!=target){\n            return mid;\n        }\n        else if(nums[mid]&lt;=target){\n            lo = mid+1;\n        }\n        else if(nums[mid]&gt;target){\n            hi = mid-1;\n        }\n        \n        return BinarySearchRight(nums,target,lo,hi);\n    }\n    \n    private int BinarySearchLeft(int[] nums, int target, int lo, int hi){\n        if(lo&gt;hi){\n            return -1;\n        }\n        \n        int mid = lo + (hi - lo)/2;\n        if(mid == 0){\n            if(nums.Length==0){\n                return -1;\n            }            \n            else if(nums[0]==target){\n                return 0;\n            }\n            if((nums.Length==2 &amp;&amp; nums[1]==target)){\n                return 1;\n            }\n            else{\n                return -1;\n            }\n        }\n        else if(nums[mid]==target &amp;&amp; nums[mid-1]!=target){\n            return mid;\n        }\n        else if(nums[mid]&gt;=target){\n            hi = mid-1;\n        }\n        else if(nums[mid]&lt;target){\n            lo = mid+1;\n        }\n        \n        return BinarySearchLeft(nums, target, lo, hi);\n    }\n}</code></pre>\n<p>Time Complexity: O(logn)</p>\n<p>Space Complexity: O(1)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/4dd548b4-7f64-4384-8000-de99e5e3a765.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"find-first-and-last-position-of-element-in-sorted-array-array-medium-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"recommendations":[{"id":1711,"title":"Count of Matches in Tournament - String - Easy - LeetCode","imageUrl":"icon_d4fba4b6-ab89-4548-aaf7-f9918522d7dd.jpg","dateCreated":"2020-12-28T14:11:46.984Z","dateModified":"2020-12-28T14:11:55.184Z","contributedBy":"sumitc91","content":"You are given an integer n, the number of teams in a tournament that has strange rules:\nIf the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.<br />If the current number of teams is od","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/d4fba4b6-ab89-4548-aaf7-f9918522d7dd.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"count-of-matches-in-tournament-string-easy-leetcode","total":0},{"id":1673,"title":"Minimum Size Subarray Sum - Array - Medium - LeetCode","imageUrl":"icon_9cd5847f-8b41-455d-8ac3-9b66f2dcb47e.jpg","dateCreated":"2020-11-18T09:07:17.833Z","dateModified":"2020-11-18T09:07:23.659Z","contributedBy":"sumitc91","content":"Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum &ge; s. If there isn't one, return 0 instead.\nExample:&nbsp;\nInput: s = 7, nums = [2,3,1,2,4,3]<br />Output: 2<br />Explanation: the subarray [4,3] has t","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/9cd5847f-8b41-455d-8ac3-9b66f2dcb47e.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"minimum-size-subarray-sum-array-medium-leetcode","total":0},{"id":1642,"title":"Combination Sum II - Array - Medium - LeetCode","imageUrl":"icon_134b4baa-680a-45e5-b0df-c627789e2d42.jpg","dateCreated":"2020-10-25T16:13:32.074Z","dateModified":"2020-10-25T16:13:43.44Z","contributedBy":"sumitc91","content":"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplic","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/134b4baa-680a-45e5-b0df-c627789e2d42.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"combination-sum-ii-array-medium-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}