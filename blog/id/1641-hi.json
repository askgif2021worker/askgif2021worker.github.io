{"id":1641,"title":"Combination Sum - Array - Medium - LeetCode","imageUrl":"icon_b42ea67c-de94-42f6-aa57-391837827a47.jpg","dateCreated":"2020-10-25T14:37:09.044Z","dateModified":"2020-10-25T14:37:53.305Z","contributedBy":"sumitc91","content":"<p>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.</p>\n<p>The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p>\n<p>It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: candidates = [2,3,6,7], target = 7<br />Output: [[2,2,3],[7]]<br />Explanation:<br />2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.<br />7 is a candidate, and 7 = 7.<br />These are the only two combinations.<br />Example 2:</p>\n<p>Input: candidates = [2,3,5], target = 8<br />Output: [[2,2,2,2],[2,3,3],[3,5]]<br />Example 3:</p>\n<p>Input: candidates = [2], target = 1<br />Output: []<br />Example 4:</p>\n<p>Input: candidates = [1], target = 1<br />Output: [[1]]<br />Example 5:</p>\n<p>Input: candidates = [1], target = 2<br />Output: [[1,1]]<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>1 &lt;= candidates.length &lt;= 30<br />1 &lt;= candidates[i] &lt;= 200<br />All elements of candidates are distinct.<br />1 &lt;= target &lt;= 500</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    IList&lt;IList&lt;int&gt;&gt; ans = new List&lt;IList&lt;int&gt;&gt;();\n    HashSet&lt;string&gt; set = new HashSet&lt;string&gt;();\n    public IList&lt;IList&lt;int&gt;&gt; CombinationSum(int[] candidates, int target) {\n        var res = new List&lt;int&gt;();\n        Helper(candidates, target, res);\n        return ans;\n    }\n    \n    private void Helper(int[] candidates, int target, List&lt;int&gt; res){\n        if(target == 0){\n            if(set.Contains(GetKey(res))){\n                return;\n            }\n            var temp = new List&lt;int&gt;();\n            foreach(var item in res){\n                temp.Add(item);\n            }\n            ans.Add(temp);\n            set.Add(GetKey(res));\n            return;\n        }\n        \n        if(target &lt; 0)\n        {\n            return;\n        }\n        \n        for(int i=0;i&lt;candidates.Length;i++){            \n            res.Add(candidates[i]);\n            Helper(candidates, target-candidates[i], res);\n            res.RemoveAt(res.Count()-1);\n        }\n    }\n    \n    private string GetKey(List&lt;int&gt; res){\n        var arr = res.ToArray();\n        Array.Sort(arr);\n        return string.Join(\":\", arr);\n    }\n}</code></pre>\n<p>Time Complexity: O(n^n) //Exponential time complexity</p>\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/b42ea67c-de94-42f6-aa57-391837827a47.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"combination-sum-array-medium-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"recommendations":[{"id":1669,"title":"Maximum Product Subarray - Array - Medium - LeetCode","imageUrl":"icon_7f1afad0-6986-4b75-b8b1-48cc2da5b308.jpg","dateCreated":"2020-11-17T12:27:09.279Z","dateModified":"2020-11-17T12:27:13.842Z","contributedBy":"sumitc91","content":"Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.\nExample 1:\nInput: [2,3,-2,4]<br />Output: 6<br />Explanation: [2,3] has the largest product 6.<br />Example 2:\nInput: [-2,0,-1]<br />Outpu","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/7f1afad0-6986-4b75-b8b1-48cc2da5b308.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"maximum-product-subarray-array-medium-leetcode","total":0},{"id":1651,"title":"Unique Paths II - Array - Medium - LeetCode","imageUrl":"icon_ca5278d5-6ee2-45fc-9c8e-7f12ff9f0357.jpg","dateCreated":"2020-10-31T08:51:34.949Z","dateModified":"2020-10-31T08:51:41.7Z","contributedBy":"sumitc91","content":"A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\nNow consider i","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/ca5278d5-6ee2-45fc-9c8e-7f12ff9f0357.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"unique-paths-ii-array-medium-leetcode","total":0},{"id":1635,"title":"New Year Chaos - Array - Medium - HackerRank","imageUrl":"icon_53eb9e67-4065-4a48-af84-1ab48ec4ee5e.jpg","dateCreated":"2020-10-24T07:14:47.121Z","dateModified":"2020-10-24T07:15:13.568Z","contributedBy":"sumitc91","content":"It's New Year's Day and everyone's in line for the Wonderland rollercoaster ride! There are a number of people queued up, and each person wears a sticker indicating their initial position in the queue. Initial positions increment by &nbsp;from &nbsp;at the front of the line to &nbsp;at the back.<","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/53eb9e67-4065-4a48-af84-1ab48ec4ee5e.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"hackerrank","slug":"hackerrank"},{"name":"मध्यम","slug":"medium"}],"slug":"new-year-chaos-array-medium-hackerrank","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}