{"id":1648,"title":"Insert Interval - Array - Medium - LeetCode","imageUrl":"icon_5a35d970-95af-493c-9aca-0b4bed037719.jpg","dateCreated":"2020-10-31T06:40:08.43Z","dateModified":"2020-10-31T06:40:18.214Z","contributedBy":"sumitc91","content":"<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>\n<p>You may assume that the intervals were initially sorted according to their start times.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: intervals = [[1,3],[6,9]], newInterval = [2,5]<br />Output: [[1,5],[6,9]]<br />Example 2:</p>\n<p>Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<br />Output: [[1,2],[3,10],[12,16]]<br />Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].<br />Example 3:</p>\n<p>Input: intervals = [], newInterval = [5,7]<br />Output: [[5,7]]<br />Example 4:</p>\n<p>Input: intervals = [[1,5]], newInterval = [2,3]<br />Output: [[1,5]]<br />Example 5:</p>\n<p>Input: intervals = [[1,5]], newInterval = [2,7]<br />Output: [[1,7]]<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>0 &lt;= intervals.length &lt;= 104<br />intervals[i].length == 2<br />0 &lt;= intervals[i][0] &lt;= intervals[i][1] &lt;= 105<br />intervals is sorted by intervals[i][0] in ascending order.<br />newInterval.length == 2<br />0 &lt;= newInterval[0] &lt;= newInterval[1] &lt;= 105</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\n        var res = new List&lt;int[]&gt;();\n        if(intervals.Length==0){\n            res.Add(newInterval);\n            return res.ToArray();\n        }\n                \n        int start = 0;\n        int end = 0;\n        int i=0;\n        for(i=0;i&lt;intervals.Length &amp;&amp; intervals[i][1] &lt; newInterval[0];i++){\n            if(intervals[i][1]&lt;newInterval[0]){\n                res.Add(new int[]{intervals[i][0], intervals[i][1]});\n            }                \n        }\n        \n        for(;i&lt;intervals.Length &amp;&amp; intervals[i][0]&lt;= newInterval[1];i++){\n            newInterval[0]=Math.Min(newInterval[0], intervals[i][0]);\n            newInterval[1]=Math.Max(newInterval[1], intervals[i][1]);\n        }\n        \n        res.Add(newInterval);\n        \n        for(;i&lt;intervals.Length;i++){\n            res.Add(new int[]{intervals[i][0], intervals[i][1]});\n        }        \n        \n        \n        return res.ToArray();\n    }\n}</code></pre>\n<p>Time Complexity: O(n)</p>\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/5a35d970-95af-493c-9aca-0b4bed037719.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"insert-interval-array-medium-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"recommendations":[{"id":1723,"title":"Beautiful Arrangement II - Maths - Medium - LeetCode","imageUrl":"icon_b2d502bc-0983-4102-b87f-e37eff0ed0db.jpg","dateCreated":"2021-01-26T13:09:40.384Z","dateModified":"2021-01-26T13:09:46.827Z","contributedBy":"sumitc91","content":"Given two integers n and k, you need to construct a list that contains n different positive integers ranging from 1 to n and obeys the following requirement:<br />Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/b2d502bc-0983-4102-b87f-e37eff0ed0db.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"maths","slug":"maths"},{"name":"medium","slug":"medium"}],"slug":"beautiful-arrangement-ii-maths-medium-leetcode","total":0},{"id":1720,"title":"Number Of Rectangles That Can Form The Largest Square - Array - Easy - LeetCode","imageUrl":"icon_a3758d97-0c9c-4e59-860a-b2f31b1f95ab.jpg","dateCreated":"2021-01-18T12:11:37.997Z","dateModified":"2021-01-18T12:11:43.515Z","contributedBy":"sumitc91","content":"You are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of length li and width wi.\nYou can cut the ith rectangle to form a square with a side length of k if both k &lt;= li and k &lt;= wi. For example, if you have a rectangle [4,6], you can cut it to g","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a3758d97-0c9c-4e59-860a-b2f31b1f95ab.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"number-of-rectangles-that-can-form-the-largest-square-array-easy-leetcode","total":0},{"id":1674,"title":"Combination Sum III - Array - Medium - LeetCode","imageUrl":"icon_becf4b84-69f9-4582-a8d7-d32b8422353a.jpg","dateCreated":"2020-11-18T11:38:07.946Z","dateModified":"2020-11-18T11:38:14.249Z","contributedBy":"sumitc91","content":"Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\nOnly numbers 1 through 9 are used.<br />Each number is used at most once.<br />Return a list of all possible valid combinations. The list must not contain the same combination twice, and ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/becf4b84-69f9-4582-a8d7-d32b8422353a.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"combination-sum-iii-array-medium-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}