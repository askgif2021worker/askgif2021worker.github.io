{"id":1651,"title":"Unique Paths II - Array - Medium - LeetCode","imageUrl":"icon_ca5278d5-6ee2-45fc-9c8e-7f12ff9f0357.jpg","dateCreated":"2020-10-31T08:51:34.949Z","dateModified":"2020-10-31T08:51:41.7Z","contributedBy":"sumitc91","content":"<p>A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).</p>\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).</p>\n<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>\n<p>&nbsp;</p>\n<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>\n<p>Note: m and n will be at most 100.</p>\n<p>Example 1:</p>\n<p>Input:<br />[<br />&nbsp; [0,0,0],<br />&nbsp; [0,1,0],<br />&nbsp; [0,0,0]<br />]<br />Output: 2<br />Explanation:<br />There is one obstacle in the middle of the 3x3 grid above.<br />There are two ways to reach the bottom-right corner:<br />1. Right -&gt; Right -&gt; Down -&gt; Down<br />2. Down -&gt; Down -&gt; Right -&gt; Right</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int UniquePathsWithObstacles(int[][] obstacleGrid) {\n        int r = obstacleGrid.Length;\n        int c = obstacleGrid[0].Length;\n        var T = new int[r,c];\n        \n        bool obstacleFound = false;\n        for(int i=0;i&lt;r;i++){\n            if(obstacleGrid[i][0]==1){\n               obstacleFound = true;\n            }\n            T[i,0] = obstacleFound ? 0 : 1;\n        }\n        \n        obstacleFound = false;\n        for(int i=0;i&lt;c;i++){\n            if(obstacleGrid[0][i]==1){\n                 obstacleFound = true;\n            }\n            T[0,i]= obstacleFound ? 0 : 1;\n        }\n        \n        for(int i=1;i&lt;r;i++){\n            for(int j=1;j&lt;c;j++){\n                T[i,j] = obstacleGrid[i][j]==1 ? 0 : T[i-1,j]+T[i,j-1];\n            }\n        }\n        \n        return T[r-1,c-1];\n    }\n}</code></pre>\n<p>Time Complexity: O(n^2)</p>\n<p>Space Complexity: O(n^2)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/ca5278d5-6ee2-45fc-9c8e-7f12ff9f0357.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"unique-paths-ii-array-medium-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"recommendations":[{"id":1708,"title":"Richest Customer Wealth - String - Easy - LeetCode","imageUrl":"icon_030389b7-ce6f-4ad2-b65b-dcfe84bba591.jpg","dateCreated":"2020-12-02T09:18:51.882Z","dateModified":"2020-12-02T09:18:55.989Z","contributedBy":"sumitc91","content":"You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.\nA customer's wealth is the amount of money they have in all their bank accounts. The","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/030389b7-ce6f-4ad2-b65b-dcfe84bba591.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"richest-customer-wealth-string-easy-leetcode","total":0},{"id":1706,"title":"Check If Two String Arrays are Equivalent - String - Easy - LeetCode","imageUrl":"icon_38460c51-4f08-46d0-82ef-1f2263c60127.jpg","dateCreated":"2020-11-24T13:04:46.01Z","dateModified":"2020-11-24T13:04:50.906Z","contributedBy":"sumitc91","content":"Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.\n&nbsp;\nExample 1:\nInput: word1 = [\"ab\", \"c\"], word2 ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/38460c51-4f08-46d0-82ef-1f2263c60127.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"check-if-two-string-arrays-are-equivalent-string-easy-leetcode","total":0},{"id":1607,"title":"Employees Earning More Than Their Managers - Sql - Easy - LeetCode","imageUrl":"icon_0a6cfc7c-14b2-43e5-8538-b4498ef0b5c3.jpg","dateCreated":"2020-10-16T06:26:34.794Z","dateModified":"2020-10-16T06:26:46.282Z","contributedBy":"sumitc91","content":"The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.\n+----+-------+--------+-----------+<br />| Id | Name &nbsp;| Salary | ManagerId |<br />+----+-------+--------+-----------+<br />| 1 &nbsp;| Joe &nbsp; |","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/0a6cfc7c-14b2-43e5-8538-b4498ef0b5c3.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"mysql","slug":"mysql"},{"name":"sql","slug":"sql"}],"slug":"employees-earning-more-than-their-managers-sql-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}