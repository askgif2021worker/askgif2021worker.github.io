{"id":1660,"title":"Check Array Formation Through Concatenation - Array - Easy - LeetCode","imageUrl":"icon_85392267-2028-4c02-8f8a-96c1d2368591.jpg","dateCreated":"2020-11-03T06:50:35.06Z","dateModified":"2020-11-03T06:50:53.205Z","contributedBy":"sumitc91","content":"<p>You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].</p>\n<p>Return true if it is possible to form the array arr from pieces. Otherwise, return false.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: arr = [85], pieces = [[85]]<br />Output: true<br />Example 2:</p>\n<p>Input: arr = [15,88], pieces = [[88],[15]]<br />Output: true<br />Explanation: Concatenate [15] then [88]<br />Example 3:</p>\n<p>Input: arr = [49,18,16], pieces = [[16,18,49]]<br />Output: false<br />Explanation: Even though the numbers match, we cannot reorder pieces[0].<br />Example 4:</p>\n<p>Input: arr = [91,4,64,78], pieces = [[78],[4,64],[91]]<br />Output: true<br />Explanation: Concatenate [91] then [4,64] then [78]<br />Example 5:</p>\n<p>Input: arr = [1,3,5,7], pieces = [[2,4,6,8]]<br />Output: false<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>1 &lt;= pieces.length &lt;= arr.length &lt;= 100<br />sum(pieces[i].length) == arr.length<br />1 &lt;= pieces[i].length &lt;= arr.length<br />1 &lt;= arr[i], pieces[i][j] &lt;= 100<br />The integers in arr are distinct.<br />The integers in pieces are distinct (i.e., If we flatten pieces in a 1D array, all the integers in this array are distinct).</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public bool CanFormArray(int[] arr, int[][] pieces) {\n        var set = new HashSet&lt;string&gt;();\n        for(int i=0;i&lt;pieces.Length;i++){\n            set.Add(GetKey(pieces[i]));\n        }\n        \n        var strList = new List&lt;int&gt;();\n        var str = \"\";\n        for(int i=0;i&lt;arr.Length;i++){\n            strList.Add(arr[i]);\n            str = GetKey(strList.ToArray());\n            if(set.Contains(str)){                \n                strList.Clear();\n            }            \n        }\n        \n        return strList.Count()==0;\n    }\n    \n    private string GetKey(int[] piece){\n        return string.Join(\":\",piece);\n    }\n}</code></pre>\n<p>Time Complexity: O(m*n)</p>\n<p>Space Complexity: O(m)</p>\n<p>Where m is the size of the places list and n is the size of the individual place list.</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/85392267-2028-4c02-8f8a-96c1d2368591.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"check-array-formation-through-concatenation-array-easy-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"recommendations":[{"id":1668,"title":"Triangle - Array - Medium - LeetCode","imageUrl":"icon_40571e99-73c8-48d0-aa94-4a53cb2adbce.jpg","dateCreated":"2020-11-17T12:18:25.997Z","dateModified":"2020-11-17T12:18:30.576Z","contributedBy":"sumitc91","content":"Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\nFor example, given the following triangle\n[<br />&nbsp; &nbsp; &nbsp;[2],<br />&nbsp; &nbsp; [3,4],<br />&nbsp; &nbsp;[6,5,7],<br />&nbsp; [4,1,8,3]<br />]<br","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/40571e99-73c8-48d0-aa94-4a53cb2adbce.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"triangle-array-medium-leetcode","total":0},{"id":1642,"title":"Combination Sum II - Array - Medium - LeetCode","imageUrl":"icon_134b4baa-680a-45e5-b0df-c627789e2d42.jpg","dateCreated":"2020-10-25T16:13:32.074Z","dateModified":"2020-10-25T16:13:43.44Z","contributedBy":"sumitc91","content":"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplic","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/134b4baa-680a-45e5-b0df-c627789e2d42.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"combination-sum-ii-array-medium-leetcode","total":0},{"id":1612,"title":"Delete Duplicate Emails - SQL - Easy - LeetCode","imageUrl":"icon_a8c368b1-ddbd-45ca-96b4-7558b7166a74.jpg","dateCreated":"2020-10-16T11:31:27.16Z","dateModified":"2020-10-16T11:31:37.404Z","contributedBy":"sumitc91","content":"Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.\n+----+------------------+<br />| Id | Email &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />+----+------------------+<br />| 1 &nbsp;| john@example.com |<br","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a8c368b1-ddbd-45ca-96b4-7558b7166a74.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"mysql","slug":"mysql"},{"name":"sql","slug":"sql"}],"slug":"delete-duplicate-emails-sql-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}