{"id":1688,"title":"सामाजिक नेटवर्क के लिए डेटा संरचनाओं को कैसे डिज़ाइन करें","imageUrl":"icon_031621dc-30c0-4e0d-ba31-1f20a3884f5c.jpg","dateCreated":"2020-11-20T06:57:07.127Z","dateModified":"2020-11-20T06:57:27.446Z","contributedBy":"sumitc91","content":"<p>चरण 1: मामलों और बाधाओं का उपयोग करें<br />आवश्यकताओं को इकट्ठा करें और समस्या को हल करें। उपयोग के मामलों और बाधाओं को स्पष्ट करने के लिए प्रश्न पूछें। मान्यताओं पर चर्चा करें।</p>\n<p>साक्षात्कारकर्ता के बिना स्पष्ट प्रश्नों को संबोधित करने के लिए, हम कुछ उपयोग मामलों और बाधाओं को परिभाषित करेंगे।</p>\n<p>बक्सों का इस्तेमाल करें<br />हम केवल निम्नलिखित उपयोग के मामलों को संभालने के लिए समस्या को हल करेंगे<br />उपयोगकर्ता किसी को खोजता है और खोजे गए व्यक्ति का सबसे छोटा रास्ता देखता है<br />सेवा की उच्च उपलब्धता है<br />अड़चनें और धारणाएँ<br />राज्य की धारणाएँ<br />यातायात समान रूप से वितरित नहीं किया जाता है<br />कुछ खोज दूसरों की तुलना में अधिक लोकप्रिय हैं, जबकि अन्य केवल एक बार निष्पादित होती हैं<br />ग्राफ डेटा एक मशीन पर फिट नहीं होगा<br />ग्राफ़ किनारों का आकार कम किया गया है<br />100 मिलियन उपयोगकर्ता<br />प्रति उपयोगकर्ता औसत 50 मित्र<br />1 बिलियन मित्र प्रति माह खोज करता है<br />अधिक पारंपरिक प्रणालियों के उपयोग का अभ्यास करें - ग्राफ़-विशिष्ट समाधानों जैसे कि ग्राफ़कॉक या नियो 4 जे जैसे ग्राफ़ डेटाबेस का उपयोग न करें</p>\n<p>उपयोग की गणना करें<br />अपने साक्षात्कारकर्ता के साथ स्पष्ट करें कि क्या आपको बैक-ऑफ-द-लिफाफा उपयोग गणनाओं को चलाना चाहिए।</p>\n<p>5 अरब मित्र संबंध<br />100 मिलियन उपयोगकर्ता * प्रति उपयोगकर्ता औसत 50 मित्र<br />प्रति सेकंड 400 खोज अनुरोध<br />आसान रूपांतरण गाइड:</p>\n<p>2.5 मिलियन सेकंड प्रति माह<br />1 प्रति सेकंड अनुरोध = प्रति माह 2.5 मिलियन अनुरोध<br />40 प्रति सेकंड अनुरोध = प्रति माह 100 मिलियन अनुरोध<br />प्रति माह 400 अनुरोध = प्रति माह 1 बिलियन अनुरोध<br />चरण 2: एक उच्च स्तरीय डिज़ाइन बनाएं<br />सभी महत्वपूर्ण घटकों के साथ एक उच्च स्तरीय डिजाइन की रूपरेखा।</p>\n<p>Imgur</p>\n<p>चरण 3: डिजाइन कोर घटक<br />प्रत्येक मुख्य घटक के लिए विवरण में गोता लगाएँ।</p>\n<p>मामले का उपयोग करें: उपयोगकर्ता किसी की खोज करता है और खोजे गए व्यक्ति के लिए सबसे छोटा रास्ता देखता है<br />अपने साक्षात्कारकर्ता के साथ स्पष्ट करें कि आपको कितने कोड लिखने की उम्मीद है।</p>\n<p>लाखों उपयोगकर्ताओं (वर्टिकल) और अरबों मित्र संबंधों (किनारों) की अड़चन के बिना, हम सामान्य BFS दृष्टिकोण के साथ इस सबसे छोटे पथ को हल कर सकते हैं:</p>\n<p>वर्ग ग्राफ़ (ग्राफ़):</p>\n<p>&nbsp; &nbsp; def shortest_path (स्वयं, स्रोत, भाग्य):<br />&nbsp; &nbsp; &nbsp; &nbsp; यदि स्रोत कोई नहीं है या कोई भी नहीं है:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; कोई नहीं<br />&nbsp; &nbsp; &nbsp; &nbsp; यदि स्रोत भाग्य है:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; वापसी [source.key]<br />&nbsp; &nbsp; &nbsp; &nbsp; prev_node_keys = self._shortest_path (स्रोत, भाग्य)<br />&nbsp; &nbsp; &nbsp; &nbsp; अगर prev_node_keys कोई नहीं है:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; कोई नहीं लौटा<br />&nbsp; &nbsp; &nbsp; &nbsp; अन्य:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path_ids = [dest.key]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_node_key = prev_node_keys [dest.key]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; जबकि prev_node_key कोई नहीं है:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path_ids.append (prev_node_key)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_node_key = prev_node_keys [prev_node_key]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; वापसी path_ids [:: - 1]</p>\n<p>&nbsp; &nbsp; def _shortest_path (स्वयं, स्रोत, भाग्य):<br />&nbsp; &nbsp; &nbsp; &nbsp; कतार = deque ()<br />&nbsp; &nbsp; &nbsp; &nbsp; queue.append (स्रोत)<br />&nbsp; &nbsp; &nbsp; &nbsp; prev_node_keys = {source.key: कोई नहीं}<br />&nbsp; &nbsp; &nbsp; &nbsp; source.visit_state = State.visited<br />&nbsp; &nbsp; &nbsp; &nbsp; जबकि कतार:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; नोड = कतार.पॉपलेफ़्ट ()<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; यदि नोड भाग्य है:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; वापसी prev_node_keys<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_node = नोड<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; नोड में adj_node.adj_nodes.values ​​() के लिए:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; अगर adj_node.visit_state == State.unvisited:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queue.append (adj_node)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_node_keys [adj_node.key] = prev_node.key<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; adj_node.visit_state = State.visited<br />&nbsp; &nbsp; &nbsp; &nbsp; कोई नहीं लौटा<br />हम सभी उपयोगकर्ताओं को एक ही मशीन पर फिट करने में सक्षम नहीं होंगे, हमें उपयोगकर्ताओं को व्यक्तिगत सर्वर पर शार्प करने और उन्हें लुकअप सेवा के साथ एक्सेस करने की आवश्यकता होगी।</p>\n<p>क्लाइंट एक रिवर्स प्रॉक्सी के रूप में चल रहा है, वेब सर्वर के लिए एक अनुरोध भेजता है<br />वेब सर्वर खोज एपीआई सर्वर के अनुरोध को आगे बढ़ाता है<br />खोज एपीआई सर्वर उपयोगकर्ता ग्राफ सेवा के लिए अनुरोध को आगे बढ़ाता है<br />उपयोगकर्ता ग्राफ़ सेवा निम्नलिखित करती है:<br />व्यक्ति सर्वर जहां वर्तमान उपयोगकर्ता की जानकारी संग्रहीत है खोजने के लिए लुकअप सेवा का उपयोग करता है<br />उपयोगकर्ता के वर्तमान मित्र की सूची को पुनः प्राप्त करने के लिए उपयुक्त व्यक्ति सर्वर को ढूँढता है<br />प्रत्येक निकटवर्ती_कोड के लिए आईडी के रूप में वर्तमान उपयोगकर्ता के स्रोत और वर्तमान उपयोगकर्ता के friend_ids के रूप में एक BFS खोज चलाता है<br />दिए गए आईडी से adjacent_node प्राप्त करने के लिए:<br />उपयोगकर्ता ग्राफ़ सेवा को फिर से लुकअप सेवा के साथ संवाद करने की आवश्यकता होगी, यह निर्धारित करने के लिए कि दिए गए आईडी से मेल खाते हुए पर्सनेल सर्वर थ्रेडिकेंट_नोड (ऑप्टिमाइज़ेशन के लिए संभावित)<br />अपने साक्षात्कारकर्ता के साथ स्पष्ट करें कि आपको कितना कोड लिखना चाहिए।</p>\n<p>नोट: त्रुटि से निपटने को सरलता के लिए नीचे रखा गया है। पूछें कि क्या आपको उचित त्रुटि सौंपने का कोड चाहिए।</p>\n<p>लुकअप सेवा कार्यान्वयन:</p>\n<p>क्लास लुकअप सर्विस (ऑब्जेक्ट):</p>\n<p>&nbsp; &nbsp; def __init __ (स्व):<br />&nbsp; &nbsp; &nbsp; &nbsp; self.lookup = self._init_lookup () # कुंजी: person_id, मान: person_server</p>\n<p>&nbsp; &nbsp; def _init_lookup (स्व):<br />&nbsp; &nbsp; &nbsp; &nbsp; ...</p>\n<p>&nbsp; &nbsp; डीफ़ लुकिंग_पर्सन_सर्वर (स्वयं, person_id):<br />&nbsp; &nbsp; &nbsp; &nbsp; स्व वापस जाएँ। [person_id]<br />व्यक्ति सर्वर कार्यान्वयन:</p>\n<p>वर्ग व्यक्ति (वस्तु):</p>\n<p>&nbsp; &nbsp; def __init __ (स्व):<br />&nbsp; &nbsp; &nbsp; &nbsp; self.people = {} # कुंजी: person_id, मान: व्यक्ति</p>\n<p>&nbsp; &nbsp; def add_person (स्व, व्यक्ति):<br />&nbsp; &nbsp; &nbsp; &nbsp; ...</p>\n<p>&nbsp; &nbsp; लोगों को (स्वयं, आईडी) को हराया:<br />&nbsp; &nbsp; &nbsp; &nbsp; परिणाम = []<br />&nbsp; &nbsp; &nbsp; &nbsp; आईडी में आईडी के लिए:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; अगर स्वयं में आईडी। लोग:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; results.append (self.people [id])<br />&nbsp; &nbsp; &nbsp; &nbsp; वापसी के परिणाम<br />व्यक्ति कार्यान्वयन:</p>\n<p>वर्ग व्यक्ति (वस्तु):</p>\n<p>&nbsp; &nbsp; def __init __ (स्व, आईडी, नाम, friend_ids):<br />&nbsp; &nbsp; &nbsp; &nbsp; self.id = आईडी<br />&nbsp; &nbsp; &nbsp; &nbsp; स्व.नाम = नाम<br />&nbsp; &nbsp; &nbsp; &nbsp; self.friend_ids = friend_ids<br />उपयोगकर्ता ग्राफ़ सेवा</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/031621dc-30c0-4e0d-ba31-1f20a3884f5c.jpg","subContents":[],"category":{"name":"शिक्षण","slug":"tutorials"},"slug":"how-to-design-the-data-structures-for-a-social-network","tags":[{"name":"डिज़ाइन","slug":"design"},{"name":"interview","slug":"interview"},{"name":"प्रणाली-की-रूपरेखा","slug":"system-design"}],"recommendations":[{"id":1698,"title":"अनुप्रयोग परत क्या है?","imageUrl":"icon_6faa8ad3-f4c7-411a-a351-f5721537582b.jpg","dateCreated":"2020-11-20T07:40:00.435Z","dateModified":"2020-11-20T07:40:05.453Z","contributedBy":"sumitc91","content":"वेब परत को एप्लिकेशन लेयर (जिसे प्लेटफ़ॉर्म लेयर के रूप में भी जाना जाता है) से अलग करना आपको दोनों परतों को स्वतंत्र रूप से स्केल करने और कॉन्फ़िगर करने की अनुमति देता है। बिना अतिरिक्त वेब सर्वर को जोड़ने के बिना एप्लिकेशन सर्वर को जोड़ने में एक नया एपीआई परिणाम जोड़ना। एकल जिम्मेदारी सिद्धांत ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/6faa8ad3-f4c7-411a-a351-f5721537582b.jpg","category":{"name":"शिक्षण","slug":"tutorials"},"tags":[{"name":"interview","slug":"interview"}],"slug":"what-is-application-layer","total":0},{"id":87,"title":"How to find Nth node from the end of a Linked List?","imageUrl":"d56c6c6f-abf1-425a-8c3b-d14b4068d305_find-nth-node.png","dateCreated":"2018-08-06T12:38:40.227Z","dateModified":"2018-08-06T12:38:49.993Z","contributedBy":"AskGif","content":"Given a linked list, remove the nth node from the end of the list and return its head.\r\nFor example,\r\nGiven linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.\r\nAfter removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.\r\nGiven n will alway","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/d56c6c6f-abf1-425a-8c3b-d14b4068d305_find-nth-node.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"linked-list","slug":"linked-list"},{"name":"interview","slug":"interview"},{"name":"java","slug":"java"},{"name":"प्रशन","slug":"questions"}],"slug":"how-to-find-nth-node-from-the-end-of-a-linked-list","total":0},{"id":70,"title":"सिंगलटन पैटर्न क्या है?","imageUrl":"cd3b4cdf-875c-4382-8f39-8e7c74356b19_singleton-pattern.png","dateCreated":"2018-08-01T13:32:33.457Z","dateModified":"2018-08-01T17:19:42.254Z","contributedBy":"AskGif","content":"In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system. The concept is sometimes generalized to systems that operate more effici","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/cd3b4cdf-875c-4382-8f39-8e7c74356b19_singleton-pattern.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"interview","slug":"interview"},{"name":"प्रशन","slug":"questions"},{"name":"design-patterns","slug":"design-patterns"},{"name":"creational-pattern","slug":"creational-pattern"}],"slug":"what-is-singleton-pattern","total":0},{"id":17,"title":"Write a Simple Hello World Program in JAVA.","imageUrl":"f91c0323-afd7-4b3e-aa1f-71c79e9913f2_hello-world-java.png","dateCreated":"2018-07-12T06:44:09.184Z","dateModified":"2018-07-12T06:44:59.673Z","contributedBy":"AskGif","content":"Writing a simple hello world programm in java.&nbsp;Java is a general-purpose computer-programming language that is concurrent, class-based, object-oriented, and specifically designed to have as few implementation dependencies as possible. It is intended to let application developers \"write once,","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/f91c0323-afd7-4b3e-aa1f-71c79e9913f2_hello-world-java.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"interview","slug":"interview"},{"name":"java","slug":"java"}],"slug":"write-a-simple-hello-world-program-in-java","total":0}]}