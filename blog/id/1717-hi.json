{"id":1717,"title":"Task Scheduler - Array - Medium - LeetCode","imageUrl":"icon_ce3e557e-274e-4956-a16f-a62c66777be4.jpg","dateCreated":"2021-01-09T09:25:26.524Z","dateModified":"2021-01-09T09:25:33.09Z","contributedBy":"sumitc91","content":"<p>Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.</p>\n<p>However, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks.</p>\n<p>Return the least number of units of times that the CPU will take to finish all the given tasks.</p>\n<p>&nbsp;</p>\n<p>Example 1:</p>\n<p>Input: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2<br />Output: 8<br />Explanation:&nbsp;<br />A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B<br />There is at least 2 units of time between any two same tasks.<br />Example 2:</p>\n<p>Input: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0<br />Output: 6<br />Explanation: On this case any permutation of size 6 would work since n = 0.<br />[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]<br />[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]<br />[\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]<br />...<br />And so on.<br />Example 3:</p>\n<p>Input: tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2<br />Output: 16<br />Explanation:&nbsp;<br />One possible solution is<br />A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; idle -&gt; idle -&gt; A -&gt; idle -&gt; idle -&gt; A<br />&nbsp;</p>\n<p>Constraints:</p>\n<p>1 &lt;= task.length &lt;= 104<br />tasks[i] is upper-case English letter.<br />The integer n is in the range [0, 100].</p>\n<pre class=\"language-csharp\"><code>public class Solution {\n    public int LeastInterval(char[] tasks, int n) {\n        int maxFreq = 0;\n        int interval = 0;\n        int cnt = 0;\n        var map = new Dictionary&lt;char, int&gt;();\n        \n        // Find the max frequency that any task can have \n        foreach(char t in tasks)\n        {\n            if(map.ContainsKey(t))\n                map[t]++;\n            else\n                map.Add(t, 1);\n            \n            maxFreq = Math.Max(maxFreq, map[t]);\n        }\n        \n        // Find the number of tasks that have the max frequency\n        foreach(var kv in map)\n        {\n            if(map[kv.Key] == maxFreq)\n                cnt++;\n        }\n        \n        // maxFreq - 1: blocks needed to allocate the first maxFreq-1 most-frequent task\n        // n + 1: each block needs n+1 spaces due the the cooling interval.\n        // cnt: Size of last block = number of most-frequent tasks\n        interval = (maxFreq - 1) * (n + 1) + cnt;\n        \n        return interval &lt; tasks.Length?  tasks.Length : interval;\n    }\n}</code></pre>\n<p>Time Complexity: O(n)</p>\n<p>Space Complexity: O(n)</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/ce3e557e-274e-4956-a16f-a62c66777be4.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"task-scheduler-array-medium-leetcode","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"recommendations":[{"id":1677,"title":"Find the Duplicate Number - Array - Medium - LeetCode","imageUrl":"icon_85d20211-e54a-42fd-9300-e83bc02b7ffe.jpg","dateCreated":"2020-11-18T13:09:40.526Z","dateModified":"2020-11-18T13:09:46.723Z","contributedBy":"sumitc91","content":"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one duplicate number in nums, return this duplicate number.\nFollow-ups:\nHow can we prove that at least one duplicate number must exist in nums?&nbsp;<b","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/85d20211-e54a-42fd-9300-e83bc02b7ffe.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"find-the-duplicate-number-array-medium-leetcode","total":0},{"id":1628,"title":"Special Array With X Elements Greater Than or Equal X - Array - Easy - LeetCode","imageUrl":"icon_8f426000-750a-4ff1-bb71-5a34851ae354.jpg","dateCreated":"2020-10-18T06:57:23.217Z","dateModified":"2020-10-18T06:57:30.65Z","contributedBy":"sumitc91","content":"You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.\nNotice that x does not have to be an element in nums.\nReturn x if the array is special, othe","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8f426000-750a-4ff1-bb71-5a34851ae354.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"special-array-with-x-elements-greater-than-or-equal-x-array-easy-leetcode","total":0},{"id":1622,"title":"Rotate String - String - Easy - LeetCode","imageUrl":"icon_cfadbae1-5a57-4a8d-8e75-47f7f8493641.jpg","dateCreated":"2020-10-17T06:43:07.643Z","dateModified":"2020-10-17T06:43:14.01Z","contributedBy":"sumitc91","content":"We are given two strings, A and B.\nA shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = 'abcde', then it will be 'bcdea' after one shift on A. Return True if and only if A can become B after some number of shifts on A.</p","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/021208ce-72e5-4026-a526-0c8b482a8d72.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"rotate-string-string-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}