{"id":210,"title":"What is a Priority Queue?","imageUrl":"09a0405d-4490-4161-bb38-f3f69f75356d_Priority-Queue.jpg","dateCreated":"2019-01-03T15:28:09.812Z","dateModified":"2019-01-03T15:28:18.476Z","contributedBy":"AskGif","content":"<p>In computer science, a priority queue is an abstract data type which is like a regular queue or stack data structure, but where additionally each element has a \"priority\" associated with it. In a priority queue, an element with high priority is served before an element with low priority. In some implementations, if two elements have the same priority, they are served according to the order in which they were enqueued, while in other implementations, ordering of elements with the same priority is undefined.</p>\r\n<p>&nbsp;</p>\r\n<p>While priority queues are often implemented with heaps, they are conceptually distinct from heaps. A priority queue is an abstract concept like \"a list\" or \"a map\"; just as a list can be implemented with a linked list or an array, a priority queue can be implemented with a heap or a variety of other methods such as an unordered array.</p>\r\n<p>&nbsp;</p>\r\n<p>In some situations we may need to find the minimum/maximum element among a collection of elements. WE can do this with the help of Priority Queue ADT. A priority queue ADT is a data structure that supports the operations insert and DeleteMmin (which returns and removes the minimum element) or DeleteMax (which returns and removes the maximum element).</p>\r\n<p>These operations are equivalent ot EnQueue and DeQueue operations of a queue. The difference is that, in priority queues, the order in which the elements enter the queue may not be the same in which they were processed. An exaple application of a priority queue is job schedulig, which is prioritized instead of serving in first come first serve.</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>Applications</p>\r\n<p>Bandwidth management</p>\r\n<p>Priority queuing can be used to manage limited resources such as bandwidth on a transmission line from a network router. In the event of outgoing traffic queuing due to insufficient bandwidth, all other queues can be halted to send the traffic from the highest priority queue upon arrival. This ensures that the prioritized traffic (such as real-time traffic, e.g. an RTP stream of a VoIP connection) is forwarded with the least delay and the least likelihood of being rejected due to a queue reaching its maximum capacity. All other traffic can be handled when the highest priority queue is empty. Another approach used is to send disproportionately more traffic from higher priority queues.</p>\r\n<p>&nbsp;</p>\r\n<p>Many modern protocols for local area networks also include the concept of priority queues at the media access control (MAC) sub-layer to ensure that high-priority applications (such as VoIP or IPTV) experience lower latency than other applications which can be served with best effort service. Examples include IEEE 802.11e (an amendment to IEEE 802.11 which provides quality of service) and ITU-T G.hn (a standard for high-speed local area network using existing home wiring (power lines, phone lines and coaxial cables).</p>\r\n<p>&nbsp;</p>\r\n<p>Usually a limitation (policer) is set to limit the bandwidth that traffic from the highest priority queue can take, in order to prevent high priority packets from choking off all other traffic. This limit is usually never reached due to high level control instances such as the Cisco Callmanager, which can be programmed to inhibit calls which would exceed the programmed bandwidth limit.</p>\r\n<p>&nbsp;</p>\r\n<p>Discrete event simulation</p>\r\n<p>Another use of a priority queue is to manage the events in a discrete event simulation. The events are added to the queue with their simulation time used as the priority. The execution of the simulation proceeds by repeatedly pulling the top of the queue and executing the event thereon.</p>\r\n<p>&nbsp;</p>\r\n<p>See also: Scheduling (computing), queueing theory</p>\r\n<p>&nbsp;</p>\r\n<p>Dijkstra's algorithm</p>\r\n<p>When the graph is stored in the form of adjacency list or matrix, priority queue can be used to extract minimum efficiently when implementing Dijkstra's algorithm, although one also needs the ability to alter the priority of a particular vertex in the priority queue efficiently.</p>\r\n<p>&nbsp;</p>\r\n<p>Huffman coding</p>\r\n<p>Huffman coding requires one to repeatedly obtain the two lowest-frequency trees. A priority queue is one method of doing this.</p>\r\n<p>&nbsp;</p>\r\n<p>Best-first search algorithms</p>\r\n<p>Best-first search algorithms, like the A* search algorithm, find the shortest path between two vertices or nodes of a weighted graph, trying out the most promising routes first. A priority queue (also known as the fringe) is used to keep track of unexplored routes; the one for which the estimate (a lower bound in the case of A*) of the total path length is smallest is given highest priority. If memory limitations make best-first search impractical, variants like the SMA* algorithm can be used instead, with a double-ended priority queue to allow removal of low-priority items.</p>\r\n<p>&nbsp;</p>\r\n<p>ROAM triangulation algorithm</p>\r\n<p>The Real-time Optimally Adapting Meshes (ROAM) algorithm computes a dynamically changing triangulation of a terrain. It works by splitting triangles where more detail is needed and merging them where less detail is needed. The algorithm assigns each triangle in the terrain a priority, usually related to the error decrease if that triangle would be split. The algorithm uses two priority queues, one for triangles that can be split and another for triangles that can be merged. In each step the triangle from the split queue with the highest priority is split, or the triangle from the merge queue with the lowest priority is merged with its neighbours.</p>\r\n<p>&nbsp;</p>\r\n<p>Prim's algorithm for minimum spanning tree</p>\r\n<p>Using min heap priority queue in Prim's algorithm to find the minimum spanning tree of a connected and undirected graph, one can achieve a good running time. This min heap priority queue uses the min heap data structure which supports operations such as insert, minimum, extract-min, decrease-key.[16] In this implementation, the weight of the edges is used to decide the priority of the vertices. Lower the weight, higher the priority and higher the weight, lower the priority.</p>\r\n<p>source: https://en.wikipedia.org/wiki/Priority_queue</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/09a0405d-4490-4161-bb38-f3f69f75356d_Priority-Queue.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"what-is-a-priority-queue","tags":[{"name":"प्रशन","slug":"questions"},{"name":"queue","slug":"queue"},{"name":"Priority-Queue","slug":"priority-queue"},{"name":"algorithm","slug":"algorithm"}],"recommendations":[{"id":1681,"title":"Circular Array Loop - Array - Medium - LeetCode","imageUrl":"icon_32298a91-8bd5-4e63-872d-105103726a20.jpg","dateCreated":"2020-11-19T09:05:08.281Z","dateModified":"2020-11-19T09:05:14.582Z","contributedBy":"sumitc91","content":"You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it's negative (-k), move backward k steps. Since the array is circular, you may assume that the last element's next element is the first element,","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/32298a91-8bd5-4e63-872d-105103726a20.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"circular-array-loop-array-medium-leetcode","total":0},{"id":1632,"title":"Container With Most Water - Array - Medium - LeetCode","imageUrl":"icon_fc25ea42-813c-4de4-be8b-eb874d415c58.jpg","dateCreated":"2020-10-18T15:53:55.445Z","dateModified":"2020-10-18T15:54:07.342Z","contributedBy":"sumitc91","content":"Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the m","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/fc25ea42-813c-4de4-be8b-eb874d415c58.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"मध्यम","slug":"medium"}],"slug":"container-with-most-water-array-medium-leetcode","total":0},{"id":1598,"title":"Find the Town Judge - Tree - Easy - LeetCode","imageUrl":"icon_2f8d0898-e59c-49cd-b25f-5234ed605d94.jpg","dateCreated":"2020-10-14T09:05:56.984Z","dateModified":"2020-10-14T09:06:09.069Z","contributedBy":"sumitc91","content":"In a town, there are N people labelled from 1 to N. &nbsp;There is a rumor that one of these people is secretly the town judge.\nIf the town judge exists, then:\nThe town judge trusts nobody.<br />Everybody (except for the town judge) trusts the town judge.<br />There is exactly one p","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/2f8d0898-e59c-49cd-b25f-5234ed605d94.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"graph","slug":"graph"},{"name":"leetcode","slug":"leetcode"}],"slug":"find-the-town-judge-tree-easy-leetcode","total":0},{"id":1590,"title":"Minimum Distance Between BST Nodes - Tree - Easy - LeetCode","imageUrl":"icon_a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","dateCreated":"2020-10-09T04:46:13.287Z","dateModified":"2020-10-09T04:46:30.726Z","contributedBy":"sumitc91","content":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.\nExample :\nInput: root = [4,2,6,1,3,null,null]<br />Output: 1<br />Explanation:<br />Note that root is a TreeNode object, not an array.</","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a016ac3e-361e-465e-ae63-03484dbf5a66.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-distance-between-bst-nodes-tree-easy-leetcode","total":0}]}