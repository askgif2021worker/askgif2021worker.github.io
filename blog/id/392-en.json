{"id":392,"title":"Coding Standards are Part of Continuous Improvement","imageUrl":"38bb951c-820a-4394-8a28-8040bd6064da_coding-standards-the-way-to-maintainable-code.jpg","dateCreated":"2019-06-14T10:36:54.072Z","dateModified":"2019-06-14T10:37:07.631Z","contributedBy":"AskGif","content":"<p>Coding standards extend to something beyond just code formatters. Coding Standards give team members the same understanding of what's expected of them.&nbsp; Developers spend less time trying to understand code when it's style and operating model look similar across modules and applications. Standards must take into account the range of developer skill set allowing for ongoing improvement from training. It may be that you allow or disallow some feature/approach to reduce the number of defects even if some developers are capable of doing \"more\". Developers like to be free to develop \"in their own fashion\" but management wants the code to have the same shape and look from developer to developer because they care about developer portability across development efforts. Standards can be created that still let developers be creative on interesting problems.</p>\r\n<p>&nbsp;</p>\r\n<p>Automated Standards Support</p>\r\n<p>Tooling can help enforce coding standards by providing constant reminders that there are minimum standards. Teams may wish to have coding standards that are not supported by automated tools but the core standard should be audited on a regular basis. Be sure the standards are adhered to before the code is checked in because you aren't going to have time to fix it later. Java developers have the advantage that their IDEs provide good automated analysis and review. These automated tools find more than just formatting issues.</p>\r\n<p>They find formatting issues that lead to defects down the road and they find actual defects. Tooling should be included in the standard if you can get away with it. Most of my projects have a standard IDE configuration that everyone loads for their Java code. The checks are automatically turned on. You may only use some of the tools on a continuous basis while other tools may be run \"on demand\". The Eclipse formatter/clean-up module is a good continuous tool. The Checkstyle plugin can be configured to only run on saving so it does not impact your build times.</p>\r\n<p>&nbsp;</p>\r\n<p>Code Format</p>\r\n<p>This is the simplest one but causes a surprising amount of conflict on a team.&nbsp; (See \"artist\" comment above. Code formatters help you with this. We basically use the Eclipse style with some changes. The great thing about the Eclipse formatter is that it can also do some code clean up in addition to managing indentation and line wraps. Conditional blocks without curly braces ({}) are defects waiting to happen. You can set up Eclipse so that it automatically adds the curly braces. We force all the developers to use Eclipse and we provide a standard set of preferences that we make everyone load. Eclipse has a setting that will reformat the source on every save so folks can just stream their code into the IDE and hit Save.</p>\r\n<p>&nbsp;</p>\r\n<p>Code Constructs</p>\r\n<p>Internally developed coding standards should focus on avoiding defects. It is best if you pick standards that can be flagged by our automated tools, IDE and plugins. As a first step, go down the list of style warnings flagged by Eclipse and figure out which ones you want to turn on. There may be some conflict here because teams include both experienced and inexperienced developers. Ex: We don't allow ternary operators because of legibility and the way folks overuse</p>\r\n<p>them. Include the documentation settings in this review because you are delivering code for future generations. Some folks claim unit test are documentation and then don't document their complicated unit tests. Set a minimum bar that makes sense. Then go through the better tools/plugins, Checkstyle, PMD and/or Findbugs and take thieir suggestions and add them to your coding conventions. Standards that are supported by tools are the easiest to enforce.</p>\r\n<p>&nbsp;</p>\r\n<p>Application Specific Standards</p>\r\n<p>Applications and architectures develop coding patterns over time. Those coding patterns should be added to the coding standards as they are developed and accepted. A project might use Spring only in a Singleton pattern so you might add that singleton pattern to the coding standard. It may be that an application caches results of some operation based on a hash key so every class that can be a result of that operation needs to implement a custom hashCode() method. This would be added to the coding standard. Basically, every defect that shows up due to a coding error is a candidate to be added to the application specific coding standard. Every tier in the application has these conventions.</p>\r\n<p>&nbsp;</p>\r\n<p>Coding for Testing</p>\r\n<p>Coding Standards are about more than pretty code. They should drive developers to create software structured in a way that meets other requirements like testability. The code takes on a different shape when it is written in a unit testable fashion. Static classes tend to disappear or made pluggable. Methods tend to get smaller and accept more inputs as parameters instead of doing environmental rendezvous with their data. Void methods in controller classes tend to vanish to be replaced by methods that return values to be handled by the callers. Coding standards that include minimum unit testing requirements drive users to create more modular code.</p>\r\n<p>&nbsp;</p>\r\n<p>Non-Java Languages in Java Projects</p>\r\n<p>Coding standards should include non-Java languages including things like XHTML, XML, Javascript, etc. Some of these standards may be supported by automated tools but that is often limited to source formatters. Application specific coding conventions should be included here as well. Example non-format non-Java related standards might be to limit types functions or data in Javascript code or in hidden fields in HTML. Many of the standards will have to be manually enforced, especially for the dynamically typed languages. The lack of good tooling support is one of the biggest reasons that teams often keep scripting or dynamic language usage to a minimum in large projects. Small teams full of really smart people will tell you that they are more efficient with these languages but it is very hard to create standard, readable code that can be handed off from one generation to the next of developer on the project.</p>\r\n<p>&nbsp;</p>\r\n<p>Standards Verification</p>\r\n<p>The team motto should be \"Trust but Verify\". Run tools in the IDE. Cover coding standards in code reviews and training. Then measure your progress with a tool like Sonar. It will run all of the automated tools described elsewhere in this document and track the progress over time. It has a web interface that lets you drill down by package and class and see where you are having compliance issues, coding problems or poor unit test coverage. Metrics can help a team</p>\r\n<p>improve their game without a lot of manual intervention.</p>\r\n<p>&nbsp;</p>\r\n<p>Training</p>\r\n<p>Training is required whenever a team changes a policy or method of operation.&nbsp; Coding standards will result in changes for many users so training will be mandatory. Some teams send out the coding standards and then assume everyone is OK with them when no one complains. Zero complaints mean they didn't read it or that they don't think the company is serious. Teams must do at least one</p>\r\n<p>walkthrough of the different sections of any standards. Training should almost always result in standards updates, clarifications or additions.&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>Final</p>\r\n<p>Coding standards can really help keep a code base together and set expectations for new and existing team members. Teams should expand the concept of a coding standard beyond naming and formatting and include all the standardized behavior and style that they want in their code base. Standards should be reevaluated whenever a new type of subsystem is written or a new 3rd party library included. The organization is the key to repeatable success and lower defect counts.</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/38bb951c-820a-4394-8a28-8040bd6064da_coding-standards-the-way-to-maintainable-code.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"coding-standards-are-part-of-continuous-improvement","tags":[{"name":"testing","slug":"testing"},{"name":"automation-framework","slug":"automation-framework"}],"recommendations":[{"id":412,"title":"Start your web tests with Selenium2, Maven, Testng","imageUrl":"c65bd914-66cf-4345-bcdb-736cf283ec69_selenium-maven.jpg","dateCreated":"2019-06-26T07:00:11.515Z","dateModified":"2019-06-26T07:02:44.098Z","contributedBy":"AskGif","content":"Every time you are playing around with web tests you think: why have I waited so long. Doesn&rsquo;t matter, you have done it and that&rsquo;s it what matters.\r\n&nbsp;\r\nThe last time I used Selenium 1 which is very often used for web tests. Selenium 1 is great but has a few limitati","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/c65bd914-66cf-4345-bcdb-736cf283ec69_selenium-maven.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"java","slug":"java"},{"name":"testing","slug":"testing"},{"name":"maven","slug":"maven"},{"name":"test","slug":"test"},{"name":"selenium","slug":"selenium"}],"slug":"start-your-web-tests-with-selenium2-maven-testng","total":0},{"id":392,"title":"Coding Standards are Part of Continuous Improvement","imageUrl":"38bb951c-820a-4394-8a28-8040bd6064da_coding-standards-the-way-to-maintainable-code.jpg","dateCreated":"2019-06-14T10:36:54.072Z","dateModified":"2019-06-14T10:37:07.631Z","contributedBy":"AskGif","content":"Coding standards extend to something beyond just code formatters. Coding Standards give team members the same understanding of what's expected of them.&nbsp; Developers spend less time trying to understand code when it's style and operating model look similar across modules and applications. Stan","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/38bb951c-820a-4394-8a28-8040bd6064da_coding-standards-the-way-to-maintainable-code.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"testing","slug":"testing"},{"name":"automation-framework","slug":"automation-framework"}],"slug":"coding-standards-are-part-of-continuous-improvement","total":0},{"id":57,"title":"Key Features of Automation Framework","imageUrl":"afb8af39-0840-4657-b903-26591e9c3b8d_automation.gif","dateCreated":"2018-07-30T14:58:57.992Z","dateModified":"2018-07-30T14:59:07.237Z","contributedBy":"AskGif","content":"In the modern software industry, Automation is becoming a must-have feature for the testing teams to quickly test and certify builds and find the bugs. To achieve the above criterion, a good automation framework is required. Now, what do we mean by a good automation framework? Let me quickly guid","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/afb8af39-0840-4657-b903-26591e9c3b8d_automation.gif","category":{"name":"coding","slug":"coding"},"tags":[{"name":"automation-framework","slug":"automation-framework"},{"name":"interview","slug":"interview"},{"name":"testing","slug":"testing"}],"slug":"key-features-of-automation-framework","total":0}]}