{"id":406,"title":"Nginx Reverse Proxy to ASP.NET Core In Separate Docker Containers","imageUrl":"449e862c-42ac-4a0f-9de9-cc740bd72632_docker-kestral.jpg","dateCreated":"2019-06-25T02:38:46.733Z","dateModified":"2019-06-26T08:33:11.276Z","contributedBy":"AskGif","content":"<p>The <a title=\"Nginx Reverse Proxy to ASP.NET Core &ndash; In Same Docker Container\" href=\"../../../../blog/405/nginx-reverse-proxy-to-asp-net-core-in-same-docker-container/\" target=\"_blank\" rel=\"noopener\">previous blog post (Nginx Reverse Proxy to ASP.NET Core &ndash; In Same Docker Container)</a> showed how to set up a reverse proxy between Nginx and an ASP.NET Core application. In that example, both Nginx and the Kestrel process ran in the same box.</p>\r\n<p>&nbsp;</p>\r\n<p>As alluded to, there is another (preferable) option. This time, we&rsquo;ll create two separate containers: one for the application and one for the reverse proxy. Then we&rsquo;ll use Docker compose to bring them up together and handle the network bridge between them.</p>\r\n<p>&nbsp;</p>\r\n<p>Directory setup</p>\r\n<p>This example will use a slightly different directory structure than the previous examples. The final directory structure should look something like this:</p>\r\n<pre class=\"language-markup\"><code>example\r\n|- app\r\n|- |- Controllers\r\n|- |- Models\r\n|- |- ...\r\n|- |- Dockerfile\r\n|- nginx\r\n|- |- Dockerfile\r\n|- |- nginx.conf\r\n|- docker-compose.yml</code></pre>\r\n<p>To get started, let&rsquo;s create the basic directory structure, generate the application, and build it:</p>\r\n<pre class=\"language-markup\"><code>mkdir example\r\nmkdir example\\app\r\nmkdir example\\nginx\r\n\r\ncd example\\app\r\ndotnet new -t web\r\ndotnet restore\r\ndotnet build\r\ndotnet publish</code></pre>\r\n<p>Docker configuration</p>\r\n<p>The Docker setup this time will involve two separate Docker containers. A Docker Compose configuration will join the two together.</p>\r\n<p>&nbsp;</p>\r\n<p>Docker Compose</p>\r\n<p>Docker Compose is used to run multi-container Docker applications. Through a docker-compose.yml file, you configure multiple application containers. Then you can build and run the composite collection of containers (similar to how you would an individual container).</p>\r\n<p>&nbsp;</p>\r\n<p>For this example, create a docker-compose.yml file in the root directory. Place this configuration inside of the file:</p>\r\n<pre class=\"language-markup\"><code>version: '2'\r\n \r\nservices:\r\n  app:\r\n    build:\r\n      context:  ./app\r\n      dockerfile: Dockerfile\r\n    expose:\r\n      - \"5000\"\r\n \r\n  proxy:\r\n    build:\r\n      context:  ./nginx\r\n      dockerfile: Dockerfile\r\n    ports:\r\n      - \"80:80\"\r\n    links:\r\n      - app</code></pre>\r\n<p>That configuration defines two services: app and proxy.</p>\r\n<p>&nbsp;</p>\r\n<p>For each service, the build section tells Docker Compose how to build each of the individual images when the enter collection is built.</p>\r\n<p>&nbsp;</p>\r\n<p>The expose and ports sections control the way the services will interact with the network bridge and the host (see the &ldquo;Network&rdquo; section below).</p>\r\n<p>&nbsp;</p>\r\n<p>Lastly, the proxy service is linked to the app service. That means that when the proxy service is brought up it will start the app service (if it is not already running).</p>\r\n<p>&nbsp;</p>\r\n<p>Application container</p>\r\n<p>Create a Dockerfile in the app directory with the following content:</p>\r\n<pre class=\"language-markup\"><code>FROM microsoft/aspnetcore:1.0\r\n \r\nWORKDIR /app\r\nCOPY bin/Debug/netcoreapp1.0/publish .\r\n \r\nENV ASPNETCORE_URLS http://+:5000\r\nEXPOSE 5000\r\n \r\nENTRYPOINT [\"dotnet\", \"app.dll\"]</code></pre>\r\n<p>That configuration will bring up the ASP.NET Core application using Kestrel. The Kestrel process will listen on port 5000 (which will be exposed to the outside world).</p>\r\n<p>&nbsp;</p>\r\n<p>Nginx container</p>\r\n<p>Create a Dockerfile in the nginx directory. The Nginx image will use the base nginx image and copy a custom nginx.conf file into it:</p>\r\n<pre class=\"language-markup\"><code>FROM nginx\r\nCOPY nginx.conf /etc/nginx/nginx.conf</code></pre>\r\n<p>The nginx.conf file is fairly similar to the previous example. It&rsquo;s contents are:</p>\r\n<pre class=\"language-markup\"><code>worker_processes 4;\r\n \r\nevents { worker_connections 1024; }\r\n \r\nhttp {\r\n    sendfile on;\r\n \r\n    upstream app_servers {\r\n        server app:5000;\r\n    }\r\n \r\n    server {\r\n        listen 80;\r\n \r\n        location / {\r\n            proxy_pass         http://app_servers;\r\n            proxy_redirect     off;\r\n            proxy_set_header   Host $host;\r\n            proxy_set_header   X-Real-IP $remote_addr;\r\n            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\r\n            proxy_set_header   X-Forwarded-Host $server_name;\r\n        }\r\n    }\r\n}</code></pre>\r\n<p>The only change from the previous example is on line 9. The previous example used an address of 127.0.0.1:5000 for the upstream app server. This time it specifies app:5000. That app is a named resource that was specified in the docker-compose.yml file.</p>\r\n<p>&nbsp;</p>\r\n<p>The name used to define the upstream resources must match the name used for the service in the docker-compose.yml file.</p>\r\n<p>&nbsp;</p>\r\n<p>Building the collection</p>\r\n<p>To build the collection, we&rsquo;ll use docker-compose. The build command will build each of the services and then tag each container with the project name and the service name.</p>\r\n<pre class=\"language-markup\"><code>docker-compose build</code></pre>\r\n<p>Running the collection</p>\r\n<p>To run the collection of containers:</p>\r\n<pre class=\"language-markup\"><code>docker-compose up</code></pre>\r\n<p>For this example, the application will be available at http://localhost:80. Accessing the application there will make a request to the Nginx service which will be proxied to the application service.</p>\r\n<p>&nbsp;</p>\r\n<p>While running, the output for all contains are aggregated and intermingled. The following example output shows messages from both the app_1 and proxy_1 containers:</p>\r\n<pre class=\"language-markup\"><code>app_1    | info: Microsoft.AspNetCore.Hosting.Internal.WebHost[2]\r\napp_1    |       Request finished in 3342.2438ms 200 text/html; charset=utf-8\r\nproxy_1  | 172.20.0.1 - - [24/Feb/2017:17:45:26 +0000] \"GET / HTTP/1.1\" 200 2490 \"-\" \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\"</code></pre>\r\n<p>Networking</p>\r\n<p>Lastly, let&rsquo;s briefly explore how the networking of this collection functions. When the collection is brought up, a shared network bridge is created. This bridge allows the services within the collection to communicate with one another.</p>\r\n<p>&nbsp;</p>\r\n<p>There are two ways to expose network connections from service to the bridge:</p>\r\n<p>&nbsp;</p>\r\n<p>ports &ndash; This setting exposes the named ports within the bridge network. It also publishes the ports to the host machine.</p>\r\n<p>expose &ndash; That setting exposes the named ports within the bridge. Unlike ports, however, the named ports are not published to the host machine.</p>\r\n<p>For example, the app service in the configuration specifies 5000 through the expose setting. That exposes port 5000 of the app service to the bridge network only.</p>\r\n<p>&nbsp;</p>\r\n<p>The proxy service, on the other hand, specifies 80:80 for the ports setting. That exposes port 80 of the app service to the bridge network and publishes port 80 to the host machine.</p>\r\n<p>&nbsp;</p>\r\n<p>Running docker network ls shows the created bridge:</p>\r\n<pre class=\"language-markup\"><code>NETWORK ID          NAME                                 DRIVER              SCOPE\r\ne942ad5d12ab        bridge                               bridge              local\r\neb2fa8b3109c        host                                 host                local\r\n7655823d3523        none                                 null                local\r\n45a51b60efbd        example_default                      bridge              local</code></pre>\r\n<p>Examining the containers through docker ps will show the effects:</p>\r\n<pre class=\"language-markup\"><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES\r\ndddf78732098        example_proxy       \"nginx -g 'daemon ...\"   15 seconds ago      Up 14 seconds       0.0.0.0:80-&gt;80/tcp, 443/tcp   example_proxy_1\r\ne52b4a3c63cb        example_app         \"dotnet app.dll\"         16 seconds ago      Up 15 seconds       5000/tcp                      example_app_1</code></pre>\r\n<p>That means that the proxy service will be accessible at http://localhost:80 but the app service will not be directly reachable at http://localhost:5000. So, the only way to access the application is through the proxy service.</p>\r\n<p>&nbsp;</p>\r\n<p>Next time?</p>\r\n<p>In the <a title=\"Implementing Load Balancer with Nginx and Docker\" href=\"../../../../../blog/407/implementing-load-balancer-with-nginx-and-docker/\" target=\"_blank\" rel=\"noopener\">next post (Implementing Load Balancer with Nginx and Docker)</a>, I&rsquo;ll show how to set up basic load balancing using Nginx and Docker Compose. Stay tuned&hellip;</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/449e862c-42ac-4a0f-9de9-cc740bd72632_docker-kestral.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"nginx-reverse-proxy-to-asp.net-core-in-separate-docker-containers","tags":[{"name":"docker","slug":"docker"},{"name":"dotnet-core","slug":"dotnet-core"},{"name":"nginx","slug":"nginx"}],"recommendations":[{"id":702,"title":"Pushing and Pulling to and from Docker Hub","imageUrl":"8f5fb6c4-3070-4ce0-a3a9-ea0070a3fc7c_docker.jpg","dateCreated":"2019-09-18T10:49:21.559Z","dateModified":"2019-09-18T10:49:34.746Z","contributedBy":"AskGif","content":"Docker is a set of platform-as-a-service (PaaS) products that use OS-level virtualization to deliver software in packages called containers. Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8f5fb6c4-3070-4ce0-a3a9-ea0070a3fc7c_docker.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"docker","slug":"docker"}],"slug":"pushing-and-pulling-to-and-from-docker-hub","total":0},{"id":407,"title":"Implementing Load Balancer with Nginx and Docker","imageUrl":"3f9f65bf-4674-4c33-9b20-c454378b960d_UDP-Load-Balancing-R9.jpg","dateCreated":"2019-06-25T02:53:26.711Z","dateModified":"2019-06-25T03:04:11.874Z","contributedBy":"AskGif","content":"The <a title=\"Nginx Reverse Proxy to ASP.NET Core &ndash; In Separate Docker Containers\" href=\"../../../../../blog/406/nginx-reverse-proxy-to-asp-net-core-in-separate-docker-containers/\" target=\"_blank\" rel=\"noopener\">previous post (Nginx Reverse Proxy to ASP.NET Core &ndash; In Separate Docker C","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/3f9f65bf-4674-4c33-9b20-c454378b960d_UDP-Load-Balancing-R9.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"dotnet-core","slug":"dotnet-core"},{"name":"load-balancing","slug":"load-balancing"},{"name":"docker","slug":"docker"},{"name":"nginx","slug":"nginx"}],"slug":"implementing-load-balancer-with-nginx-and-docker","total":0},{"id":405,"title":"Nginx Reverse Proxy to ASP.NET Core In Same Docker Container","imageUrl":"851b560d-0263-4e5d-9426-f7dad119ba6c_target-architecture-docker-nginx-ketrel.png","dateCreated":"2019-06-25T02:25:00.552Z","dateModified":"2019-06-26T08:34:17.75Z","contributedBy":"AskGif","content":"As mentioned in the <a title=\"Hosting ASP.NET Core in Docker\" href=\"../../../../blog/404/hosting-asp-net-core-in-docker/\" target=\"_blank\" rel=\"noopener\">previous post (Hosting ASP.NET Core in Docker)</a>, it is recommended to use something other than Kestrel as the front-line web server. In this ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/851b560d-0263-4e5d-9426-f7dad119ba6c_target-architecture-docker-nginx-ketrel.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"nginx","slug":"nginx"},{"name":"dotnet-core","slug":"dotnet-core"},{"name":"asp-dot-net","slug":"asp-dot-net"},{"name":"docker","slug":"docker"}],"slug":"nginx-reverse-proxy-to-asp.net-core-in-same-docker-container","total":0},{"id":5,"title":"मैं AWS EC2 Ubuntu 16.04 मशीन पर Nginx कैसे स्थापित कर सकता हूं और एकाधिक वेबसाइट होस्ट करता हूं।","imageUrl":"78354fdb-9e8d-43be-a51a-75dc508974e5_NGINX-On-Ubuntu-1200x1200.jpg","dateCreated":"2018-07-02T12:43:39.373Z","dateModified":"2018-07-02T16:12:00.428Z","contributedBy":"AskGif","content":" Nginx (/ ˌɛndʒɪnɛks / EN-jin-EKS [8]) (एनजीआईएनएक्स, एनजीआईएक्सएक्स या एनजिनक्स के रूप में शैलीबद्ध) एक वेब सर्वर है जिसे रिवर्स प्रॉक्सी, लोड बैलेंसर, मेल प्रॉक्सी और HTTP कैश के रूप में भी इस्तेमाल किया जा सकता है। सॉफ्टवेयर इगोर सिसोव द्वारा बनाया गया था और पहली बार 2004 में सार्वजनिक रूप से ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/78354fdb-9e8d-43be-a51a-75dc508974e5_NGINX-On-Ubuntu-1200x1200.jpg","category":{"name":"शिक्षण","slug":"tutorials"},"tags":[{"name":"EC2","slug":"ec2"},{"name":"nginx","slug":"nginx"},{"name":"ubuntu","slug":"ubuntu"}],"slug":"how-can-i-install-nginx-on-aws-ec2-ubuntu-16.04-machine-and-host-multiple-websites","total":0}]}