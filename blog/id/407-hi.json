{"id":407,"title":"Implementing Load Balancer with Nginx and Docker","imageUrl":"3f9f65bf-4674-4c33-9b20-c454378b960d_UDP-Load-Balancing-R9.jpg","dateCreated":"2019-06-25T02:53:26.711Z","dateModified":"2019-06-25T03:04:11.874Z","contributedBy":"AskGif","content":"<p>The <a title=\"Nginx Reverse Proxy to ASP.NET Core &ndash; In Separate Docker Containers\" href=\"../../../../../blog/406/nginx-reverse-proxy-to-asp-net-core-in-separate-docker-containers/\" target=\"_blank\" rel=\"noopener\">previous post (Nginx Reverse Proxy to ASP.NET Core &ndash; In Separate Docker Containers)</a> showed how to use Nginx as a reverse proxy to an ASP.NET Core application running in a separate Docker container. This time, I&rsquo;ll show how to use a similar configuration to spin up multiple application containers and use Nginx as a load balancer to spread traffic over them.</p>\r\n<p>&nbsp;</p>\r\n<p>Desired architecture</p>\r\n<p>The architecture we&rsquo;re looking for is to have four application servers running in separate Docker containers. In front of those application servers, there will be a single Nginx server. That Nginx server will reverse proxy to the application servers and will load balance using a round-robin methodology.</p>\r\n<p>Example Application</p>\r\n<p>This example uses the same application and directory structure as the previous example.</p>\r\n<p>&nbsp;</p>\r\n<p>Docker Compose Configuration</p>\r\n<p>The configuration file for Docker compose remains exactly the same as in the previous example.</p>\r\n<pre class=\"language-markup\"><code>version: '2'\r\n \r\nservices:\r\n  app:\r\n    build:\r\n      context:  ./app\r\n      dockerfile: Dockerfile\r\n    expose:\r\n      - \"5000\"\r\n \r\n  proxy:\r\n    build:\r\n      context:  ./nginx\r\n      dockerfile: Dockerfile\r\n    ports:\r\n      - \"80:80\"\r\n    links:\r\n      - app</code></pre>\r\n<p>So, while we will eventually end up with four running instances of the app service, it only needs to be defined within the docker-compose.yml file once.</p>\r\n<p>&nbsp;</p>\r\n<p>Nginx Configuration</p>\r\n<p>The first thing we&rsquo;ll need to update is the Nginx configuration. Instead of a single upstream server, we now need to define four of them.</p>\r\n<p>&nbsp;</p>\r\n<p>When updated, the nginx.conf file should look like the following:</p>\r\n<pre class=\"language-markup\"><code>worker_processes 4;\r\n \r\nevents { worker_connections 1024; }\r\n \r\nhttp {\r\n    sendfile on;\r\n \r\n    upstream app_servers {\r\n        server example_app_1:5000;\r\n        server example_app_2:5000;\r\n        server example_app_3:5000;\r\n        server example_app_4:5000;\r\n    }\r\n \r\n    server {\r\n        listen 80;\r\n \r\n        location / {\r\n            proxy_pass         http://app_servers;\r\n            proxy_redirect     off;\r\n            proxy_set_header   Host $host;\r\n            proxy_set_header   X-Real-IP $remote_addr;\r\n            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\r\n            proxy_set_header   X-Forwarded-Host $server_name;\r\n        }\r\n    }\r\n}</code></pre>\r\n<p>With this configuration, the reverse proxy defined with proxy-pass will use each of the defined upstream application servers. The requests will be passed between them in a round-robin fashion.</p>\r\n<p>&nbsp;</p>\r\n<p>Starting the services</p>\r\n<p>The first thing we need to do is build the collection of services:</p>\r\n<pre class=\"language-markup\"><code>docker-compose build</code></pre>\r\n<p>Before bringing up the services, we need to tell Docker to bring multiple instances of the app service online. The Nginx configuration used four instances of the application, so we need to set the number of containers for that service to four as well.</p>\r\n<pre class=\"language-markup\"><code>docker-compose scale app=4</code></pre>\r\n<p>You should see each service starting</p>\r\n<pre class=\"language-markup\"><code>Starting example_app_1 ... done\r\nStarting example_app_2 ... done\r\nStarting example_app_3 ... done\r\nStarting example_app_4 ... done</code></pre>\r\n<p>Now you can bring up all of the services</p>\r\n<pre class=\"language-markup\"><code>docker-compose up</code></pre>\r\n<p>Testing the load balancer</p>\r\n<p>Let&rsquo;s navigate to the site at http://localhost:80. We can look at the output from the services to see that the requests are being split across multiple application service instances.</p>\r\n<pre class=\"language-markup\"><code>proxy_1  | 172.20.0.1 - - [24/Feb/2017:18:59:39 +0000] \"GET / HTTP/1.1\" 200 2490 \"-\" \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\"\r\napp_3    | info: Microsoft.AspNetCore.Hosting.Internal.WebHost[1]\r\napp_3    |       Request starting HTTP/1.0 GET http://localhost/js/site.min.js?v=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU\r\napp_2    | info: Microsoft.AspNetCore.Hosting.Internal.WebHost[1]\r\napp_2    |       Request starting HTTP/1.0 GET http://localhost/css/site.min.css?v=78TaBTSGdek5nF1RDwBLOnz-PHnokB0X5pwQZ6rE9ZA\r\napp_3    | info: Microsoft.AspNetCore.StaticFiles.StaticFileMiddleware[6]\r\napp_3    |       The file /js/site.min.js was not modified\r\napp_3    | info: Microsoft.AspNetCore.Hosting.Internal.WebHost[2]\r\napp_3    |       Request finished in 97.6534ms 304 application/javascript\r\napp_2    | info: Microsoft.AspNetCore.StaticFiles.StaticFileMiddleware[2]\r\napp_2    |       Sending file. Request path: '/css/site.min.css'. Physical path: '/app/wwwroot/css/site.min.css'\r\nproxy_1  | 172.20.0.1 - - [24/Feb/2017:18:59:39 +0000] \"GET /js/site.min.js?v=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU HTTP/1.1\" 304 0 \"http://localhost/\" \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\"\r\nproxy_1  | 172.20.0.1 - - [24/Feb/2017:18:59:39 +0000] \"GET /css/site.min.css?v=78TaBTSGdek5nF1RDwBLOnz-PHnokB0X5pwQZ6rE9ZA HTTP/1.1\" 200 251 \"http://localhost/\" \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\"</code></pre>\r\n<p>&nbsp;</p>\r\n<p>In that output, you can see that the app_1, app_2, and app_3 instances were all to responding to requests.</p>\r\n<p>&nbsp;</p>\r\n<p>Further scaling</p>\r\n<p>For the purpose of this blog series, I think I intend to stop at this scaling capability level.</p>\r\n<p>&nbsp;</p>\r\n<p>If you find you need to scale beyond what you can easily accomplish with Nginx, there are a couple of good options to look into.</p>\r\n<p>&nbsp;</p>\r\n<p><a title=\"https://www.docker.com/products/orchestration\" href=\"https://www.docker.com/products/orchestration\" target=\"_blank\" rel=\"noopener\">Docker Swarm</a> provides a facade projecting multiple clustered Docker engines as a single engine. The tooling and infrastructure will feel similar to the other Docker tooling you will have used.</p>\r\n<p>&nbsp;</p>\r\n<p>A more extensive option would be to use <a title=\"https://kubernetes.io/\" href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener\">Kubernetes</a>. That system is designed for automated deployment and scaling. It does provide a good toolset for massive scaling. But, it involves quite a bit of complexity in creating and managing your clustered services.</p>\r\n<p>&nbsp;</p>\r\n<p>Either option could serve you well. Before picking up either option, I&rsquo;d first make sure the scaling needs of the application really warrant the added complexity.</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/3f9f65bf-4674-4c33-9b20-c454378b960d_UDP-Load-Balancing-R9.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"implementing-load-balancer-with-nginx-and-docker","tags":[{"name":"dotnet-core","slug":"dotnet-core"},{"name":"load-balancing","slug":"load-balancing"},{"name":"docker","slug":"docker"},{"name":"nginx","slug":"nginx"}],"recommendations":[{"id":405,"title":"Nginx Reverse Proxy to ASP.NET Core In Same Docker Container","imageUrl":"851b560d-0263-4e5d-9426-f7dad119ba6c_target-architecture-docker-nginx-ketrel.png","dateCreated":"2019-06-25T02:25:00.552Z","dateModified":"2019-06-26T08:34:17.75Z","contributedBy":"AskGif","content":"As mentioned in the <a title=\"Hosting ASP.NET Core in Docker\" href=\"../../../../blog/404/hosting-asp-net-core-in-docker/\" target=\"_blank\" rel=\"noopener\">previous post (Hosting ASP.NET Core in Docker)</a>, it is recommended to use something other than Kestrel as the front-line web server. In this ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/851b560d-0263-4e5d-9426-f7dad119ba6c_target-architecture-docker-nginx-ketrel.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"nginx","slug":"nginx"},{"name":"dotnet-core","slug":"dotnet-core"},{"name":"asp-dot-net","slug":"asp-dot-net"},{"name":"docker","slug":"docker"}],"slug":"nginx-reverse-proxy-to-asp.net-core-in-same-docker-container","total":0},{"id":183,"title":"What is the difference between .NET Core and .NET Standard Class Library project types?","imageUrl":"45fbb4c6-4033-4912-ba36-20ef79898f70_netcore-vs-netstandard.png","dateCreated":"2018-12-24T09:11:03.982Z","dateModified":"2018-12-24T09:11:14.257Z","contributedBy":"AskGif","content":"Question:\r\nIn Visual Studio, there are at least 3 different types of class library you can create:\r\n&nbsp;\r\nClass Library (.NET Framework)\r\nClass Library (.NET Standard)\r\nClass Library (.NET Core)\r\nWhile the first is what we've been using for years, a maj","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/45fbb4c6-4033-4912-ba36-20ef79898f70_netcore-vs-netstandard.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"dot-net-standard","slug":"dot-net-standard"},{"name":"dot-net","slug":"dot-net"},{"name":"class-library","slug":"class-library"},{"name":"dotnet-core","slug":"dotnet-core"}],"slug":"what-is-the-difference-between-.net-core-and-.net-standard-class-library-project-types","total":0},{"id":154,"title":"How to Install Trusted Root Certificates in DotNet Core on Ubuntu","imageUrl":"bea83dd0-4470-4f94-999e-5fdaf3ecf45e_https-and-self-signed-certificates-with-asp-net-core.png","dateCreated":"2018-11-23T05:46:44.431Z","dateModified":"2018-11-23T05:47:22.15Z","contributedBy":"AskGif","content":"Question :\r\nI'm getting an issue while deploying a .net-core web-API to a Docker container on Ubuntu. Everything works as expected, but from my application, I need to call other services via https and those hosts use certificates signed by self-maintained root certificates.\r\n&nbsp;<","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/bea83dd0-4470-4f94-999e-5fdaf3ecf45e_https-and-self-signed-certificates-with-asp-net-core.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"ubuntu","slug":"ubuntu"},{"name":"ssl","slug":"ssl"},{"name":"dotnet-core","slug":"dotnet-core"}],"slug":"how-to-install-trusted-root-certificates-in-dotnet-core-on-ubuntu","total":0},{"id":5,"title":"मैं AWS EC2 Ubuntu 16.04 मशीन पर Nginx कैसे स्थापित कर सकता हूं और एकाधिक वेबसाइट होस्ट करता हूं।","imageUrl":"78354fdb-9e8d-43be-a51a-75dc508974e5_NGINX-On-Ubuntu-1200x1200.jpg","dateCreated":"2018-07-02T12:43:39.373Z","dateModified":"2018-07-02T16:12:00.428Z","contributedBy":"AskGif","content":" Nginx (/ ˌɛndʒɪnɛks / EN-jin-EKS [8]) (एनजीआईएनएक्स, एनजीआईएक्सएक्स या एनजिनक्स के रूप में शैलीबद्ध) एक वेब सर्वर है जिसे रिवर्स प्रॉक्सी, लोड बैलेंसर, मेल प्रॉक्सी और HTTP कैश के रूप में भी इस्तेमाल किया जा सकता है। सॉफ्टवेयर इगोर सिसोव द्वारा बनाया गया था और पहली बार 2004 में सार्वजनिक रूप से ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/78354fdb-9e8d-43be-a51a-75dc508974e5_NGINX-On-Ubuntu-1200x1200.jpg","category":{"name":"शिक्षण","slug":"tutorials"},"tags":[{"name":"EC2","slug":"ec2"},{"name":"nginx","slug":"nginx"},{"name":"ubuntu","slug":"ubuntu"}],"slug":"how-can-i-install-nginx-on-aws-ec2-ubuntu-16.04-machine-and-host-multiple-websites","total":0}]}