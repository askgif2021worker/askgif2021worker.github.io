{"id":416,"title":"Implementing .NET Core Logging Levels and Categories","imageUrl":"29427d9e-f158-40f8-ae73-be3429828ba1_NET-Core-Log-Factory.jpg","dateCreated":"2019-08-05T11:33:46.631Z","dateModified":"2019-08-05T11:34:06.076Z","contributedBy":"AskGif","content":"<p>In .NET Core. One thing that I never implemented was granular control of logging specific levels by category. It turns out that it&rsquo;s pretty easy to do, though. Logging in .NET Core passes LogLevel and Category whenever something is to be logged. Category corresponds, afaik, to namespaces. You can see this in the default Console based logger configuration provided by the standard Visual Studio .NET Core templates:</p>\r\n<pre class=\"language-csharp\"><code>\"Logging\": {\r\n  \"IncludeScopes\": false,\r\n  \"LogLevel\": {\r\n    \"Default\": \"Debug\",\r\n    \"System\": \"Information\",\r\n    \"Microsoft\": \"Information\"\r\n  }\r\n}</code></pre>\r\n<p>Also, as far as I know, these settings refer to &ldquo;minimum&rdquo; log levels. Whenever log messages are passed to a logger, a filter is checked to determine if the message should be logged. You can see in my previous post, that I always return &ldquo;true&rdquo; which means everything is logged. Later, I implemented the concept of a single minimum level, but this isn&rsquo;t overly useful since .NET Core logs a ton of messages that, really, are framework diagnostics from the Microsoft/System namespaces.</p>\r\n<p>&nbsp;</p>\r\n<p>The minimum level I implemented that I had implemented in the Logger looks like this:</p>\r\n<pre class=\"language-csharp\"><code>public bool IsEnabled(LogLevel logLevel)\r\n{\r\n    return (_filter == null || _filter(_categoryName, logLevel));\r\n}</code></pre>\r\n<p>Where the filter is a simple Func&lt;string, LogLevel, bool&gt;</p>\r\n<p>&nbsp;</p>\r\n<p>return logLevel != LogLevel.None &amp;&amp; logLevel &gt;= matchedCategory.MinLevel;</p>\r\n<p>&nbsp;</p>\r\n<p>Notice how I don&rsquo;t inspect Category. There is no built-in nice feature for granular logging as the Console logger. But, it is pretty easy to implement.</p>\r\n<p>&nbsp;</p>\r\n<p>Following the pattern that the Console-based logger uses, I create this section in my appsettings.json:</p>\r\n<pre class=\"language-csharp\"><code>\"MyLoggingSettings\": {\r\n  \"ConnectionStringName\": \"Logging\",\r\n  \"LogLevels\": [\r\n    {\r\n      \"Namespace\": \"Application\",\r\n      \"MinLevel\": \"Debug\",\r\n      \"Levels\": [\r\n        \"Debug\",\r\n        \"Error\"\r\n      ]\r\n    },\r\n    {\r\n      \"Namespace\": \"Microsoft\",\r\n      \"Levels\": [\r\n        \"Information\",\r\n        \"Error\"\r\n      ]\r\n    },\r\n    {\r\n      \"Namespace\": \"System\",\r\n      \"Levels\": [\r\n        \"Debug\",\r\n        \"Information\",\r\n        \"Error\"\r\n      ]\r\n    }\r\n  ]\r\n}</code></pre>\r\n<p>Remember that I mentioned that the Namespace is synonymous with Category? That&rsquo;s why you&rsquo;ll see the key to the array of objects is Namespace. The class that I will map these settings to is, then, pretty simple. A List&lt;AppLogLevel&gt; is populated along with the connections string name.</p>\r\n<pre class=\"language-csharp\"><code>public class AppLogLevel\r\n{\r\n    public string Name { get; set; } = \"Application\";\r\n    public LogLevel MinLevel { get; set; } = LogLevel.Debug;\r\n    public List&lt;LogLevel&gt; Levels { get; set; } = new List&lt;LogLevel&gt;();\r\n}\r\n \r\npublic class AppLoggingSettings\r\n{\r\n    public string ConnectionStringName{ get; set; } = \"Logging\";\r\n    public List&lt;AppLogLevel&gt; LogLevels { get; set; } = new List&lt;AppLogLevel&gt;();\r\n}</code></pre>\r\n<p>In the ConfigureServices section of my Startup.cs, I populate the settings, instantiate the settings object, and pass the connection string name into the extension method that creates the AppLoggerProvider:</p>\r\n<pre class=\"language-csharp\"><code>// Make configuration settings available\r\nservices.Configure&lt;AppLoggingSettings&gt;(Configuration.GetSection(\"MyLoggingSettings\"));\r\nservices.AddSingleton&lt;IConfiguration&gt;(Configuration);\r\n \r\nvar loggingSettings = new AppLoggingSettings();\r\nConfiguration.GetSection(\"MyLoggingSettings\").Bind(loggingSettings);\r\n \r\n// Add logging\r\nservices.AddLogger(Configuration.GetConnectionString(loggingSettings.ConnectionStringName));\r\n</code></pre>\r\n<p>In the Configure method of Startup.cs, the UseLogger method is called passing the Console configuration and the ApplicationName:</p>\r\n<pre class=\"language-csharp\"><code>// Use logger\r\napp.UseLogger(Configuration.GetSection(\"Logging\"), appSettings.ApplicationName);\r\n</code></pre>\r\n<p>Since the extension methods for AddLogger/UseLogger have changed significantly, the Extension methods are below. You can see that the AddLogger method is adding the DbContext and the IRepository. The key change here is that the &ldquo;AddProvider&rdquo; method, which instantiates the AppLoggerProvider and attaches it to the ServiceProvider, has the AppLoggingSettings passed into it.</p>\r\n<pre class=\"language-csharp\"><code>public static class Extensions\r\n{\r\n    public static void AddLogger(this IServiceCollection services, string loggingConnStr)\r\n    {\r\n        services.AddTransient&lt;IRepository&lt;AppLogModel&gt;, AppLogRepository&gt;();\r\n \r\n        // Logging context must be transient..\r\n        services.AddDbContext&lt;AppLogContext&gt;(options =&gt;\r\n        {\r\n            options.UseSqlServer(loggingConnStr);\r\n            options.UseLoggerFactory(null);\r\n        }, ServiceLifetime.Transient);\r\n    }\r\n \r\n    /// &lt;summary&gt;\r\n    /// Use the logger\r\n    /// &lt;/summary&gt;\r\n    /// &lt;param name=\"app\"&gt;&lt;/param&gt;\r\n    /// &lt;param name=\"config\"&gt;&lt;/param&gt;\r\n    /// &lt;param name=\"applicationName\"&gt;&lt;/param&gt;\r\n    public static void UseLogger(this IApplicationBuilder app, IConfigurationSection config, string applicationName)\r\n    {\r\n        var serviceProvider = app.ApplicationServices;\r\n        var loggerFactory = serviceProvider.GetService&lt;ILoggerFactory&gt;() as ILoggerFactory;\r\n        var loggingSettings = (serviceProvider.GetService&lt;IOptions&lt;AppLoggingSettings&gt;&gt;()).Value;\r\n        loggerFactory.AddConsole(config);\r\n        loggerFactory.AddDebug();\r\n \r\n        loggerFactory.AddDebug(LogLevel.Information);\r\n        loggerFactory.AddDebug(LogLevel.Debug);\r\n        loggerFactory.AddDebug(LogLevel.Error);\r\n \r\n        Func&lt;IRepository&lt;AppLogModel&gt;&gt; appLogRepoFactory = () =&gt;\r\n        {\r\n            // Create a scope repository\r\n            var scope = serviceProvider.CreateScope();\r\n            return scope.ServiceProvider.GetRequiredService&lt;IRepository&lt;AppLogModel&gt;&gt;();\r\n        };\r\n \r\n        loggerFactory.AddProvider(new AppLoggerProvider(appLogRepoFactory, loggingSettings, applicationName));\r\n    }\r\n}</code></pre>\r\n<p>Now that the boilerplate setup is out of the way, we can focus on creating the filter. We&rsquo;ll use some simple LINQ expresses to match our settings against category and LogLevel.</p>\r\n<p>&nbsp;</p>\r\n<p>The AppLoggerProvider will store references to our filter, appName, and the repository factory. It will also have (3) constructors. One will take a predefined filter, one will take a minimum LogLevel, and one will take the AppLoggingSettings.</p>\r\n<pre class=\"language-csharp\"><code>public class AppLoggerProvider : ILoggerProvider\r\n{\r\n    private Func&lt;IRepository&lt;AppLogModel&gt;&gt; _repoFactory;\r\n    private AppLoggingSettings logSettings;\r\n    private Func&lt;string, LogLevel, bool&gt; _filter;\r\n    private string _appName = \"Microsoft.AspNetCore\";\r\n \r\n    public AppLoggerProvider(Func&lt;IRepository&lt;AppLogModel&gt;&gt; repoFactory, Func&lt;string, LogLevel, bool&gt; filter, string applicationName)\r\n    {\r\n        _repoFactory = repoFactory;\r\n        _filter = filter;\r\n        _appName = applicationName;\r\n    }</code></pre>\r\n<p>&nbsp;</p>\r\n<p>The first constructor is self-explanatory. We&rsquo;re only setting our private members.</p>\r\n<pre class=\"language-csharp\"><code>public AppLoggerProvider(Func&lt;IRepository&lt;AppLogModel&gt;&gt; repoFactory, Func&lt;string, LogLevel, bool&gt; filter, string applicationName)\r\n{\r\n    _repoFactory = repoFactory;\r\n    _filter = filter;\r\n    _appName = applicationName;\r\n}</code></pre>\r\n<p>The next constructor is a bit more interesting since we define our filter. Note that it takes a &ldquo;minimum&rdquo; LogLevel and creates a Func&lt;string, LogLevel, bool&gt; from the LogLevel. This does not take into account Category, so it has limited usefulness.</p>\r\n<pre class=\"language-csharp\"><code>public AppLoggerProvider(Func&lt;IRepository&lt;AppLogModel&gt;&gt; repoFactory, LogLevel minLogLevel, string applicationName)\r\n{\r\n    _repoFactory = repoFactory;\r\n    _filter = (_, logLevel) =&gt; logLevel != LogLevel.None &amp;&amp; logLevel &gt;= minLogLevel;\r\n    _appName = applicationName;\r\n}</code></pre>\r\n<p>The last, and most versatile constructor takes the AppLoggingSettings object as an input. Based on this object, a robut filter is created. The category will be compared against the Namespace of each AppLogLevel to find a match. If no match is found, then we look for specifically named entries of &ldquo;Default&rdquo; or &ldquo;Application.&rdquo; I chose these as the &ldquo;catch all&rdquo; defaults. If there are LogLevels in the List&lt;LogLevel&gt; of a matched AppLogLevel, then we see if the passed in LogLevel is in the list and log the message if it is. If there are no LogLevels in the List&lt;LogLevel&gt; then we defer to the similar &ldquo;minimum&rdquo; LogLevel comparison. And, if we find no matches at all, then the message will not be logged.</p>\r\n<pre class=\"language-csharp\"><code>public AppLoggerProvider(Func&lt;IRepository&lt;AppLogModel&gt;&gt; repoFactory, AppLoggingSettings loggingSettings, string applicationName)\r\n    {\r\n        _repoFactory = repoFactory;\r\n        _filter = (category, logLevel) =&gt;\r\n        {\r\n            // First, does this match a category?\r\n            var matchedCategory = loggingSettings.LogLevels.FirstOrDefault(x =&gt; category.ToLowerTrim().StartsWith(x.Namespace.ToLowerTrim()));\r\n            if (matchedCategory == null)\r\n            {\r\n                matchedCategory = loggingSettings.LogLevels.FirstOrDefault(x =&gt; x.Namespace.ToLowerTrim() == \"application\" || x.Namespace.ToLowerTrim() == \"default\");\r\n            }\r\n \r\n            if (matchedCategory == null)\r\n            {\r\n                return false;\r\n            }\r\n \r\n            // Now, if there are levels defined, use those\r\n            if ((matchedCategory.Levels?.Count ?? 0) &gt; 0)\r\n            {\r\n                return matchedCategory.Levels.Contains(logLevel);\r\n            }\r\n            else\r\n            {\r\n                return logLevel != LogLevel.None &amp;&amp; logLevel &gt;= matchedCategory.MinLevel;\r\n            }\r\n        };\r\n        _appName = applicationName;\r\n    }\r\n \r\n    public ILogger CreateLogger(string categoryName)\r\n    {\r\n        return new AppLogger(_repoFactory, _filter, _appName, categoryName);\r\n    }\r\n \r\n    public void Dispose()\r\n    {\r\n        _repoFactory = null;\r\n    }\r\n}</code></pre>\r\n<p>The only other change needed was to change the &ldquo;IsEnabled&rdquo; method in the AppLogger to execute the filter:</p>\r\n<pre class=\"language-csharp\"><code>public bool IsEnabled(LogLevel logLevel)\r\n{\r\n    return (_filter == null || _filter(_categoryName, logLevel));\r\n}</code></pre>\r\n<p>With these bits of code and configuration options in place, I have fine, granular control of what gets logged. Previously, my logging tables will getting slammed with all of the &ldquo;System&rdquo; and &ldquo;Microsoft&rdquo; messages. Now, I can turn any specific category (Namespace) completely off if I choose to. Once time permits, I will put the logging project/solution, in its entirely into a Github repository.</p>\r\n<p>&nbsp;</p>\r\n<p>As an aside, Microsoft&rsquo;s LogLevel enum is defined as below:</p>\r\n<p>&nbsp;</p>\r\n<p>ASP.NET Core defines the following log levels, ordered here from least to highest severity.</p>\r\n<p>&nbsp;</p>\r\n<p>Trace = 0</p>\r\n<p>&nbsp;</p>\r\n<p>For information that is valuable only to a developer debugging an issue. These messages may contain sensitive application data and so should not be enabled in a production environment. Disabled by default. Example: Credentials: {\"User\":\"someuser\", \"Password\":\"P@ssword\"}</p>\r\n<p>&nbsp;</p>\r\n<p>Debug = 1</p>\r\n<p>&nbsp;</p>\r\n<p>For information that has short-term usefulness during development and debugging. Example: Entering method Configure with flag set to true.</p>\r\n<p>&nbsp;</p>\r\n<p>Information = 2</p>\r\n<p>&nbsp;</p>\r\n<p>For tracking the general flow of the application. These logs typically have some long-term value. Example: Request received for path /api/todo</p>\r\n<p>&nbsp;</p>\r\n<p>Warning = 3</p>\r\n<p>&nbsp;</p>\r\n<p>For abnormal or unexpected events in the application flow. These may include errors or other conditions that do not cause the application to stop, but which may need to be investigated. Handled exceptions are a common place to use the Warning log level. Example: FileNotFoundException for file quotes.txt.</p>\r\n<p>&nbsp;</p>\r\n<p>Error = 4</p>\r\n<p>&nbsp;</p>\r\n<p>For errors and exceptions that cannot be handled. These messages indicate a failure in the current activity or operation (such as the current HTTP request), not an application-wide failure. Example log message: Cannot insert record due to duplicate key violation.</p>\r\n<p>&nbsp;</p>\r\n<p>Critical = 5</p>\r\n<p>&nbsp;</p>\r\n<p>For failures that require immediate attention. Examples: data loss scenarios, out of disk space.</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/29427d9e-f158-40f8-ae73-be3429828ba1_NET-Core-Log-Factory.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"implementing-.net-core-logging-levels-and-categories","tags":[{"name":"asp-dot-net","slug":"asp-dot-net"},{"name":"dot-net","slug":"dot-net"},{"name":"dotnet-core","slug":"dotnet-core"}],"recommendations":[{"id":298,"title":"How to use ASP.NET Web API cross-origin with ASP.NET Identity ?","imageUrl":"de304292-ed2e-4e28-8b7f-2cc5898f57ac_cross-origin.jpg","dateCreated":"2019-03-20T16:50:35.577Z","dateModified":"2019-03-20T16:54:16.861Z","contributedBy":"AskGif","content":"ASP.NET Web API is a fantastic piece of the .NET family (there is certainly some weirdness since we now have MVC and Web API with nearly identical methods, but ASP.NET MVC 6 is coming :)). However, getting a SPA or mobile hybrid (Ionic!) app working isn&rsquo;t the most pleasant experience.\r\n","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/de304292-ed2e-4e28-8b7f-2cc5898f57ac_cross-origin.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"mvc-5","slug":"mvc-5"},{"name":"Angular-JS","slug":"angular-js"},{"name":"javascript","slug":"javascript"},{"name":"asp-dot-net","slug":"asp-dot-net"}],"slug":"how-to-use-asp.net-web-api-cross-origin-with-asp.net-identity-","total":0},{"id":144,"title":"How can I get the total size of a particular folder in C#?","imageUrl":"e83abf96-0566-4f2a-bc58-c4697e4bd464_folder-size.png","dateCreated":"2018-10-25T09:42:29.321Z","dateModified":"2018-10-25T09:42:29.321Z","contributedBy":"AskGif","content":"When I'm creating one application where I'm giving certain memory space to users and I want to calculate the total space he used in his folder and to show him/her the total space utilized and total remaining space that can be utilized. How can I calculate the size of the entire folder including a","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/e83abf96-0566-4f2a-bc58-c4697e4bd464_folder-size.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"dot-net","slug":"dot-net"},{"name":"c-sharp","slug":"c-sharp"},{"name":"प्रशन","slug":"questions"},{"name":"asp-dot-net","slug":"asp-dot-net"}],"slug":"how-can-i-get-the-total-size-of-a-particular-folder-in-c","total":0},{"id":143,"title":"मैं केबी, एमबी, जीबी आदि में उपलब्ध बाइट्स में उपलब्ध बाइट्स कैसे परिवर्तित कर सकता हूं?","imageUrl":"2942acea-4a45-42f6-9fa6-fb552e182169_storage.jpg","dateCreated":"2018-10-25T05:32:57.852Z","dateModified":"2018-10-25T05:34:56.322Z","contributedBy":"AskGif","content":"How to calculate total bytes available in particular folder and I want to convert the total bytes available to total bytes available in KB, MB, GB etc?\r\nif you are calculating total bytes then you can use the following function to find out the respective total bytes in KB, MB, GB, TB etc.<","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/2942acea-4a45-42f6-9fa6-fb552e182169_storage.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"c-sharp","slug":"c-sharp"},{"name":"dot-net","slug":"dot-net"},{"name":"प्रशन","slug":"questions"},{"name":"asp-dot-net","slug":"asp-dot-net"}],"slug":"how-to-convert-given-bytes-in-kb-mb-gb-etc","total":0},{"id":122,"title":"Sending email using Gmail SMTP in asp.net mvc application?","imageUrl":"9314a749-f567-4f1c-8619-0d55ecfe29d3_gmail-smtp.jpg","dateCreated":"2018-08-27T12:20:43.031Z","dateModified":"2018-08-29T07:46:58.801Z","contributedBy":"AskGif","content":"You can use GMAIL SMTP service to send emails using c# .net MVC. You can specify the property constants in a config file for easy alteration.\r\nCreate Gmail Class comprises of all needed data type and member function as below.\r\n<pre class=\"language-csharp\"><code>public class GMailer\r\n{\r","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/9314a749-f567-4f1c-8619-0d55ecfe29d3_gmail-smtp.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"c-sharp","slug":"c-sharp"},{"name":"dot-net","slug":"dot-net"},{"name":"जीमेल","slug":"gmail"},{"name":"smtp","slug":"smtp"}],"slug":"sending-email-using-gmail-smtp-in-asp.net-mvc-application","total":0}]}