{"id":52,"title":"How to Find Longest Common Subsequence ?","imageUrl":"c7357e0f-63f6-4670-b96d-4dc337b28500_longest-common-subsequence.jpg","dateCreated":"2018-07-30T08:26:45.294Z","dateModified":"2018-07-30T08:53:55.528Z","contributedBy":"AskGif","content":"<p>The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all sequences in a set of sequences (often just two sequences). It differs from the longest common substring problem: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences. The longest common subsequence problem is a classic computer science problem, the basis of data comparison programs such as the diff utility, and has applications in bioinformatics. It is also widely used by revision control systems such as Git for reconciling multiple changes made to a revision-controlled collection of files.</p>\r\n<p>&nbsp;</p>\r\n<p>Recursive Solution :</p>\r\n<pre class=\"language-java\"><code>package dp;\r\n\r\npublic class LCS {\r\n\r\n\tpublic static int max(int a, int b) {\r\n\t\treturn a&gt;b?a:b;\r\n\t}\r\n\tpublic static int LCSUtil(String str1, int i, int len1, \r\n\t\t\tString str2, int j, int len2) {\r\n\t\tif(i == len1 || j == len2)\r\n\t\t\treturn 0;\r\n\t\tif(str1.charAt(i)==str2.charAt(j))\r\n\t\t\treturn 1 + LCSUtil(str1, i+1, len1, str2, j+1, len2);\r\n\t\t\r\n\t\treturn max(LCSUtil(str1, i+1, len1, str2, j, len2), \r\n\t\t\t\tLCSUtil(str1, i, len1, str2, j+1, len2));\r\n\t}\r\n\t\r\n\tpublic static int FindLCS(String str1, String str2) {\r\n\t\treturn LCSUtil(str1,0,str1.length(),str2,0,str2.length());\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tString str1 = \"ABCBDAB\";\r\n\t\tString str2 = \"BDCABA\";\r\n\t\t\r\n\t\tlong startTime = System.nanoTime();\r\n\t\t\r\n\t\tSystem.out.println(FindLCS(str1,str2));\r\n\t\t\r\n\t\tlong endTime   = System.nanoTime();\r\n\t\tlong totalTime = endTime - startTime;\r\n\t\tSystem.out.println(\"Total Time (nanoseconds) : \" + (totalTime));\r\n\r\n\t}\r\n\r\n}\r\n</code></pre>\r\n<pre class=\"language-markup\"><code>output:\r\n\r\n4\r\nTotal Time (nanoseconds) : 894489\r\n\r\n</code></pre>\r\n<p>This is a correct solution but it is very time-consuming. The time complexity of the above solution is O(2^n).</p>\r\n<p>&nbsp;</p>\r\n<p>Now We will solve this question using Dynamic Programming by using Memoization:</p>\r\n<pre class=\"language-java\"><code>package dp;\r\n\r\npublic class LCS {\r\n\r\n\tpublic static int max(int a, int b) {\r\n\t\treturn a&gt;b?a:b;\r\n\t}\r\n\tpublic static int LCSUtil(String str1, int i, int len1, \r\n\t\t\tString str2, int j, int len2) {\r\n\t\tint[][] dp = new int[len1+1][len2+1];\r\n\t\tfor(int x=0;x&lt;len1;x++)\r\n\t\t\tdp[x][len2]=0;\r\n\t\tfor(int x=0;x&lt;len2;x++)\r\n\t\t\tdp[len1][x]=0;\r\n\t\t\r\n\t\tfor(int x=len1-1;x&gt;=0;x--) {\r\n\t\t\tfor(int y=len2-1;y&gt;=0;y--) {\r\n\t\t\t\tdp[x][y]=dp[x+1][y+1];\r\n\t\t\t\tif(str1.charAt(x)==str2.charAt(y)) {\r\n\t\t\t\t\tdp[x][y]++;\r\n\t\t\t\t}\r\n\t\t\t\tif(dp[x+1][y]&gt;dp[x][y])\r\n\t\t\t\t\tdp[x][y]=dp[x+1][y];\r\n\t\t\t\tif(dp[x][y+1]&gt;dp[x][y])\r\n\t\t\t\t\tdp[x][y]=dp[x][y+1];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn dp[0][0];\r\n\t}\r\n\t\r\n\tpublic static int FindLCS(String str1, String str2) {\r\n\t\treturn LCSUtil(str1,0,str1.length(),str2,0,str2.length());\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tString str1 = \"ABCBDAB\";\r\n\t\tString str2 = \"BDCABA\";\r\n\t\t\r\n\t\tlong startTime = System.nanoTime();\r\n\t\t\r\n\t\tSystem.out.println(FindLCS(str1,str2));\r\n\t\t\r\n\t\tlong endTime   = System.nanoTime();\r\n\t\tlong totalTime = endTime - startTime;\r\n\t\tSystem.out.println(\"Total Time (nanoseconds) : \" + (totalTime));\r\n\r\n\t}\r\n\r\n}\r\n</code></pre>\r\n<pre class=\"language-markup\"><code>output:\r\n\r\n4\r\nTotal Time (nanoseconds) : 275257\r\n</code></pre>\r\n<p>The time complexity of the above solution is O(mn). Where m and n are the length of two strings to be compared.</p>\r\n<p>&nbsp;</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/c7357e0f-63f6-4670-b96d-4dc337b28500_longest-common-subsequence.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"how-to-find-longest-common-subsequence-","tags":[{"name":"lcs","slug":"lcs"},{"name":"java","slug":"java"},{"name":"dynamic-programming","slug":"dynamic-programming"},{"name":"recursion","slug":"recursion"},{"name":"प्रशन","slug":"questions"},{"name":"algorithm","slug":"algorithm"},{"name":"interview","slug":"interview"}],"recommendations":[{"id":1698,"title":"अनुप्रयोग परत क्या है?","imageUrl":"icon_6faa8ad3-f4c7-411a-a351-f5721537582b.jpg","dateCreated":"2020-11-20T07:40:00.435Z","dateModified":"2020-11-20T07:40:05.453Z","contributedBy":"sumitc91","content":"वेब परत को एप्लिकेशन लेयर (जिसे प्लेटफ़ॉर्म लेयर के रूप में भी जाना जाता है) से अलग करना आपको दोनों परतों को स्वतंत्र रूप से स्केल करने और कॉन्फ़िगर करने की अनुमति देता है। बिना अतिरिक्त वेब सर्वर को जोड़ने के बिना एप्लिकेशन सर्वर को जोड़ने में एक नया एपीआई परिणाम जोड़ना। एकल जिम्मेदारी सिद्धांत ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/6faa8ad3-f4c7-411a-a351-f5721537582b.jpg","category":{"name":"शिक्षण","slug":"tutorials"},"tags":[{"name":"interview","slug":"interview"}],"slug":"what-is-application-layer","total":0},{"id":1636,"title":"Two Strings - HashMap - Easy - HackerRank","imageUrl":"icon_b574251c-e9c0-4be6-9bc1-7c86f8da1806.jpg","dateCreated":"2020-10-24T07:22:16.972Z","dateModified":"2020-10-24T07:22:22.952Z","contributedBy":"sumitc91","content":"Given two strings, determine if they share a common substring. A substring may be as small as one character.\nFor example, the words \"a\", \"and\", \"art\" share the common substring . The words \"be\" and \"cat\" do not share a substring.\nFunction Description\nComplete the function two","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/b574251c-e9c0-4be6-9bc1-7c86f8da1806.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"hackerrank","slug":"hackerrank"},{"name":"hash-table","slug":"hash-table"}],"slug":"two-strings-hashmap-easy-hackerrank","total":0},{"id":1621,"title":"Swap Salary - Sql - Easy - LeetCode","imageUrl":"icon_d5dae622-be43-4a7d-a90e-4173c15f3195.jpg","dateCreated":"2020-10-17T06:35:01.639Z","dateModified":"2020-10-17T06:36:00.564Z","contributedBy":"sumitc91","content":"Given a table salary, such as the one below, that has m=male and f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update statement and no intermediate temp table.\nNote that you must write a single update statement, DO NOT write any sele","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/d5dae622-be43-4a7d-a90e-4173c15f3195.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"sql","slug":"sql"}],"slug":"swap-salary-sql-easy-leetcode","total":0},{"id":1609,"title":"Customers Who Never Order - Sql - Easy - LeetCode","imageUrl":"icon_3979029e-3ead-4244-a16d-a1344d80e6ec.jpg","dateCreated":"2020-10-16T07:20:40.745Z","dateModified":"2020-10-16T07:20:46.124Z","contributedBy":"sumitc91","content":"Suppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything.\nTable: Customers.\n+----+-------+<br />| Id | Name &nbsp;|<br />+----+-------+<br />| 1 &nbsp;| Joe &nbsp; |<br />| 2 &nbsp;| Henry ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/3979029e-3ead-4244-a16d-a1344d80e6ec.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"mysql","slug":"mysql"},{"name":"sql","slug":"sql"}],"slug":"customers-who-never-order-sql-easy-leetcode","total":0}]}