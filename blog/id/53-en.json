{"id":53,"title":"How to Find Maximum Value Contiguous Subsequence?","imageUrl":"8a4e1acc-7d87-4759-81e9-b9987ddc13c8_max-subarray.jpg","dateCreated":"2018-07-30T09:53:10.091Z","dateModified":"2018-07-30T09:54:41.928Z","contributedBy":"AskGif","content":"<p>The input to this problem is an array A[1...n] of real numbers. You need to find out what the highest value is that can be obtained by summing up all numbers of a contiguous subsequence A[i], A[i+1],...A[j] of A. If A does not contain negative numbers, the problem is trivial and can be solved by summing up all the elements of A. It becomes more tricky when A contains a mix of positive and negative numbers though.</p>\r\n<p>This problem is same as maximum contiguous subarray sum problem.</p>\r\n<p>For instance, for A = [-2,11,-4,13,-5,-2], the solution is 20 (11-4+13=20).</p>\r\n<p>Brute force Approach :</p>\r\n<pre class=\"language-java\"><code>package dp;\r\n\r\npublic class MaximumValueContiguousSubsequence {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tint[] arr = new int[] {-2, 11, -4, 13, -5, 2};\r\n\t\t\r\n\t\tlong startTime = System.nanoTime();\r\n\t\t\r\n\t\tSystem.out.println(FindMaximumValue(arr));\r\n\t\t\r\n\t\tlong endTime   = System.nanoTime();\r\n\t\tlong totalTime = endTime - startTime;\r\n\t\tSystem.out.println(\"Total Time (nanoseconds) : \" + (totalTime));\r\n\r\n\t}\r\n\r\n\tprivate static int FindMaximumValue(int[] arr) {\r\n\t\t\r\n\t\tint max = 0;\r\n\t\t\r\n\t\tfor(int i=0;i&lt;arr.length;i++) {\r\n\t\t\tfor(int j=i+1;j&lt;arr.length;j++) {\r\n\t\t\t\tint sum = 0;\r\n\t\t\t\t//Checking all possible combinations\r\n\t\t\t\tfor(int k=i;k&lt;=j;k++) {\r\n\t\t\t\t\tsum+=arr[k];\r\n\t\t\t\t\tif(sum&gt;max)\r\n\t\t\t\t\t\tmax = sum;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn max;\r\n\t}\r\n\r\n}\r\n</code></pre>\r\n<pre class=\"language-markup\"><code>output:\r\n\r\n20\r\nTotal Time (nanoseconds) : 353793\r\n</code></pre>\r\n<p>The Time complexity of the above solution is O(n^3) and space complexity is O(1).</p>\r\n<p>&nbsp;</p>\r\n<p>Can we improve the above solution?</p>\r\n<p>Yes, we can by using only 2 loops and use the already computed result.</p>\r\n<pre class=\"language-java\"><code>package dp;\r\n\r\npublic class MaximumValueContiguousSubsequence {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tint[] arr = new int[] {-2, 11, -4, 13, -5, 2};\r\n\t\t\r\n\t\tlong startTime = System.nanoTime();\r\n\t\t\r\n\t\tSystem.out.println(FindMaximumValue(arr));\r\n\t\t\r\n\t\tlong endTime   = System.nanoTime();\r\n\t\tlong totalTime = endTime - startTime;\r\n\t\tSystem.out.println(\"Total Time (nanoseconds) : \" + (totalTime));\r\n\r\n\t}\r\n\r\n\tprivate static int FindMaximumValue(int[] arr) {\r\n\t\t\r\n\t\tint max = 0;\r\n\t\t\r\n\t\tfor(int i=0;i&lt;arr.length;i++) {\r\n\t\t\tint sum = 0;\r\n\t\t\tfor(int j=i;j&lt;arr.length;j++) {\r\n\t\t\t\tsum+=arr[j];\r\n\t\t\t\tif(sum&gt;max)\r\n\t\t\t\t\tmax = sum;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn max;\r\n\t}\r\n\r\n}\r\n</code></pre>\r\n<pre class=\"language-markup\"><code>output:\r\n\r\n20\r\nTotal Time (nanoseconds) : 306218\r\n</code></pre>\r\n<p>The time complexity of the above solution is O(n^2) and space complexity is&nbsp; O(1).</p>\r\n<p>&nbsp;</p>\r\n<p>Can we improve the above solution even further?</p>\r\n<p>Yes by using <strong>Dynamic Programming.</strong></p>\r\n<pre class=\"language-java\"><code>package dp;\r\n\r\npublic class MaximumValueContiguousSubsequence {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tint[] arr = new int[] {-2, 11, -4, 13, -5, 2};\r\n\t\t\r\n\t\tlong startTime = System.nanoTime();\r\n\t\t\r\n\t\tSystem.out.println(FindMaximumValue(arr));\r\n\t\t\r\n\t\tlong endTime   = System.nanoTime();\r\n\t\tlong totalTime = endTime - startTime;\r\n\t\tSystem.out.println(\"Total Time (nanoseconds) : \" + (totalTime));\r\n\r\n\t}\r\n\r\n\tprivate static int FindMaximumValue(int[] arr) {\r\n\t\t\r\n\t\tint[] M = new int[arr.length+1];\r\n\t\tif(arr.length == 0)\r\n\t\t\treturn 0;\r\n\t\tif(arr.length == 1)\r\n\t\t\treturn arr[0];\r\n\t\tif(arr[0]&gt;0)\r\n\t\t\tM[0] = arr[0];\r\n\t\telse\r\n\t\t\tM[0] = 0;\r\n\t\t\r\n\t\tfor(int i=1;i&lt;arr.length;i++) {\r\n\t\t\tif(arr[i]+M[i-1]&gt;0)\r\n\t\t\t\tM[i]=arr[i]+M[i-1];\r\n\t\t\telse\r\n\t\t\t\tM[i]=0;\r\n\t\t}\r\n\t\t\t\r\n\t\tint max = Integer.MIN_VALUE;\r\n\t\tfor(int i=0;i&lt;M.length;i++)\r\n\t\t{\r\n\t\t\tif(max &lt; M[i])\r\n\t\t\t\tmax = M[i];\r\n\t\t}\r\n\t\t\r\n\t\treturn max;\r\n\t}\r\n\r\n}\r\n</code></pre>\r\n<pre class=\"language-markup\"><code>output:\r\n\r\n20\r\nTotal Time (nanoseconds) : 158206\r\n</code></pre>\r\n<p>Time Complexity of the above solution is O(n) and Space Complexity is also O(n).</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8a4e1acc-7d87-4759-81e9-b9987ddc13c8_max-subarray.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"how-to-find-maximum-value-contiguous-subsequence","tags":[{"name":"algorithm","slug":"algorithm"},{"name":"interview","slug":"interview"},{"name":"dynamic-programming","slug":"dynamic-programming"},{"name":"java","slug":"java"},{"name":"questions","slug":"questions"}],"recommendations":[{"id":1715,"title":"Determine if String Halves Are Alike - String - Easy - LeetCode","imageUrl":"icon_8d5b87e0-0bd8-47c9-8f55-cfff94e5858d.jpg","dateCreated":"2021-01-08T09:24:14.63Z","dateModified":"2021-01-08T09:24:20.084Z","contributedBy":"sumitc91","content":"You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half.\nTwo strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains upperca","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8d5b87e0-0bd8-47c9-8f55-cfff94e5858d.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"string","slug":"string"}],"slug":"determine-if-string-halves-are-alike-string-easy-leetcode","total":0},{"id":1701,"title":"K-diff Pairs in an Array - Array - Medium - LeetCode","imageUrl":"icon_adbe88a9-d88c-469f-ae16-26daa92dc3b3.jpg","dateCreated":"2020-11-20T09:11:47.894Z","dateModified":"2020-11-20T09:11:56.252Z","contributedBy":"sumitc91","content":"Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array.\nA k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:\n0 &lt;= i, j &lt; nums.length<br />i != j<br />|nums[i] - nums[j]| == k<br />Notice that |val| ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8c421996-adef-4a2c-b776-f3e3810e1e3b.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"k-diff-pairs-in-an-array-array-medium-leetcode","total":0},{"id":1669,"title":"Maximum Product Subarray - Array - Medium - LeetCode","imageUrl":"icon_7f1afad0-6986-4b75-b8b1-48cc2da5b308.jpg","dateCreated":"2020-11-17T12:27:09.279Z","dateModified":"2020-11-17T12:27:13.842Z","contributedBy":"sumitc91","content":"Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.\nExample 1:\nInput: [2,3,-2,4]<br />Output: 6<br />Explanation: [2,3] has the largest product 6.<br />Example 2:\nInput: [-2,0,-1]<br />Outpu","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/7f1afad0-6986-4b75-b8b1-48cc2da5b308.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"array","slug":"array"},{"name":"data-structure","slug":"data-structure"},{"name":"leetcode","slug":"leetcode"},{"name":"medium","slug":"medium"}],"slug":"maximum-product-subarray-array-medium-leetcode","total":0},{"id":1609,"title":"Customers Who Never Order - Sql - Easy - LeetCode","imageUrl":"icon_3979029e-3ead-4244-a16d-a1344d80e6ec.jpg","dateCreated":"2020-10-16T07:20:40.745Z","dateModified":"2020-10-16T07:20:46.124Z","contributedBy":"sumitc91","content":"Suppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything.\nTable: Customers.\n+----+-------+<br />| Id | Name &nbsp;|<br />+----+-------+<br />| 1 &nbsp;| Joe &nbsp; |<br />| 2 &nbsp;| Henry ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/3979029e-3ead-4244-a16d-a1344d80e6ec.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"mysql","slug":"mysql"},{"name":"sql","slug":"sql"}],"slug":"customers-who-never-order-sql-easy-leetcode","total":0}]}