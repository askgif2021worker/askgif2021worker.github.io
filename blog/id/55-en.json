{"id":55,"title":"How to solve Matrix Product Parenthesizations problem?","imageUrl":"3037b8be-31fd-4f24-8882-e7babe1f2242_matrix-mult.jpg","dateCreated":"2018-07-30T12:26:31.838Z","dateModified":"2018-07-30T12:32:48.996Z","contributedBy":"AskGif","content":"<p>Matrix chain multiplication (or Matrix Chain Ordering Problem, MCOP) is an optimization problem that can be solved using dynamic programming. Given a sequence of matrices, the goal is to find the most efficient way to multiply these matrices. The problem is not actually to perform the multiplications, but merely to decide the sequence of the matrix multiplications involved.</p>\r\n<p>This problem is also known as Matrix-Chain Multiplication Problem.</p>\r\n<p>There are many options because matrix multiplication is associative. In other words, no matter how the product is parenthesized, the result obtained will remain the same. For example, for four matrices A, B, C, and D, we would have:</p>\r\n<p>&nbsp;</p>\r\n<p>((AB)C)D = (A(BC))D = (AB)(CD) = A((BC)D) = A(B(CD)).</p>\r\n<p>However, the order in which the product is parenthesized affects the number of simple arithmetic operations needed to compute the product, that is the computational complexity. For example, if A is a 10 &times; 30 matrix, B is a 30 &times; 5 matrix, and C is a 5 &times; 60 matrix, then</p>\r\n<p>&nbsp;</p>\r\n<p>computing (AB)C needs (10&times;30&times;5) + (10&times;5&times;60) = 1500 + 3000 = 4500 operations, while</p>\r\n<p>computing A(BC) needs (30&times;5&times;60) + (10&times;30&times;60) = 9000 + 18000 = 27000 operations.</p>\r\n<p>Clearly, the first method is more efficient. With this information, the problem statement can be refined as \"how to determine the optimal parenthesization of a product of n matrices?\" Checking each possible parenthesization (brute force) would require a run-time that is exponential in the number of matrices, which is very slow and impractical for large n. A quicker solution to this problem can be achieved by breaking up the problem into a set of related subproblems. By solving subproblems once and reusing the solutions, the required run-time can be drastically reduced. This concept is known as dynamic programming.</p>\r\n<pre class=\"language-java\"><code>package dp;\r\n\r\npublic class MatrixProductParenthesization {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tint arr[] = {1, 2, 3, 4};\r\n\t\t\r\n\t\tlong startTime = System.nanoTime();\r\n\t\t\r\n\t\tSystem.out.println(FindMatrixProduct(arr));\r\n\t\t\r\n\t\tlong endTime   = System.nanoTime();\r\n\t\tlong totalTime = endTime - startTime;\r\n\t\tSystem.out.println(\"Total Time (nanoseconds) : \" + (totalTime));\r\n\r\n\t}\r\n\r\n\tprivate static int FindMatrixProduct(int[] arr) {\r\n\t\t\r\n\t\tint n = arr.length;\r\n\t    int[][] dp=new int[n][n];\r\n\t \r\n\t    int i, j, k, L, q;\r\n\t \r\n\t    for (L=2; L&lt;n; L++)\r\n\t    {\r\n\t        for (i=1; i&lt;n-L+1; i++)\r\n\t        {\r\n\t            j = i+L-1;\r\n\t            dp[i][j] = Integer.MAX_VALUE;\r\n\t            for (k=i; k&lt;=j-1; k++)\r\n\t            {\r\n\t                q = dp[i][k] + dp[k+1][j] + arr[i-1]*arr[k]*arr[j];\r\n\t                if (q &lt; dp[i][j])\r\n\t                    dp[i][j] = q;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t \r\n\t    return dp[1][n-1];\r\n\t}\r\n\r\n}\r\n</code></pre>\r\n<pre class=\"language-markup\"><code>output:\r\n\r\n18\r\nTotal Time (nanoseconds) : 266194\r\n</code></pre>\r\n<p>The time complexity of the above solution is O(n^3) and Space complexity is O(n^2).</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/3037b8be-31fd-4f24-8882-e7babe1f2242_matrix-mult.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"how-to-solve-matrix-product-parenthesizations-problem","tags":[{"name":"dynamic-programming","slug":"dynamic-programming"},{"name":"interview","slug":"interview"},{"name":"java","slug":"java"},{"name":"questions","slug":"questions"}],"recommendations":[{"id":74,"title":"What is Iterator pattern?","imageUrl":"2ae1cc9a-b9ca-4dd5-8faf-ae38f2bdd6c3_Iterator-pattern.png","dateCreated":"2018-08-01T15:49:45.656Z","dateModified":"2018-08-01T17:23:52.861Z","contributedBy":"AskGif","content":"In object-oriented programming, the iterator pattern is a design pattern in which an iterator is used to traverse a container and access the container's elements. The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus canno","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/2ae1cc9a-b9ca-4dd5-8faf-ae38f2bdd6c3_Iterator-pattern.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"questions","slug":"questions"},{"name":"design-patterns","slug":"design-patterns"},{"name":"behavioral-patterns","slug":"behavioral-patterns"},{"name":"interview","slug":"interview"}],"slug":"what-is-iterator-pattern","total":0},{"id":66,"title":"What is Observer pattern ?","imageUrl":"e69dad7f-de9e-4693-9048-db8d81419863_Observer-pattern.png","dateCreated":"2018-08-01T12:21:30.92Z","dateModified":"2018-08-01T17:24:10.49Z","contributedBy":"AskGif","content":"The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods.\r\n&nbsp;\r\nIt is mainly used to implement dist","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/e69dad7f-de9e-4693-9048-db8d81419863_Observer-pattern.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"behavioral-patterns","slug":"behavioral-patterns"},{"name":"questions","slug":"questions"},{"name":"interview","slug":"interview"},{"name":"design-patterns","slug":"design-patterns"}],"slug":"what-is-observer-pattern-","total":0},{"id":25,"title":"Minimum Coin Count For a Coin Change Sum Problem","imageUrl":"b5366990-c1aa-4e54-a3c3-9835217b43d3_coin-change-dp.jpg","dateCreated":"2018-07-13T12:15:28.514Z","dateModified":"2018-07-13T12:40:03.514Z","contributedBy":"AskGif","content":"Coin Changing Minimum Count Number of Coins With a Sum Using Dynamic programming.\r\nThe question is given coins of certain denominations and a total, how many minimum coins would you need to make this total.\r\n<pre class=\"language-java\"><code>public class MinCoinChangeProblem {\r\n\tprivate","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/b5366990-c1aa-4e54-a3c3-9835217b43d3_coin-change-dp.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"java","slug":"java"},{"name":"algorithm","slug":"algorithm"},{"name":"interview","slug":"interview"},{"name":"dynamic-programming","slug":"dynamic-programming"}],"slug":"minimum-coin-count-for-a-coin-change-sum-problem","total":0},{"id":1,"title":"How to install java on EC2 Ubuntu 16-04","imageUrl":"d11fed6a-e800-4779-8cee-f7f5c8c42ee8_00_lead_image_java_in_ubuntu.png","dateCreated":"2018-06-20T13:02:11.29Z","dateModified":"2018-07-07T15:23:51.439Z","contributedBy":"AskGif","content":"This blog is in continuation to blog&nbsp;<a href=\"../../../../../blog/3/how-to-create-ec2-instance-on-aws-free-tier-plan/?lang=en\" target=\"_blank\" rel=\"noopener\">How to create EC2 instance on AWS Free Tier plan.</a>&nbsp;if you missed please revisit.\r\nFirst we need to get an Ubuntu (16.04","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/d11fed6a-e800-4779-8cee-f7f5c8c42ee8_00_lead_image_java_in_ubuntu.png","category":{"name":"tutorials","slug":"tutorials"},"tags":[{"name":"jre","slug":"jre"},{"name":"jdk","slug":"jdk"},{"name":"java","slug":"java"}],"slug":"how-to-install-java-on-ec2-ubuntu-16-04","total":0}]}