{"id":58,"title":"How to solve Knapsack problem using Dynamic Programming","imageUrl":"b6cbe28d-ef39-4235-aa96-015ea58e9991_knapsack.jpg","dateCreated":"2018-07-31T07:51:18.76Z","dateModified":"2018-07-31T07:51:31.675Z","contributedBy":"AskGif","content":"<p>The knapsack problem or rucksack problem is a problem in combinatorial optimization: Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. It derives its name from the problem faced by someone who is constrained by a fixed-size knapsack and must fill it with the most valuable items.</p>\r\n<p>The problem often arises in resource allocation where there are financial constraints and is studied in fields such as combinatorics, computer science, complexity theory, cryptography, applied mathematics, and daily fantasy sports.</p>\r\n<p>The knapsack problem has been studied for more than a century, with early works dating as far back as 1897. The name \"knapsack problem\" dates back to the early works of mathematician Tobias Dantzig (1884&ndash;1956) and refers to the commonplace problem of packing the most valuable or useful items without overloading the luggage.</p>\r\n<p>We will solve this problem using recursion :</p>\r\n<pre class=\"language-java\"><code>package dp;\r\n\r\npublic class Knapsack {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tint[] values = new int[] {60, 100, 120};\r\n\t\tint[] weight = new int[] {10, 20, 30};\r\n\t\tint maxWeight = 50;\r\n\t\t\r\n\t\tlong startTime = System.nanoTime();\r\n\t\t\r\n\t\tSystem.out.println(MaxProfit(values, weight, maxWeight, values.length-1));\r\n\r\n\t\tlong endTime   = System.nanoTime();\r\n\t\tlong totalTime = endTime - startTime;\r\n\t\tSystem.out.println(\"Total Time (nanoseconds) : \" + (totalTime));\r\n\t}\r\n\r\n\tprivate static int MaxProfit(int[] values, int[] weight, int maxWeight, int index) {\r\n\t\tif(maxWeight &lt;= 0 || index &lt; 0)\r\n\t\t\treturn 0;\r\n\t\t\r\n\t\t//Either ignore the current item or take the current item.\r\n\t\treturn max(MaxProfit(values, weight, maxWeight,index-1), \r\n\t\t\t\tvalues[index] + MaxProfit(values, weight, maxWeight-weight[index], index-1));\r\n\t}\r\n\r\n\tprivate static int max(int a, int b) {\r\n\t\treturn a&gt;b?a:b;\r\n\t}\r\n\r\n}\r\n</code></pre>\r\n<pre class=\"language-markup\"><code>output:\r\n\r\n220\r\nTotal Time (nanoseconds) : 164625\r\n</code></pre>\r\n<p>If you look carefully we are solving the same overlapping problem again and again. The time complexity of the above solution is exponential, i.e 2^n.</p>\r\n<p>&nbsp;</p>\r\n<p>Can we improve the above solution?</p>\r\n<p>Yes by using Dynamic Programming and remembering the previously calculated results.</p>\r\n<pre class=\"language-java\"><code>package dp;\r\n\r\npublic class Knapsack {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tint[] values = new int[] {60, 100, 120};\r\n\t\tint[] weight = new int[] {10, 20, 30};\r\n\t\tint maxWeight = 50;\r\n\t\t\r\n\t\tlong startTime = System.nanoTime();\r\n\t\t\r\n\t\tSystem.out.println(MaxProfit(values, weight, maxWeight));\r\n\r\n\t\tlong endTime   = System.nanoTime();\r\n\t\tlong totalTime = endTime - startTime;\r\n\t\tSystem.out.println(\"Total Time (nanoseconds) : \" + (totalTime));\r\n\t}\r\n\r\n\tprivate static int MaxProfit(int[] values, int[] weight, int maxWeight) {\r\n\t\tif(maxWeight &lt;= 0)\r\n\t\t\treturn 0;\r\n\t\t\r\n\t\tint[][] dp = new int[values.length+1][maxWeight+1];\r\n\t\t\r\n\t\tfor(int i=0;i&lt;values.length;i++) {\r\n\t\t\tfor(int j=0;j&lt;=maxWeight;j++) {\r\n\t\t\t\tif(i==0 || j==0)\r\n\t\t\t\t\tdp[i][j]=0;\r\n\t\t\t\telse if(weight[i]&lt;=j) {\r\n\t\t\t\t\tdp[i][j]=max(values[i]+dp[i-1][j-weight[i]],dp[i-1][j]);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dp[values.length-1][maxWeight];\r\n\t}\r\n\r\n\tprivate static int max(int a, int b) {\r\n\t\treturn a&gt;b?a:b;\r\n\t}\r\n\r\n}\r\n</code></pre>\r\n<pre class=\"language-markup\"><code>output:\r\n\r\n220\r\nTotal Time (nanoseconds) : 239009\r\n</code></pre>\r\n<p>The time complexity of the above solution is O(nW) where n is the number of items and W is the capacity of Knapsack.</p>\r\n<p>&nbsp;</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/b6cbe28d-ef39-4235-aa96-015ea58e9991_knapsack.jpg","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"how-to-solve-knapsack-problem-using-dynamic-programming","tags":[{"name":"recursion","slug":"recursion"},{"name":"interview","slug":"interview"},{"name":"प्रशन","slug":"questions"},{"name":"dynamic-programming","slug":"dynamic-programming"},{"name":"java","slug":"java"}],"recommendations":[{"id":1534,"title":"Range Sum Query - Immutable - Array - Easy - LeetCode","imageUrl":"icon_bfa9c4e7-d1a4-4718-b80b-18fa3fcbc1a3.jpg","dateCreated":"2020-10-03T10:01:00.986Z","dateModified":"2020-10-03T10:01:07.585Z","contributedBy":"sumitc91","content":"Given an integer array nums, find the sum of the elements between indices i and j (i &le; j), inclusive.\nExample:\nGiven nums = [-2, 0, 3, -5, 2, -1]\nsumRange(0, 2) -&gt; 1<br />sumRange(2, 5) -&gt; -1<br />sumRange(0, 5) -&gt; -3<br />&nbsp;\nConstraints:\nYou may","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/bfa9c4e7-d1a4-4718-b80b-18fa3fcbc1a3.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"dynamic-programming","slug":"dynamic-programming"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"range-sum-query-immutable-array-easy-leetcode","total":0},{"id":108,"title":"How to implement Level Order Traversal in Binary Tree?","imageUrl":"7833549b-eb6c-47f7-a6b0-1364f1434f70_binary_tree_breadth-first_traversal.png","dateCreated":"2018-08-14T14:06:33.296Z","dateModified":"2018-08-14T14:06:56.625Z","contributedBy":"AskGif","content":"Trees can also be traversed in level-order, where we visit every node on a level before going to a lower level. This search is referred to as a breadth-first search (BFS), as the search tree is broadened as much as possible on each depth before going to the next depth.\r\nJava implementation","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/7833549b-eb6c-47f7-a6b0-1364f1434f70_binary_tree_breadth-first_traversal.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"java","slug":"java"},{"name":"tree","slug":"tree"},{"name":"interview","slug":"interview"},{"name":"प्रशन","slug":"questions"},{"name":"level-order","slug":"level-order"},{"name":"traversal","slug":"traversal"}],"slug":"how-to-implement-level-order-traversal-in-binary-tree","total":0},{"id":65,"title":"रणनीति पैटर्न क्या है?","imageUrl":"ffa5f7f6-cc72-474b-8dd9-afcf149959f1_strategy_pattern.jpg","dateCreated":"2018-08-01T12:05:22.176Z","dateModified":"2018-08-01T17:24:43.716Z","contributedBy":"AskGif","content":"In computer programming, the strategy pattern (also known as the policy pattern) is a behavioural software design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, code receives run-time instructions as to which is a family of algorithms ","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/ffa5f7f6-cc72-474b-8dd9-afcf149959f1_strategy_pattern.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"design-patterns","slug":"design-patterns"},{"name":"behavioral-patterns","slug":"behavioral-patterns"},{"name":"प्रशन","slug":"questions"},{"name":"interview","slug":"interview"}],"slug":"what-is-strategy-pattern","total":0},{"id":1,"title":"EC2 उबंटू 16-04 पर जावा कैसे स्थापित करें","imageUrl":"d11fed6a-e800-4779-8cee-f7f5c8c42ee8_00_lead_image_java_in_ubuntu.png","dateCreated":"2018-06-20T13:02:11.29Z","dateModified":"2018-07-07T15:23:51.439Z","contributedBy":"AskGif","content":"यह ब्लॉग ब्लॉग के निरंतरता में है एडब्ल्यूएस फ्री टियर योजना पर ईसी 2 उदाहरण कैसे बनाएं। यदि आप चूक गए तो कृपया पुनरीक्षण करें। सबसे पहले हमें उबंटू (16.04) उदाहरण प्राप्त करने की आवश्यकता है। इसके लिए हम एडब्ल्यूएस कंसोल का उपयोग कर सकते हैं। एक बार ubuntu मशीन ऊपर है और चल रहा है निम्नलिखित दृष","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/d11fed6a-e800-4779-8cee-f7f5c8c42ee8_00_lead_image_java_in_ubuntu.png","category":{"name":"शिक्षण","slug":"tutorials"},"tags":[{"name":"jre","slug":"jre"},{"name":"jdk","slug":"jdk"},{"name":"java","slug":"java"}],"slug":"how-to-install-java-on-ec2-ubuntu-16-04","total":0}]}