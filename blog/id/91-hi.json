{"id":91,"title":"Find the Merging Point of Two Linked Lists.","imageUrl":"5c3e878f-f7b0-49be-a057-486f950a7a67_linked-list-merging.png","dateCreated":"2018-08-07T13:43:16.367Z","dateModified":"2018-08-08T10:36:40.67Z","contributedBy":"AskGif","content":"<p>Given pointers to the head nodes of linked lists that merge together at some point, find the Node where the two lists merge. It is guaranteed that the two head Nodes will be different, and neither will be NULL.</p>\r\n<p>We need to find the merging point of two linked lists.</p>\r\n<p>&nbsp;</p>\r\n<p>Let's first solve this problem using stacks :</p>\r\n<p>We will push all elements of list1 in stack1 and all elements of list2 in stack2. While popping each element we will compare and if it is different we will return the just previously traversed Node. i.e the node from where diversion occurred.</p>\r\n<p>Java solution for the above problem is as below:</p>\r\n<pre class=\"language-java\"><code>package askgif.linkedlist;\r\n\r\nimport java.util.Stack;\r\n\r\nclass ListNode{\r\n    public int data;\r\n    public ListNode next;\r\n    ListNode(int data){\r\n    \tthis.data = data;\r\n    }\r\n};\r\n\r\npublic class CircularNodeExist {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t\r\n        ListNode node1 = new ListNode(1);\r\n        ListNode node2 = new ListNode(2);\r\n        ListNode node3 = new ListNode(3);\r\n        ListNode node4 = new ListNode(4);\r\n        ListNode node5 = new ListNode(5);\r\n        ListNode node6 = new ListNode(6);\r\n        ListNode node7 = new ListNode(7);\r\n        ListNode node8 = new ListNode(8);\r\n        ListNode node9 = new ListNode(9);\r\n        ListNode node10 = new ListNode(10);\r\n        ListNode node11 = new ListNode(11);\r\n        \r\n        \r\n        node4.next = node5;\r\n        node5.next = node6;\r\n        node6.next = node7;\r\n        node7.next = node8;\r\n        node8.next = node9;\r\n        node9.next = node10;\r\n        node10.next = node11;\r\n        node11.next = null;\r\n        \r\n        node1.next = node2;\r\n        node2.next = node3;\r\n        node3.next = node8;\r\n        \r\n        \r\n\t\tSystem.out.println(GetMeetingNode( node1, node4));\r\n\t\t\r\n\r\n\t}\r\n\r\n\tprivate static int GetMeetingNode(ListNode node1, ListNode node2) {\r\n\t\t\r\n\t\t//By using stack\r\n\t\tStack&lt;ListNode&gt; stack1 = new Stack&lt;ListNode&gt;();\r\n\t\tStack&lt;ListNode&gt; stack2 = new Stack&lt;ListNode&gt;();\r\n\t\t\r\n\t\twhile(node1 != null) {\r\n\t\t\tstack1.push(node1);\r\n\t\t\tnode1 = node1.next;\r\n\t\t}\r\n\t\t\r\n\t\twhile(node2 != null) {\r\n\t\t\tstack2.push(node2);\r\n\t\t\tnode2 = node2.next;\r\n\t\t}\r\n\t\t\r\n\t\tListNode prev = null;\r\n\t\twhile(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty()){\r\n\t\t\t\r\n\t\t\tListNode data1 = stack1.pop();\r\n\t\t\tListNode data2 = stack2.pop();\r\n            if(data1 != data2)\r\n            \treturn prev.data;\r\n            prev = data1;\r\n        }\r\n\t\t\r\n\t\treturn -1;\r\n\t}\r\n\r\n}\r\n</code></pre>\r\n<pre class=\"language-markup\"><code>output:\r\n\r\n8</code></pre>\r\n<p>The time complexity of the above solution is O(n) for traversing the Linked List While Space complexity is O(n) since we are using a stack to store the nodes.</p>\r\n<p>&nbsp;</p>\r\n<p>Can we do it better?</p>\r\n<p>Yes by using length property.</p>\r\n<p>calculate the difference of both list length. Traverse the Larger linked list by k(difference) steps. then just compare both nodes. if they are equal just return the data of the node.</p>\r\n<p>Java Solution is as below:</p>\r\n<pre class=\"language-java\"><code>package askgif.linkedlist;\r\n\r\nimport java.util.Stack;\r\n\r\nclass ListNode{\r\n    public int data;\r\n    public ListNode next;\r\n    ListNode(int data){\r\n    \tthis.data = data;\r\n    }\r\n};\r\n\r\npublic class CircularNodeExist {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t\r\n        ListNode node1 = new ListNode(1);\r\n        ListNode node2 = new ListNode(2);\r\n        ListNode node3 = new ListNode(3);\r\n        ListNode node4 = new ListNode(4);\r\n        ListNode node5 = new ListNode(5);\r\n        ListNode node6 = new ListNode(6);\r\n        ListNode node7 = new ListNode(7);\r\n        ListNode node8 = new ListNode(8);\r\n        ListNode node9 = new ListNode(9);\r\n        ListNode node10 = new ListNode(10);\r\n        ListNode node11 = new ListNode(11);\r\n        \r\n        \r\n        node4.next = node5;\r\n        node5.next = node6;\r\n        node6.next = node7;\r\n        node7.next = node8;\r\n        node8.next = node9;\r\n        node9.next = node10;\r\n        node10.next = node11;\r\n        node11.next = null;\r\n        \r\n        node1.next = node2;\r\n        node2.next = node3;\r\n        node3.next = node8;\r\n        \r\n        \r\n\t\tSystem.out.println(GetMeetingNode( node1, node4));\r\n\t\t\r\n\r\n\t}\r\n\r\n\tprivate static int GetMeetingNode(ListNode node1, ListNode node2) {\r\n\t\t\r\n\t\t//By using length property\r\n\t\tint len1=0;\r\n\t\tint len2=0;\r\n\t\t\r\n\t\tListNode ll1 = node1;\r\n\t\tListNode ll2 = node2;\r\n\t\t\r\n\t\twhile(node1 != null) {\r\n\t\t\tlen1++;\r\n\t\t\tnode1 = node1.next;\r\n\t\t}\r\n\t\t\r\n\t\twhile(node2 != null) {\r\n\t\t\tlen2++;\r\n\t\t\tnode2 = node2.next;\r\n\t\t}\r\n\t\t\r\n\t\tif(len1 &gt; len2) {\r\n\t\t\tint diff = len1 - len2;\r\n\t\t\tint i = 0;\r\n\t\t\twhile(ll1 != null &amp;&amp; i != diff) {\r\n\t\t\t\ti++;\r\n\t\t\t\tll1 = ll1.next;\r\n\t\t\t}\r\n\t\t}\t\r\n\t\telse\r\n\t\t{\r\n\t\t\tint diff = len2 - len1;\r\n\t\t\tint i = 0;\r\n\t\t\twhile(ll2 != null &amp;&amp; i != diff) {\r\n\t\t\t\ti++;\r\n\t\t\t\tll2 = ll2.next;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twhile(ll1 != null) {\r\n\t\t\tif(ll1 == ll2)\r\n\t\t\t\treturn ll1.data;\r\n\t\t\tll1 = ll1.next;\r\n\t\t\tll2 = ll2.next;\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n}\r\n</code></pre>\r\n<pre class=\"language-markup\"><code>output:\r\n\r\n8</code></pre>\r\n<p>The time complexity of the above solution is O(1) and the space complexity is also O(1).</p>","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/5c3e878f-f7b0-49be-a057-486f950a7a67_linked-list-merging.png","subContents":[],"category":{"name":"coding","slug":"coding"},"slug":"find-the-merging-point-of-two-linked-lists","tags":[{"name":"stack","slug":"stack"},{"name":"interview","slug":"interview"},{"name":"linked-list","slug":"linked-list"},{"name":"java","slug":"java"},{"name":"प्रशन","slug":"questions"}],"recommendations":[{"id":1690,"title":"AWS पर लाखों उपयोगकर्ताओं के लिए एक प्रणाली कैसे डिज़ाइन करें","imageUrl":"icon_c4c206e1-63c2-46f8-a9b3-076b94e481a7.png","dateCreated":"2020-11-20T07:07:56.332Z","dateModified":"2020-11-20T07:08:06.04Z","contributedBy":"sumitc91","content":"चरण 1: मामलों और बाधाओं का उपयोग करें<br />आवश्यकताओं को इकट्ठा करें और समस्या को हल करें। उपयोग के मामलों और बाधाओं को स्पष्ट करने के लिए प्रश्न पूछें। मान्यताओं पर चर्चा करें।\nसाक्षात्कारकर्ता के बिना स्पष्ट प्रश्नों को संबोधित करने के लिए, हम कुछ उपयोग मामलों और बाधाओं को परिभाषित करेंग","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/c4c206e1-63c2-46f8-a9b3-076b94e481a7.png","category":{"name":"शिक्षण","slug":"tutorials"},"tags":[{"name":"डिज़ाइन","slug":"design"},{"name":"interview","slug":"interview"},{"name":"प्रणाली-की-रूपरेखा","slug":"system-design"}],"slug":"how-to-design-a-system-that-scales-to-millions-of-users-on-aws","total":0},{"id":105,"title":"How to implement PostOrder Traversal in Binary Tree?","imageUrl":"d82cf369-0894-48fd-ba39-de927c3291d9_post-order-traversal.png","dateCreated":"2018-08-09T14:28:23.665Z","dateModified":"2018-08-09T14:29:04.831Z","contributedBy":"AskGif","content":"PostOrder Traversal is different from InOrder Traversal and PreOrder Traversal. In this Traversal approach we first traverse through left and then right and at the end, we traverse to the node data.\r\nIn PostOrder traversal, the root is visited after both subtrees. PostOrder traversal is de","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/d82cf369-0894-48fd-ba39-de927c3291d9_post-order-traversal.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"tree","slug":"tree"},{"name":"traversal","slug":"traversal"},{"name":"java","slug":"java"},{"name":"recursion","slug":"recursion"},{"name":"प्रशन","slug":"questions"},{"name":"postorder","slug":"postorder"},{"name":"interview","slug":"interview"}],"slug":"how-to-implement-postorder-traversal-in-binary-tree","total":0},{"id":26,"title":"Cutting Rod Problem to get maximum profit","imageUrl":"9e5dad83-cf44-4cbb-802a-d2b361487079_cutting-rod.png","dateCreated":"2018-07-13T13:29:30.675Z","dateModified":"2018-07-14T04:10:50.978Z","contributedBy":"AskGif","content":"You are given a rod of a particular length and prices at which those different lengths of this rod can be sell, how will you cut this rod to maximize your profit?&nbsp;\r\nWe will be using dynamic programming to solve this problem. Java Solution for the problem is given below:\r\n&nbsp;","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/9e5dad83-cf44-4cbb-802a-d2b361487079_cutting-rod.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"dynamic-programming","slug":"dynamic-programming"},{"name":"algorithm","slug":"algorithm"},{"name":"interview","slug":"interview"},{"name":"java","slug":"java"}],"slug":"cutting-rod-problem-to-get-maximum-profit","total":0},{"id":19,"title":"Find Longest Increasing Subsequence Using Binary Search","imageUrl":"11b79284-f1ed-4645-ade0-e4eb5a2b247c_longest-increasing-subsequence.png","dateCreated":"2018-07-12T11:08:33.866Z","dateModified":"2018-07-14T03:26:50.263Z","contributedBy":"AskGif","content":"In this approach we will find longest increasing Subsequence using Binary Search. Time Complexity for this approach will be <strong>nlogn</strong>.\r\n<span style=\"color: #576871; font-family: OpenSans, Arial, Helvetica, sans-serif; font-size: 13px;\">The task is to find the length of the lon","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/11b79284-f1ed-4645-ade0-e4eb5a2b247c_longest-increasing-subsequence.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"interview","slug":"interview"},{"name":"java","slug":"java"},{"name":"algorithm","slug":"algorithm"},{"name":"LIS","slug":"lis"}],"slug":"find-longest-increasing-subsequence-using-binary-search","total":0}]}