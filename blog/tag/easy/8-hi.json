[{"id":1572,"title":"Binary Tree Paths - Tree - Easy - LeetCode","imageUrl":"icon_93874631-b0aa-4d7d-a413-084a6380763d.jpg","dateCreated":"2020-10-06T14:22:08.31Z","dateModified":"2020-10-06T14:22:21.599Z","contributedBy":"sumitc91","content":"Given a binary tree, return all root-to-leaf paths.\nNote: A leaf is a node with no children.\nExample:\nInput:\n&nbsp; &nbsp;1<br />&nbsp;/ &nbsp; \\<br />2 &nbsp; &nbsp; 3<br />&nbsp;\\<br />&nbsp; 5\nOutput: [\"1-&gt;2-&gt;5\", \"1-&gt;3\"]\nExplanation: All root-","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/93874631-b0aa-4d7d-a413-084a6380763d.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"binary-tree-paths-tree-easy-leetcode","total":360},{"id":1571,"title":"Path Sum - Tree - Easy - LeetCode","imageUrl":"icon_6a94315a-4048-49fe-b47e-88c1b010b589.jpg","dateCreated":"2020-10-06T14:06:06.304Z","dateModified":"2020-10-06T14:06:16.586Z","contributedBy":"sumitc91","content":"Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\nNote: A leaf is a node with no children.\nExample:\nGiven the below binary tree and sum = 22,\n&nbsp; &nbsp; &nbsp; 5<br />","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/6a94315a-4048-49fe-b47e-88c1b010b589.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"path-sum-tree-easy-leetcode","total":360},{"id":1570,"title":"Minimum Depth of Binary Tree - Tree - Easy - LeetCode","imageUrl":"icon_8accc3c3-568f-41c5-802c-290cc011c286.jpg","dateCreated":"2020-10-06T13:56:54.355Z","dateModified":"2020-10-06T13:57:05.072Z","contributedBy":"sumitc91","content":"Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample:\nGiven binary tree [3,9,20,null,null,15,7],\n&nbsp; &n","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8accc3c3-568f-41c5-802c-290cc011c286.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-depth-of-binary-tree-tree-easy-leetcode","total":360},{"id":1569,"title":"Balanced Binary Tree - Tree - Easy - LeetCode","imageUrl":"icon_a02672ff-1bfd-42f4-b3e1-900ad9c690d2.jpg","dateCreated":"2020-10-06T13:45:55.261Z","dateModified":"2020-10-06T13:46:08.3Z","contributedBy":"sumitc91","content":"Given a binary tree, determine if it is height-balanced.\nFor this problem, a height-balanced binary tree is defined as:\na binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n&nbsp;\nExample 1:\nGiven the following tre","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a02672ff-1bfd-42f4-b3e1-900ad9c690d2.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"balanced-binary-tree-tree-easy-leetcode","total":360},{"id":1568,"title":"Convert Sorted Array to Binary Search Tree - Tree - Easy - LeetCode","imageUrl":"icon_8270223b-6b31-4eef-b37f-adfc7656ad5f.jpg","dateCreated":"2020-10-06T13:26:01.868Z","dateModified":"2020-10-06T13:26:11.017Z","contributedBy":"sumitc91","content":"Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\nExample:\nGiven the s","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8270223b-6b31-4eef-b37f-adfc7656ad5f.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"convert-sorted-array-to-binary-search-tree-tree-easy-leetcode","total":360},{"id":1567,"title":"Binary Tree Level Order Traversal II - Tree - Easy - LeetCode","imageUrl":"icon_a136a23c-7eb7-4aa1-9a2b-ed03cc026177.jpg","dateCreated":"2020-10-06T13:16:59.748Z","dateModified":"2020-10-06T13:17:09.034Z","contributedBy":"sumitc91","content":"Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\nFor example:<br />Given binary tree [3,9,20,null,null,15,7],<br />&nbsp; &nbsp; 3<br />&nbsp; &nbsp;/ \\<br />&nbsp; 9 &nbsp;20<br />&nbsp; &nbsp","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a136a23c-7eb7-4aa1-9a2b-ed03cc026177.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"binary-tree-level-order-traversal-ii-tree-easy-leetcode","total":360},{"id":1566,"title":"Maximum Depth of Binary Tree - Tree - Easy - LeetCode","imageUrl":"icon_46f118cf-bf37-4c04-90b1-2d41a7561e3d.jpg","dateCreated":"2020-10-06T13:08:41.296Z","dateModified":"2020-10-06T13:08:50.491Z","contributedBy":"sumitc91","content":"Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNote: A leaf is a node with no children.\nExample:\nGiven binary tree [3,9,20,null,null,15,7],\n&nbsp; &n","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/46f118cf-bf37-4c04-90b1-2d41a7561e3d.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"maximum-depth-of-binary-tree-tree-easy-leetcode","total":360},{"id":1565,"title":"Same Tree - Tree - Easy - LeetCode","imageUrl":"icon_f30f179e-60ef-425f-aa3f-5d9d343cfe97.jpg","dateCreated":"2020-10-06T12:11:31.252Z","dateModified":"2020-10-06T12:11:43.376Z","contributedBy":"sumitc91","content":"Given two binary trees, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.\nExample 1:\nInput: &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; 1<br />&nbsp; &nbsp; &nb","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/f30f179e-60ef-425f-aa3f-5d9d343cfe97.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"same-tree-tree-easy-leetcode","total":360},{"id":1564,"title":"Number of Steps to Reduce a Number to Zero - Bit Manipulation - Easy - LeetCode","imageUrl":"icon_fd517175-fcc4-4ea1-ab97-525cf26aeabc.jpg","dateCreated":"2020-10-06T09:43:53.011Z","dateModified":"2020-10-06T09:44:13.892Z","contributedBy":"sumitc91","content":"Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.\n&nbsp;\nExample 1:\nInput: num = 14<br />Output: 6<br />Explanation:&nbsp;<br />Step 1) 14 is","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/fd517175-fcc4-4ea1-ab97-525cf26aeabc.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"bit-manipulation","slug":"bit-manipulation"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"number-of-steps-to-reduce-a-number-to-zero-bit-manipulation-easy-leetcode","total":360},{"id":1563,"title":"Prime Number of Set Bits in Binary Representation - Bit Manipulation - Easy - LeetCode","imageUrl":"icon_8ff23690-a1ec-487a-a860-51faf94bafb7.jpg","dateCreated":"2020-10-06T09:32:36.994Z","dateModified":"2020-10-06T09:32:44.766Z","contributedBy":"sumitc91","content":"Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.\n(Recall that the number of set bits an integer has is the number of 1s present when written in binary. For example, 21 written in binary i","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8ff23690-a1ec-487a-a860-51faf94bafb7.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"bit-manipulation","slug":"bit-manipulation"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"prime-number-of-set-bits-in-binary-representation-bit-manipulation-easy-leetcode","total":360},{"id":1562,"title":"Binary Number with Alternating Bits - Bit Manipulation - Easy - LeetCode","imageUrl":"icon_ddcad4a4-fb4d-4431-a952-364d812a1226.jpg","dateCreated":"2020-10-06T09:24:47.325Z","dateModified":"2020-10-06T09:24:58.56Z","contributedBy":"sumitc91","content":"Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.\n&nbsp;\nExample 1:\nInput: n = 5<br />Output: true<br />Explanation: The binary representation of 5 is: 101<br />Example 2:\nInput: n = 7<br />","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/ddcad4a4-fb4d-4431-a952-364d812a1226.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"bit-manipulation","slug":"bit-manipulation"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"binary-number-with-alternating-bits-bit-manipulation-easy-leetcode","total":360},{"id":1561,"title":"Number Complement - Bit Manipulation - Easy - LeetCode","imageUrl":"icon_b356a014-8311-4317-ac21-b43fa1f6ea7c.jpg","dateCreated":"2020-10-06T08:39:30.029Z","dateModified":"2020-10-06T08:39:39.785Z","contributedBy":"sumitc91","content":"Given a positive integer num, output its complement number. The complement strategy is to flip the bits of its binary representation.\n&nbsp;\nExample 1:\nInput: num = 5<br />Output: 2<br />Explanation: The binary representation of 5 is 101 (no leading zero bits), and its comple","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/b356a014-8311-4317-ac21-b43fa1f6ea7c.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"bit-manipulation","slug":"bit-manipulation"},{"name":"डेटा-संरचना","slug":"data-structure"},{"name":"आसान","slug":"easy"},{"name":"leetcode","slug":"leetcode"}],"slug":"number-complement-bit-manipulation-easy-leetcode","total":360}]