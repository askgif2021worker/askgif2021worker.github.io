[{"id":1573,"title":"Sum of Left Leaves - Tree - Easy - LeetCode","imageUrl":"icon_7428e4d9-3ec0-4c51-b78a-160b42c2d247.jpg","dateCreated":"2020-10-06T14:29:29.283Z","dateModified":"2020-10-06T14:29:36.996Z","contributedBy":"sumitc91","content":"Find the sum of all left leaves in a given binary tree.\nExample:\n&nbsp; &nbsp; 3<br />&nbsp; &nbsp;/ \\<br />&nbsp; 9 &nbsp;20<br />&nbsp; &nbsp; / &nbsp;\\<br />&nbsp; &nbsp;15 &nbsp; 7\nThere are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/7428e4d9-3ec0-4c51-b78a-160b42c2d247.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"sum-of-left-leaves-tree-easy-leetcode","total":40},{"id":1572,"title":"Binary Tree Paths - Tree - Easy - LeetCode","imageUrl":"icon_93874631-b0aa-4d7d-a413-084a6380763d.jpg","dateCreated":"2020-10-06T14:22:08.31Z","dateModified":"2020-10-06T14:22:21.599Z","contributedBy":"sumitc91","content":"Given a binary tree, return all root-to-leaf paths.\nNote: A leaf is a node with no children.\nExample:\nInput:\n&nbsp; &nbsp;1<br />&nbsp;/ &nbsp; \\<br />2 &nbsp; &nbsp; 3<br />&nbsp;\\<br />&nbsp; 5\nOutput: [\"1-&gt;2-&gt;5\", \"1-&gt;3\"]\nExplanation: All root-","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/93874631-b0aa-4d7d-a413-084a6380763d.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"binary-tree-paths-tree-easy-leetcode","total":40},{"id":1571,"title":"Path Sum - Tree - Easy - LeetCode","imageUrl":"icon_6a94315a-4048-49fe-b47e-88c1b010b589.jpg","dateCreated":"2020-10-06T14:06:06.304Z","dateModified":"2020-10-06T14:06:16.586Z","contributedBy":"sumitc91","content":"Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\nNote: A leaf is a node with no children.\nExample:\nGiven the below binary tree and sum = 22,\n&nbsp; &nbsp; &nbsp; 5<br />","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/6a94315a-4048-49fe-b47e-88c1b010b589.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"path-sum-tree-easy-leetcode","total":40},{"id":1570,"title":"Minimum Depth of Binary Tree - Tree - Easy - LeetCode","imageUrl":"icon_8accc3c3-568f-41c5-802c-290cc011c286.jpg","dateCreated":"2020-10-06T13:56:54.355Z","dateModified":"2020-10-06T13:57:05.072Z","contributedBy":"sumitc91","content":"Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample:\nGiven binary tree [3,9,20,null,null,15,7],\n&nbsp; &n","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8accc3c3-568f-41c5-802c-290cc011c286.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"minimum-depth-of-binary-tree-tree-easy-leetcode","total":40},{"id":1569,"title":"Balanced Binary Tree - Tree - Easy - LeetCode","imageUrl":"icon_a02672ff-1bfd-42f4-b3e1-900ad9c690d2.jpg","dateCreated":"2020-10-06T13:45:55.261Z","dateModified":"2020-10-06T13:46:08.3Z","contributedBy":"sumitc91","content":"Given a binary tree, determine if it is height-balanced.\nFor this problem, a height-balanced binary tree is defined as:\na binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n&nbsp;\nExample 1:\nGiven the following tre","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a02672ff-1bfd-42f4-b3e1-900ad9c690d2.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"balanced-binary-tree-tree-easy-leetcode","total":40},{"id":1568,"title":"Convert Sorted Array to Binary Search Tree - Tree - Easy - LeetCode","imageUrl":"icon_8270223b-6b31-4eef-b37f-adfc7656ad5f.jpg","dateCreated":"2020-10-06T13:26:01.868Z","dateModified":"2020-10-06T13:26:11.017Z","contributedBy":"sumitc91","content":"Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\nExample:\nGiven the s","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/8270223b-6b31-4eef-b37f-adfc7656ad5f.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"convert-sorted-array-to-binary-search-tree-tree-easy-leetcode","total":40},{"id":1567,"title":"Binary Tree Level Order Traversal II - Tree - Easy - LeetCode","imageUrl":"icon_a136a23c-7eb7-4aa1-9a2b-ed03cc026177.jpg","dateCreated":"2020-10-06T13:16:59.748Z","dateModified":"2020-10-06T13:17:09.034Z","contributedBy":"sumitc91","content":"Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\nFor example:<br />Given binary tree [3,9,20,null,null,15,7],<br />&nbsp; &nbsp; 3<br />&nbsp; &nbsp;/ \\<br />&nbsp; 9 &nbsp;20<br />&nbsp; &nbsp","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/a136a23c-7eb7-4aa1-9a2b-ed03cc026177.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"binary-tree-level-order-traversal-ii-tree-easy-leetcode","total":40},{"id":1566,"title":"Maximum Depth of Binary Tree - Tree - Easy - LeetCode","imageUrl":"icon_46f118cf-bf37-4c04-90b1-2d41a7561e3d.jpg","dateCreated":"2020-10-06T13:08:41.296Z","dateModified":"2020-10-06T13:08:50.491Z","contributedBy":"sumitc91","content":"Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNote: A leaf is a node with no children.\nExample:\nGiven binary tree [3,9,20,null,null,15,7],\n&nbsp; &n","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/46f118cf-bf37-4c04-90b1-2d41a7561e3d.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"maximum-depth-of-binary-tree-tree-easy-leetcode","total":40},{"id":1565,"title":"Same Tree - Tree - Easy - LeetCode","imageUrl":"icon_f30f179e-60ef-425f-aa3f-5d9d343cfe97.jpg","dateCreated":"2020-10-06T12:11:31.252Z","dateModified":"2020-10-06T12:11:43.376Z","contributedBy":"sumitc91","content":"Given two binary trees, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.\nExample 1:\nInput: &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; 1<br />&nbsp; &nbsp; &nb","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/f30f179e-60ef-425f-aa3f-5d9d343cfe97.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"algorithm","slug":"algorithm"},{"name":"binary-tree","slug":"binary-tree"},{"name":"data-structure","slug":"data-structure"},{"name":"easy","slug":"easy"},{"name":"leetcode","slug":"leetcode"},{"name":"tree","slug":"tree"}],"slug":"same-tree-tree-easy-leetcode","total":40},{"id":112,"title":"Search an element in binary tree without recursion.","imageUrl":"b3ea6acf-6279-4e29-b3cd-bb09edbc2784_binary-tree.jpg","dateCreated":"2018-08-16T09:08:38.069Z","dateModified":"2018-08-16T09:09:08.341Z","contributedBy":"AskGif","content":"We can use level order traversal for solving this problem. The only change required in level order traversal is, instead of printing the date we just need to check whether the root data is equal to the element we want to search.\r\nsource:&nbsp;Data Structures and Algorithms Made Easy in Jav","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/b3ea6acf-6279-4e29-b3cd-bb09edbc2784_binary-tree.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"interview","slug":"interview"},{"name":"java","slug":"java"},{"name":"traversal","slug":"traversal"},{"name":"tree","slug":"tree"},{"name":"questions","slug":"questions"},{"name":"binary-tree","slug":"binary-tree"},{"name":"level-order","slug":"level-order"}],"slug":"search-an-element-in-binary-tree-without-recursion","total":40},{"id":111,"title":"Find maximum element in binary tree without recursion.","imageUrl":"852f8357-9b87-4af3-9054-484bbc13f1fd_BST_Example.jpg","dateCreated":"2018-08-16T08:35:11.21Z","dateModified":"2018-08-16T08:36:54.976Z","contributedBy":"AskGif","content":"We could have used either PreOrder, InOrder or PostOrder traversal to find the maximum in a Tree but as it is mentioned that we need to find the maximum without using Recursion.\r\nUsing Level Order Traversal we can find the Maximum element. We just need to observe the elements data while de","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/852f8357-9b87-4af3-9054-484bbc13f1fd_BST_Example.jpg","category":{"name":"coding","slug":"coding"},"tags":[{"name":"level-order","slug":"level-order"},{"name":"tree","slug":"tree"},{"name":"questions","slug":"questions"},{"name":"binary-tree","slug":"binary-tree"},{"name":"algorithm","slug":"algorithm"},{"name":"interview","slug":"interview"},{"name":"traversal","slug":"traversal"}],"slug":"find-maximum-element-in-binary-tree-without-recursion","total":40},{"id":108,"title":"How to implement Level Order Traversal in Binary Tree?","imageUrl":"7833549b-eb6c-47f7-a6b0-1364f1434f70_binary_tree_breadth-first_traversal.png","dateCreated":"2018-08-14T14:06:33.296Z","dateModified":"2018-08-14T14:06:56.625Z","contributedBy":"AskGif","content":"Trees can also be traversed in level-order, where we visit every node on a level before going to a lower level. This search is referred to as a breadth-first search (BFS), as the search tree is broadened as much as possible on each depth before going to the next depth.\r\nJava implementation","ampImage":"https://raw.githubusercontent.com/sumitc91/AmpImage/main/Blogs/7833549b-eb6c-47f7-a6b0-1364f1434f70_binary_tree_breadth-first_traversal.png","category":{"name":"coding","slug":"coding"},"tags":[{"name":"java","slug":"java"},{"name":"tree","slug":"tree"},{"name":"interview","slug":"interview"},{"name":"questions","slug":"questions"},{"name":"level-order","slug":"level-order"},{"name":"traversal","slug":"traversal"}],"slug":"how-to-implement-level-order-traversal-in-binary-tree","total":40}]